import {
  __commonJS
} from "./chunk-J43GMYXM.js";

// node_modules/mapbox-gl/dist/mapbox-gl-csp.js
var require_mapbox_gl_csp = __commonJS({
  "node_modules/mapbox-gl/dist/mapbox-gl-csp.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).mapboxgl = t();
    }(exports, function() {
      "use strict";
      var e = "undefined" != typeof self ? self : {}, t = "2.12.1";
      let i;
      const r = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
        if (null == i) {
          const e2 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
          try {
            i = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : e2;
          } catch (t2) {
            i = e2;
          }
        }
        return i;
      }, get API_TILEJSON_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
      }, get API_SPRITE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
      }, get API_FONTS_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
      }, get API_STYLE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
      }, get API_CDN_URL_REGEX() {
        return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
      }, get EVENTS_URL() {
        return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;
      }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, n = { supported: false, testSupport: function(e2) {
        !a && s && (l ? c(e2) : o = e2);
      } };
      let o, s, a = false, l = false;
      function c(e2) {
        const t2 = e2.createTexture();
        e2.bindTexture(e2.TEXTURE_2D, t2);
        try {
          if (e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, e2.RGBA, e2.UNSIGNED_BYTE, s), e2.isContextLost())
            return;
          n.supported = true;
        } catch (e3) {
        }
        e2.deleteTexture(t2), a = true;
      }
      e.document && (s = e.document.createElement("img"), s.onload = function() {
        o && c(o), o = null, l = true;
      }, s.onerror = function() {
        a = true, o = null;
      }, s.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      const u = "01";
      var h = p;
      function p(e2, t2, i2, r2) {
        this.cx = 3 * e2, this.bx = 3 * (i2 - e2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t2, this.by = 3 * (r2 - t2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e2, this.p1y = t2, this.p2x = i2, this.p2y = r2;
      }
      p.prototype = { sampleCurveX: function(e2) {
        return ((this.ax * e2 + this.bx) * e2 + this.cx) * e2;
      }, sampleCurveY: function(e2) {
        return ((this.ay * e2 + this.by) * e2 + this.cy) * e2;
      }, sampleCurveDerivativeX: function(e2) {
        return (3 * this.ax * e2 + 2 * this.bx) * e2 + this.cx;
      }, solveCurveX: function(e2, t2) {
        if (void 0 === t2 && (t2 = 1e-6), e2 < 0)
          return 0;
        if (e2 > 1)
          return 1;
        for (var i2 = e2, r2 = 0; r2 < 8; r2++) {
          var n2 = this.sampleCurveX(i2) - e2;
          if (Math.abs(n2) < t2)
            return i2;
          var o2 = this.sampleCurveDerivativeX(i2);
          if (Math.abs(o2) < 1e-6)
            break;
          i2 -= n2 / o2;
        }
        var s2 = 0, a2 = 1;
        for (i2 = e2, r2 = 0; r2 < 20 && (n2 = this.sampleCurveX(i2), !(Math.abs(n2 - e2) < t2)); r2++)
          e2 > n2 ? s2 = i2 : a2 = i2, i2 = 0.5 * (a2 - s2) + s2;
        return i2;
      }, solve: function(e2, t2) {
        return this.sampleCurveY(this.solveCurveX(e2, t2));
      } };
      var d = f;
      function f(e2, t2) {
        this.x = e2, this.y = t2;
      }
      function m(e2, t2) {
        if (Array.isArray(e2)) {
          if (!Array.isArray(t2) || e2.length !== t2.length)
            return false;
          for (let i2 = 0; i2 < e2.length; i2++)
            if (!m(e2[i2], t2[i2]))
              return false;
          return true;
        }
        if ("object" == typeof e2 && null !== e2 && null !== t2) {
          if ("object" != typeof t2)
            return false;
          if (Object.keys(e2).length !== Object.keys(t2).length)
            return false;
          for (const i2 in e2)
            if (!m(e2[i2], t2[i2]))
              return false;
          return true;
        }
        return e2 === t2;
      }
      f.prototype = { clone: function() {
        return new f(this.x, this.y);
      }, add: function(e2) {
        return this.clone()._add(e2);
      }, sub: function(e2) {
        return this.clone()._sub(e2);
      }, multByPoint: function(e2) {
        return this.clone()._multByPoint(e2);
      }, divByPoint: function(e2) {
        return this.clone()._divByPoint(e2);
      }, mult: function(e2) {
        return this.clone()._mult(e2);
      }, div: function(e2) {
        return this.clone()._div(e2);
      }, rotate: function(e2) {
        return this.clone()._rotate(e2);
      }, rotateAround: function(e2, t2) {
        return this.clone()._rotateAround(e2, t2);
      }, matMult: function(e2) {
        return this.clone()._matMult(e2);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(e2) {
        return this.x === e2.x && this.y === e2.y;
      }, dist: function(e2) {
        return Math.sqrt(this.distSqr(e2));
      }, distSqr: function(e2) {
        var t2 = e2.x - this.x, i2 = e2.y - this.y;
        return t2 * t2 + i2 * i2;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(e2) {
        return Math.atan2(this.y - e2.y, this.x - e2.x);
      }, angleWith: function(e2) {
        return this.angleWithSep(e2.x, e2.y);
      }, angleWithSep: function(e2, t2) {
        return Math.atan2(this.x * t2 - this.y * e2, this.x * e2 + this.y * t2);
      }, _matMult: function(e2) {
        var t2 = e2[2] * this.x + e2[3] * this.y;
        return this.x = e2[0] * this.x + e2[1] * this.y, this.y = t2, this;
      }, _add: function(e2) {
        return this.x += e2.x, this.y += e2.y, this;
      }, _sub: function(e2) {
        return this.x -= e2.x, this.y -= e2.y, this;
      }, _mult: function(e2) {
        return this.x *= e2, this.y *= e2, this;
      }, _div: function(e2) {
        return this.x /= e2, this.y /= e2, this;
      }, _multByPoint: function(e2) {
        return this.x *= e2.x, this.y *= e2.y, this;
      }, _divByPoint: function(e2) {
        return this.x /= e2.x, this.y /= e2.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var e2 = this.y;
        return this.y = this.x, this.x = -e2, this;
      }, _rotate: function(e2) {
        var t2 = Math.cos(e2), i2 = Math.sin(e2), r2 = i2 * this.x + t2 * this.y;
        return this.x = t2 * this.x - i2 * this.y, this.y = r2, this;
      }, _rotateAround: function(e2, t2) {
        var i2 = Math.cos(e2), r2 = Math.sin(e2), n2 = t2.y + r2 * (this.x - t2.x) + i2 * (this.y - t2.y);
        return this.x = t2.x + i2 * (this.x - t2.x) - r2 * (this.y - t2.y), this.y = n2, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, f.convert = function(e2) {
        return e2 instanceof f ? e2 : Array.isArray(e2) ? new f(e2[0], e2[1]) : e2;
      };
      const _ = Math.PI / 180, g = 180 / Math.PI;
      function y(e2) {
        return e2 * _;
      }
      function x(e2) {
        return e2 * g;
      }
      const v = [[0, 0], [1, 0], [1, 1], [0, 1]];
      function b(e2) {
        if (e2 <= 0)
          return 0;
        if (e2 >= 1)
          return 1;
        const t2 = e2 * e2, i2 = t2 * e2;
        return 4 * (e2 < 0.5 ? i2 : 3 * (e2 - t2) + i2 - 0.75);
      }
      function w(e2) {
        let t2 = 1 / 0, i2 = 1 / 0, r2 = -1 / 0, n2 = -1 / 0;
        for (const o2 of e2)
          t2 = Math.min(t2, o2.x), i2 = Math.min(i2, o2.y), r2 = Math.max(r2, o2.x), n2 = Math.max(n2, o2.y);
        return { min: new d(t2, i2), max: new d(r2, n2) };
      }
      function T(e2, t2, i2 = 0, r2 = true) {
        const n2 = new d(i2, i2), o2 = e2.sub(n2), s2 = t2.add(n2), a2 = [o2, new d(s2.x, o2.y), s2, new d(o2.x, s2.y)];
        return r2 && a2.push(o2.clone()), a2;
      }
      function E(e2, t2, i2, r2) {
        const n2 = new h(e2, t2, i2, r2);
        return function(e3) {
          return n2.solve(e3);
        };
      }
      const S = E(0.25, 0.1, 0.25, 1);
      function A(e2, t2, i2) {
        return Math.min(i2, Math.max(t2, e2));
      }
      function C(e2, t2, i2) {
        return (i2 = A((i2 - e2) / (t2 - e2), 0, 1)) * i2 * (3 - 2 * i2);
      }
      function I(e2, t2, i2) {
        const r2 = i2 - t2, n2 = ((e2 - t2) % r2 + r2) % r2 + t2;
        return n2 === t2 ? i2 : n2;
      }
      function M(e2, t2, i2) {
        if (!e2.length)
          return i2(null, []);
        let r2 = e2.length;
        const n2 = new Array(e2.length);
        let o2 = null;
        e2.forEach((e3, s2) => {
          t2(e3, (e4, t3) => {
            e4 && (o2 = e4), n2[s2] = t3, 0 == --r2 && i2(o2, n2);
          });
        });
      }
      function D(e2) {
        const t2 = [];
        for (const i2 in e2)
          t2.push(e2[i2]);
        return t2;
      }
      function P(e2, ...t2) {
        for (const i2 of t2)
          for (const t3 in i2)
            e2[t3] = i2[t3];
        return e2;
      }
      function z(e2, t2) {
        const i2 = {};
        for (let r2 = 0; r2 < t2.length; r2++) {
          const n2 = t2[r2];
          n2 in e2 && (i2[n2] = e2[n2]);
        }
        return i2;
      }
      let L = 1;
      function k() {
        return L++;
      }
      function B() {
        return function e2(t2) {
          return t2 ? (t2 ^ Math.random() * (16 >> t2 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, e2);
        }();
      }
      function R(e2) {
        return e2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(e2) / Math.LN2));
      }
      function F(e2) {
        return !!e2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e2);
      }
      function O(e2, t2) {
        e2.forEach((e3) => {
          t2[e3] && (t2[e3] = t2[e3].bind(t2));
        });
      }
      function U(e2, t2) {
        return -1 !== e2.indexOf(t2, e2.length - t2.length);
      }
      function V(e2, t2, i2) {
        const r2 = {};
        for (const n2 in e2)
          r2[n2] = t2.call(i2 || this, e2[n2], n2, e2);
        return r2;
      }
      function j(e2, t2, i2) {
        const r2 = {};
        for (const n2 in e2)
          t2.call(i2 || this, e2[n2], n2, e2) && (r2[n2] = e2[n2]);
        return r2;
      }
      function N(e2) {
        return Array.isArray(e2) ? e2.map(N) : "object" == typeof e2 && e2 ? V(e2, N) : e2;
      }
      function G(e2, t2, i2, r2, n2) {
        return A((e2 - t2) / (i2 - t2) * (n2 - r2) + r2, r2, n2);
      }
      const q = {};
      function Z(e2) {
        q[e2] || ("undefined" != typeof console && console.warn(e2), q[e2] = true);
      }
      function $(e2, t2, i2) {
        return (i2.y - e2.y) * (t2.x - e2.x) > (t2.y - e2.y) * (i2.x - e2.x);
      }
      function W(e2) {
        let t2 = 0;
        for (let i2, r2, n2 = 0, o2 = e2.length, s2 = o2 - 1; n2 < o2; s2 = n2++)
          i2 = e2[n2], r2 = e2[s2], t2 += (r2.x - i2.x) * (i2.y + r2.y);
        return t2;
      }
      function H() {
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
      }
      function X(e2) {
        const t2 = {};
        if (e2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (e3, i2, r2, n2) => {
          const o2 = r2 || n2;
          return t2[i2] = !o2 || o2.toLowerCase(), "";
        }), t2["max-age"]) {
          const e3 = parseInt(t2["max-age"], 10);
          isNaN(e3) ? delete t2["max-age"] : t2["max-age"] = e3;
        }
        return t2;
      }
      let K = null;
      function Y(e2) {
        if (null == K) {
          const t2 = e2.navigator ? e2.navigator.userAgent : null;
          K = !!e2.safari || !(!t2 || !(/\b(iPad|iPhone|iPod)\b/.test(t2) || t2.match("Safari") && !t2.match("Chrome")));
        }
        return K;
      }
      function J() {
        return !!e.document.fullscreenElement || !!e.document.webkitFullscreenElement;
      }
      function Q(t2) {
        try {
          const i2 = e[t2];
          return i2.setItem("_mapbox_test_", 1), i2.removeItem("_mapbox_test_"), true;
        } catch (e2) {
          return false;
        }
      }
      function ee(e2, t2) {
        return [e2[4 * t2], e2[4 * t2 + 1], e2[4 * t2 + 2], e2[4 * t2 + 3]];
      }
      function te(e2, t2, i2) {
        e2[4 * t2 + 0] = i2[0], e2[4 * t2 + 1] = i2[1], e2[4 * t2 + 2] = i2[2], e2[4 * t2 + 3] = i2[3];
      }
      const ie = "mapbox-tiles";
      let re, ne, oe = 500, se = 50;
      function ae() {
        try {
          return e.caches;
        } catch (e2) {
        }
      }
      function le() {
        ae() && !re && (re = e.caches.open(ie));
      }
      function ce(e2) {
        const t2 = e2.indexOf("?");
        if (t2 < 0)
          return e2;
        const i2 = function(e3) {
          const t3 = e3.indexOf("?");
          return t3 > 0 ? e3.slice(t3 + 1).split("&") : [];
        }(e2), r2 = i2.filter((e3) => {
          const t3 = e3.split("=");
          return "language" === t3[0] || "worldview" === t3[0];
        });
        return r2.length ? `${e2.slice(0, t2)}?${r2.join("&")}` : e2.slice(0, t2);
      }
      let ue = 1 / 0;
      function he(e2) {
        ue++, ue > se && (e2.getActor().send("enforceCacheSizeLimit", oe), ue = 0);
      }
      const pe = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
      "function" == typeof Object.freeze && Object.freeze(pe);
      class AJAXError extends Error {
        constructor(e2, t2, i2) {
          401 === t2 && Ee(i2) && (e2 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(e2), this.status = t2, this.url = i2;
        }
        toString() {
          return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
        }
      }
      const de = H() ? () => self.worker && self.worker.referrer : () => ("blob:" === e.location.protocol ? e.parent : e).location.href;
      const fe = function(t2, i2) {
        if (!(/^file:/.test(r2 = t2.url) || /^file:/.test(de()) && !/^\w+:/.test(r2))) {
          if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty("signal"))
            return function(t3, i3) {
              const r3 = new e.AbortController(), n2 = new e.Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: de(), signal: r3.signal });
              let o2 = false, s2 = false;
              const a2 = (l2 = n2.url).indexOf("sku=") > 0 && Ee(l2);
              var l2;
              "json" === t3.type && n2.headers.set("Accept", "application/json");
              const c2 = (r4, o3, l3) => {
                if (s2)
                  return;
                if (r4 && "SecurityError" !== r4.message && Z(r4), o3 && l3)
                  return u2(o3);
                const c3 = Date.now();
                e.fetch(n2).then((e2) => {
                  if (e2.ok) {
                    const t4 = a2 ? e2.clone() : null;
                    return u2(e2, t4, c3);
                  }
                  return i3(new AJAXError(e2.statusText, e2.status, t3.url));
                }).catch((e2) => {
                  20 !== e2.code && i3(new Error(e2.message));
                });
              }, u2 = (r4, a3, l3) => {
                ("arrayBuffer" === t3.type ? r4.arrayBuffer() : "json" === t3.type ? r4.json() : r4.text()).then((t4) => {
                  s2 || (a3 && l3 && function(t5, i4, r5) {
                    if (le(), !re)
                      return;
                    const n3 = { status: i4.status, statusText: i4.statusText, headers: new e.Headers() };
                    i4.headers.forEach((e2, t6) => n3.headers.set(t6, e2));
                    const o3 = X(i4.headers.get("Cache-Control") || "");
                    if (o3["no-store"])
                      return;
                    o3["max-age"] && n3.headers.set("Expires", new Date(r5 + 1e3 * o3["max-age"]).toUTCString());
                    const s3 = n3.headers.get("Expires");
                    s3 && (new Date(s3).getTime() - r5 < 42e4 || function(e2, t6) {
                      if (void 0 === ne)
                        try {
                          new Response(new ReadableStream()), ne = true;
                        } catch (e3) {
                          ne = false;
                        }
                      ne ? t6(e2.body) : e2.blob().then(t6);
                    }(i4, (i5) => {
                      const r6 = new e.Response(i5, n3);
                      le(), re && re.then((e2) => e2.put(ce(t5.url), r6)).catch((e2) => Z(e2.message));
                    }));
                  }(n2, a3, l3), o2 = true, i3(null, t4, r4.headers.get("Cache-Control"), r4.headers.get("Expires")));
                }).catch((e2) => {
                  s2 || i3(new Error(e2.message));
                });
              };
              return a2 ? function(e2, t4) {
                if (le(), !re)
                  return t4(null);
                const i4 = ce(e2.url);
                re.then((e3) => {
                  e3.match(i4).then((r4) => {
                    const n3 = function(e4) {
                      if (!e4)
                        return false;
                      const t5 = new Date(e4.headers.get("Expires") || 0), i5 = X(e4.headers.get("Cache-Control") || "");
                      return t5 > Date.now() && !i5["no-cache"];
                    }(r4);
                    e3.delete(i4), n3 && e3.put(i4, r4.clone()), t4(null, r4, n3);
                  }).catch(t4);
                }).catch(t4);
              }(n2, c2) : c2(null, null), { cancel: () => {
                s2 = true, o2 || r3.abort();
              } };
            }(t2, i2);
          if (H() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", t2, i2, void 0, true);
        }
        var r2;
        return function(t3, i3) {
          const r3 = new e.XMLHttpRequest();
          r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer");
          for (const e2 in t3.headers)
            r3.setRequestHeader(e2, t3.headers[e2]);
          return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = () => {
            i3(new Error(r3.statusText));
          }, r3.onload = () => {
            if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
              let e2 = r3.response;
              if ("json" === t3.type)
                try {
                  e2 = JSON.parse(r3.response);
                } catch (e3) {
                  return i3(e3);
                }
              i3(null, e2, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
            } else
              i3(new AJAXError(r3.statusText, r3.status, t3.url));
          }, r3.send(t3.body), { cancel: () => r3.abort() };
        }(t2, i2);
      }, me = function(e2, t2) {
        return fe(P(e2, { type: "json" }), t2);
      }, _e = function(e2, t2) {
        return fe(P(e2, { type: "arrayBuffer" }), t2);
      };
      function ge(t2) {
        const i2 = e.document.createElement("a");
        return i2.href = t2, i2.protocol === e.document.location.protocol && i2.host === e.document.location.host;
      }
      const ye = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      let xe, ve;
      xe = [], ve = 0;
      const be = function(t2, i2) {
        if (n.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), ve >= r.MAX_PARALLEL_IMAGE_REQUESTS) {
          const e2 = { requestParameters: t2, callback: i2, cancelled: false, cancel() {
            this.cancelled = true;
          } };
          return xe.push(e2), e2;
        }
        ve++;
        let o2 = false;
        const s2 = () => {
          if (!o2)
            for (o2 = true, ve--; xe.length && ve < r.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const e2 = xe.shift(), { requestParameters: t3, callback: i3, cancelled: r2 } = e2;
              r2 || (e2.cancel = be(t3, i3).cancel);
            }
        }, a2 = _e(t2, (t3, r2, n2, o3) => {
          s2(), t3 ? i2(t3) : r2 && (e.createImageBitmap ? function(t4, i3) {
            const r3 = new e.Blob([new Uint8Array(t4)], { type: "image/png" });
            e.createImageBitmap(r3).then((e2) => {
              i3(null, e2);
            }).catch((e2) => {
              i3(new Error(`Could not load image because of ${e2.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
            });
          }(r2, (e2, t4) => i2(e2, t4, n2, o3)) : function(t4, i3) {
            const r3 = new e.Image(), n3 = e.URL;
            r3.onload = () => {
              i3(null, r3), n3.revokeObjectURL(r3.src), r3.onload = null, e.requestAnimationFrame(() => {
                r3.src = ye;
              });
            }, r3.onerror = () => i3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const o4 = new e.Blob([new Uint8Array(t4)], { type: "image/png" });
            r3.src = t4.byteLength ? n3.createObjectURL(o4) : ye;
          }(r2, (e2, t4) => i2(e2, t4, n2, o3)));
        });
        return { cancel: () => {
          a2.cancel(), s2();
        } };
      }, we = "NO_ACCESS_TOKEN";
      class RequestManager {
        constructor(e2, t2, i2) {
          this._transformRequestFn = e2, this._customAccessToken = t2, this._silenceAuthErrors = !!i2, this._createSkuToken();
        }
        _createSkuToken() {
          const e2 = function() {
            let e3 = "";
            for (let t2 = 0; t2 < 10; t2++)
              e3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", u, e3].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = e2.token, this._skuTokenExpiresAt = e2.tokenExpiresAt;
        }
        _isSkuTokenExpired() {
          return Date.now() > this._skuTokenExpiresAt;
        }
        transformRequest(e2, t2) {
          return this._transformRequestFn && this._transformRequestFn(e2, t2) || { url: e2 };
        }
        normalizeStyleURL(e2, t2) {
          if (!Te(e2))
            return e2;
          const i2 = Me(e2);
          return i2.path = `/styles/v1${i2.path}`, this._makeAPIURL(i2, this._customAccessToken || t2);
        }
        normalizeGlyphsURL(e2, t2) {
          if (!Te(e2))
            return e2;
          const i2 = Me(e2);
          return i2.path = `/fonts/v1${i2.path}`, this._makeAPIURL(i2, this._customAccessToken || t2);
        }
        normalizeSourceURL(e2, t2, i2, r2) {
          if (!Te(e2))
            return e2;
          const n2 = Me(e2);
          return n2.path = `/v4/${n2.authority}.json`, n2.params.push("secure"), i2 && n2.params.push(`language=${i2}`), r2 && n2.params.push(`worldview=${r2}`), this._makeAPIURL(n2, this._customAccessToken || t2);
        }
        normalizeSpriteURL(e2, t2, i2, r2) {
          const n2 = Me(e2);
          return Te(e2) ? (n2.path = `/styles/v1${n2.path}/sprite${t2}${i2}`, this._makeAPIURL(n2, this._customAccessToken || r2)) : (n2.path += `${t2}${i2}`, De(n2));
        }
        normalizeTileURL(e2, t2, i2) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), e2 && !Te(e2))
            return e2;
          const o2 = Me(e2);
          o2.path = o2.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${t2 || i2 && "raster" !== o2.authority && 512 === i2 ? "@2x" : ""}${n.supported ? ".webp" : "$1"}`), "raster" === o2.authority ? o2.path = `/${r.RASTER_URL_PREFIX}${o2.path}` : (o2.path = o2.path.replace(/^.+\/v4\//, "/"), o2.path = `/${r.TILE_URL_VERSION}${o2.path}`);
          const s2 = this._customAccessToken || function(e3) {
            for (const t3 of e3) {
              const e4 = t3.match(/^access_token=(.*)$/);
              if (e4)
                return e4[1];
            }
            return null;
          }(o2.params) || r.ACCESS_TOKEN;
          return r.REQUIRE_ACCESS_TOKEN && s2 && this._skuToken && o2.params.push(`sku=${this._skuToken}`), this._makeAPIURL(o2, s2);
        }
        canonicalizeTileURL(e2, t2) {
          const i2 = Me(e2);
          if (!i2.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !i2.path.match(/\.[\w]+$/))
            return e2;
          let n2 = "mapbox://";
          i2.path.match(/^\/raster\/v1\//) ? n2 += `raster/${i2.path.replace(`/${r.RASTER_URL_PREFIX}/`, "")}` : n2 += `tiles/${i2.path.replace(`/${r.TILE_URL_VERSION}/`, "")}`;
          let o2 = i2.params;
          return t2 && (o2 = o2.filter((e3) => !e3.match(/^access_token=/))), o2.length && (n2 += `?${o2.join("&")}`), n2;
        }
        canonicalizeTileset(e2, t2) {
          const i2 = !!t2 && Te(t2), r2 = [];
          for (const t3 of e2.tiles || [])
            Ee(t3) ? r2.push(this.canonicalizeTileURL(t3, i2)) : r2.push(t3);
          return r2;
        }
        _makeAPIURL(e2, t2) {
          const i2 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", n2 = Me(r.API_URL);
          if (e2.protocol = n2.protocol, e2.authority = n2.authority, "http" === e2.protocol) {
            const t3 = e2.params.indexOf("secure");
            t3 >= 0 && e2.params.splice(t3, 1);
          }
          if ("/" !== n2.path && (e2.path = `${n2.path}${e2.path}`), !r.REQUIRE_ACCESS_TOKEN)
            return De(e2);
          if (t2 = t2 || r.ACCESS_TOKEN, !this._silenceAuthErrors) {
            if (!t2)
              throw new Error(`An API access token is required to use Mapbox GL. ${i2}`);
            if ("s" === t2[0])
              throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${i2}`);
          }
          return e2.params = e2.params.filter((e3) => -1 === e3.indexOf("access_token")), e2.params.push(`access_token=${t2 || ""}`), De(e2);
        }
      }
      function Te(e2) {
        return 0 === e2.indexOf("mapbox:");
      }
      function Ee(e2) {
        return r.API_URL_REGEX.test(e2);
      }
      function Se(e2) {
        return r.API_CDN_URL_REGEX.test(e2);
      }
      function Ae(e2) {
        return r.API_STYLE_REGEX.test(e2) && !Ce(e2);
      }
      function Ce(e2) {
        return r.API_SPRITE_REGEX.test(e2);
      }
      const Ie = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function Me(e2) {
        const t2 = e2.match(Ie);
        if (!t2)
          throw new Error("Unable to parse URL object");
        return { protocol: t2[1], authority: t2[2], path: t2[3] || "/", params: t2[4] ? t2[4].split("&") : [] };
      }
      function De(e2) {
        const t2 = e2.params.length ? `?${e2.params.join("&")}` : "";
        return `${e2.protocol}://${e2.authority}${e2.path}${t2}`;
      }
      function Pe(t2) {
        if (!t2)
          return null;
        const i2 = t2.split(".");
        if (!i2 || 3 !== i2.length)
          return null;
        try {
          return JSON.parse(decodeURIComponent(e.atob(i2[1]).split("").map((e2) => "%" + ("00" + e2.charCodeAt(0).toString(16)).slice(-2)).join("")));
        } catch (e2) {
          return null;
        }
      }
      class TelemetryEvent {
        constructor(e2) {
          this.type = e2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        }
        getStorageKey(t2) {
          const i2 = Pe(r.ACCESS_TOKEN);
          let n2 = "";
          return n2 = i2 && i2.u ? e.btoa(encodeURIComponent(i2.u).replace(/%([0-9A-F]{2})/g, (e2, t3) => String.fromCharCode(Number("0x" + t3)))) : r.ACCESS_TOKEN || "", t2 ? `mapbox.eventData.${t2}:${n2}` : `mapbox.eventData:${n2}`;
        }
        fetchEventData() {
          const t2 = Q("localStorage"), i2 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
          if (t2)
            try {
              const t3 = e.localStorage.getItem(i2);
              t3 && (this.eventData = JSON.parse(t3));
              const n2 = e.localStorage.getItem(r2);
              n2 && (this.anonId = n2);
            } catch (e2) {
              Z("Unable to read from LocalStorage");
            }
        }
        saveEventData() {
          const t2 = Q("localStorage"), i2 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
          if (t2)
            try {
              e.localStorage.setItem(r2, this.anonId), Object.keys(this.eventData).length >= 1 && e.localStorage.setItem(i2, JSON.stringify(this.eventData));
            } catch (e2) {
              Z("Unable to write to LocalStorage");
            }
        }
        processRequests(e2) {
        }
        postEvent(e2, t2, i2, n2) {
          if (!r.EVENTS_URL)
            return;
          const o2 = Me(r.EVENTS_URL);
          o2.params.push(`access_token=${n2 || r.ACCESS_TOKEN || ""}`);
          const s2 = { event: this.type, created: new Date(e2).toISOString() }, a2 = t2 ? P(s2, t2) : s2, l2 = { url: De(o2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([a2]) };
          this.pendingRequest = function(e3, t3) {
            return fe(P(e3, { method: "POST" }), t3);
          }(l2, (e3) => {
            this.pendingRequest = null, i2(e3), this.saveEventData(), this.processRequests(n2);
          });
        }
        queueRequest(e2, t2) {
          this.queue.push(e2), this.processRequests(t2);
        }
      }
      const ze = new class TurnstileEvent extends TelemetryEvent {
        constructor(e2) {
          super("appUserTurnstile"), this._customAccessToken = e2;
        }
        postTurnstileEvent(e2, t2) {
          r.EVENTS_URL && r.ACCESS_TOKEN && Array.isArray(e2) && e2.some((e3) => Te(e3) || Ee(e3)) && this.queueRequest(Date.now(), t2);
        }
        processRequests(e2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
          const i2 = Pe(r.ACCESS_TOKEN), n2 = i2 ? i2.u : r.ACCESS_TOKEN;
          let o2 = n2 !== this.eventData.tokenU;
          F(this.anonId) || (this.anonId = B(), o2 = true);
          const s2 = this.queue.shift();
          if (this.eventData.lastSuccess) {
            const e3 = new Date(this.eventData.lastSuccess), t2 = new Date(s2), i3 = (s2 - this.eventData.lastSuccess) / 864e5;
            o2 = o2 || i3 >= 1 || i3 < -1 || e3.getDate() !== t2.getDate();
          } else
            o2 = true;
          o2 ? this.postEvent(s2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: t, skuId: u, "enabled.telemetry": false, userId: this.anonId }, (e3) => {
            e3 || (this.eventData.lastSuccess = s2, this.eventData.tokenU = n2);
          }, e2) : this.processRequests();
        }
      }(), Le = ze.postTurnstileEvent.bind(ze), ke = new class MapLoadEvent extends TelemetryEvent {
        constructor() {
          super("map.load"), this.success = {}, this.skuToken = "";
        }
        postMapLoadEvent(e2, t2, i2, n2) {
          this.skuToken = t2, this.errorCb = n2, r.EVENTS_URL && (i2 || r.ACCESS_TOKEN ? this.queueRequest({ id: e2, timestamp: Date.now() }, i2) : this.errorCb(new Error(we)));
        }
        processRequests(e2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { id: i2, timestamp: r2 } = this.queue.shift();
          i2 && this.success[i2] || (this.anonId || this.fetchEventData(), F(this.anonId) || (this.anonId = B()), this.postEvent(r2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: t, skuId: u, skuToken: this.skuToken, userId: this.anonId }, (e3) => {
            e3 ? this.errorCb(e3) : i2 && (this.success[i2] = true);
          }, e2));
        }
      }(), Be = ke.postMapLoadEvent.bind(ke), Re = new class PerformanceEvent extends TelemetryEvent {
        constructor() {
          super("gljs.performance");
        }
        postPerformanceEvent(e2, t2) {
          r.EVENTS_URL && (e2 || r.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: t2 }, e2);
        }
        processRequests(i2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { timestamp: r2, performanceData: n2 } = this.queue.shift(), o2 = function(i3) {
            const r3 = e.performance.getEntriesByType("resource"), n3 = e.performance.getEntriesByType("mark"), o3 = function(e2) {
              const t2 = {};
              if (e2) {
                for (const i4 in e2)
                  if ("other" !== i4)
                    for (const r4 of e2[i4]) {
                      const e3 = `${i4}ResolveRangeMin`, n4 = `${i4}ResolveRangeMax`, o4 = `${i4}RequestCount`, s3 = `${i4}RequestCachedCount`;
                      t2[e3] = Math.min(t2[e3] || 1 / 0, r4.startTime), t2[n4] = Math.max(t2[n4] || -1 / 0, r4.responseEnd);
                      const a3 = (e4) => {
                        void 0 === t2[e4] && (t2[e4] = 0), ++t2[e4];
                      };
                      void 0 !== r4.transferSize && 0 === r4.transferSize && a3(s3), a3(o4);
                    }
              }
              return t2;
            }(function(e2, t2) {
              const i4 = {};
              if (e2)
                for (const r4 of e2) {
                  const e3 = t2(r4);
                  void 0 === i4[e3] && (i4[e3] = []), i4[e3].push(r4);
                }
              return i4;
            }(r3, qe)), s2 = e.devicePixelRatio, a2 = e.navigator.connection || e.navigator.mozConnection || e.navigator.webkitConnection, l2 = { counters: [], metadata: [], attributes: [] }, c2 = (e2, t2, i4) => {
              null != i4 && e2.push({ name: t2, value: i4.toString() });
            };
            for (const e2 in o3)
              c2(l2.counters, e2, o3[e2]);
            if (i3.interactionRange[0] !== 1 / 0 && i3.interactionRange[1] !== -1 / 0 && (c2(l2.counters, "interactionRangeMin", i3.interactionRange[0]), c2(l2.counters, "interactionRangeMax", i3.interactionRange[1])), n3)
              for (const e2 of Object.keys(Ne)) {
                const t2 = Ne[e2], i4 = n3.find((e3) => e3.name === t2);
                i4 && c2(l2.counters, t2, i4.startTime);
              }
            return c2(l2.counters, "visibilityHidden", i3.visibilityHidden), c2(l2.attributes, "style", function(e2) {
              if (e2)
                for (const t2 of e2) {
                  const e3 = t2.name.split("?")[0];
                  if (Ae(e3)) {
                    const t3 = e3.split("/").slice(-2);
                    if (2 === t3.length)
                      return `mapbox://styles/${t3[0]}/${t3[1]}`;
                  }
                }
            }(r3)), c2(l2.attributes, "terrainEnabled", i3.terrainEnabled ? "true" : "false"), c2(l2.attributes, "fogEnabled", i3.fogEnabled ? "true" : "false"), c2(l2.attributes, "projection", i3.projection), c2(l2.attributes, "zoom", i3.zoom), c2(l2.metadata, "devicePixelRatio", s2), c2(l2.metadata, "connectionEffectiveType", a2 ? a2.effectiveType : void 0), c2(l2.metadata, "navigatorUserAgent", e.navigator.userAgent), c2(l2.metadata, "screenWidth", e.screen.width), c2(l2.metadata, "screenHeight", e.screen.height), c2(l2.metadata, "windowWidth", e.innerWidth), c2(l2.metadata, "windowHeight", e.innerHeight), c2(l2.metadata, "mapWidth", i3.width / s2), c2(l2.metadata, "mapHeight", i3.height / s2), c2(l2.metadata, "webglRenderer", i3.renderer), c2(l2.metadata, "webglVendor", i3.vendor), c2(l2.metadata, "sdkVersion", t), c2(l2.metadata, "sdkIdentifier", "mapbox-gl-js"), l2;
          }(n2);
          for (const e2 of o2.metadata)
            ;
          for (const e2 of o2.counters)
            ;
          for (const e2 of o2.attributes)
            ;
          this.postEvent(r2, o2, () => {
          }, i2);
        }
      }(), Fe = Re.postPerformanceEvent.bind(Re), Oe = new class MapSessionAPI extends TelemetryEvent {
        constructor() {
          super("map.auth"), this.success = {}, this.skuToken = "";
        }
        getSession(e2, t2, i2, n2) {
          if (!r.API_URL || !r.SESSION_PATH)
            return;
          const o2 = Me(r.API_URL + r.SESSION_PATH);
          o2.params.push(`sku=${t2 || ""}`), o2.params.push(`access_token=${n2 || r.ACCESS_TOKEN || ""}`);
          const s2 = { url: De(o2), headers: { "Content-Type": "text/plain" } };
          this.pendingRequest = function(e3, t3) {
            return fe(P(e3, { method: "GET" }), t3);
          }(s2, (e3) => {
            this.pendingRequest = null, i2(e3), this.saveEventData(), this.processRequests(n2);
          });
        }
        getSessionAPI(e2, t2, i2, n2) {
          this.skuToken = t2, this.errorCb = n2, r.SESSION_PATH && r.API_URL && (i2 || r.ACCESS_TOKEN ? this.queueRequest({ id: e2, timestamp: Date.now() }, i2) : this.errorCb(new Error(we)));
        }
        processRequests(e2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { id: t2, timestamp: i2 } = this.queue.shift();
          t2 && this.success[t2] || this.getSession(i2, this.skuToken, (e3) => {
            e3 ? this.errorCb(e3) : t2 && (this.success[t2] = true);
          }, e2);
        }
      }(), Ue = Oe.getSessionAPI.bind(Oe), Ve = /* @__PURE__ */ new Set();
      function je(e2, t2) {
        t2 ? Ve.add(e2) : Ve.delete(e2);
      }
      const Ne = { create: "create", load: "load", fullLoad: "fullLoad" }, Ge = { mark(t2) {
        e.performance.mark(t2);
      }, measure(t2, i2, r2) {
        e.performance.measure(t2, i2, r2);
      } };
      function qe(e2) {
        const t2 = e2.name.split("?")[0];
        return Se(t2) && t2.includes("mapbox-gl.js") ? "javascript" : Se(t2) && t2.includes("mapbox-gl.css") ? "css" : function(e3) {
          return r.API_FONTS_REGEX.test(e3);
        }(t2) ? "fontRange" : Ce(t2) ? "sprite" : Ae(t2) ? "style" : function(e3) {
          return r.API_TILEJSON_REGEX.test(e3);
        }(t2) ? "tilejson" : "other";
      }
      var Ze = $e;
      function $e(e2) {
        return !function(e3) {
          return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return false;
            var e4, t3, i2 = new Blob([""], { type: "text/javascript" }), r2 = URL.createObjectURL(i2);
            try {
              t3 = new Worker(r2), e4 = true;
            } catch (t4) {
              e4 = false;
            }
            return t3 && t3.terminate(), URL.revokeObjectURL(r2), e4;
          }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
            var e4 = document.createElement("canvas");
            e4.width = e4.height = 1;
            var t3 = e4.getContext("2d");
            if (!t3)
              return false;
            var i2 = t3.getImageData(0, 0, 1, 1);
            return i2 && i2.width === e4.width;
          }() ? (void 0 === We[t2 = e3 && e3.failIfMajorPerformanceCaveat] && (We[t2] = function(e4) {
            var t3, i2 = function(e5) {
              var t4 = document.createElement("canvas"), i3 = Object.create($e.webGLContextAttributes);
              return i3.failIfMajorPerformanceCaveat = e5, t4.getContext("webgl", i3) || t4.getContext("experimental-webgl", i3);
            }(e4);
            if (!i2)
              return false;
            try {
              t3 = i2.createShader(i2.VERTEX_SHADER);
            } catch (e5) {
              return false;
            }
            return !(!t3 || i2.isContextLost()) && (i2.shaderSource(t3, "void main() {}"), i2.compileShader(t3), true === i2.getShaderParameter(t3, i2.COMPILE_STATUS));
          }(t2)), We[t2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
          var t2;
        }(e2);
      }
      var We = {};
      let He, Xe, Ke, Ye;
      $e.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
      const Je = { now: () => void 0 !== Ke ? Ke : e.performance.now(), setNow(e2) {
        Ke = e2;
      }, restoreNow() {
        Ke = void 0;
      }, frame(t2) {
        const i2 = e.requestAnimationFrame(t2);
        return { cancel: () => e.cancelAnimationFrame(i2) };
      }, getImageData(t2, i2 = 0) {
        const { width: r2, height: n2 } = t2;
        Ye || (Ye = e.document.createElement("canvas"));
        const o2 = Ye.getContext("2d", { willReadFrequently: true });
        if (!o2)
          throw new Error("failed to create canvas 2d context");
        return (r2 > Ye.width || n2 > Ye.height) && (Ye.width = r2, Ye.height = n2), o2.clearRect(-i2, -i2, r2 + 2 * i2, n2 + 2 * i2), o2.drawImage(t2, 0, 0, r2, n2), o2.getImageData(-i2, -i2, r2 + 2 * i2, n2 + 2 * i2);
      }, resolveURL: (t2) => (He || (He = e.document.createElement("a")), He.href = t2, He.href), get devicePixelRatio() {
        return e.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!e.matchMedia && (null == Xe && (Xe = e.matchMedia("(prefers-reduced-motion: reduce)")), Xe.matches);
      } };
      function Qe(t2, i2, r2) {
        const n2 = e.document.createElement(t2);
        return void 0 !== i2 && (n2.className = i2), r2 && r2.appendChild(n2), n2;
      }
      function et(t2, i2, r2) {
        const n2 = e.document.createElementNS("http://www.w3.org/2000/svg", t2);
        for (const e2 of Object.keys(i2))
          n2.setAttributeNS(null, e2, i2[e2]);
        return r2 && r2.appendChild(n2), n2;
      }
      const tt = e.document && e.document.documentElement.style, it = tt && void 0 !== tt.userSelect ? "userSelect" : "WebkitUserSelect";
      let rt;
      function nt() {
        tt && it && (rt = tt[it], tt[it] = "none");
      }
      function ot() {
        tt && it && (tt[it] = rt);
      }
      function st(t2) {
        t2.preventDefault(), t2.stopPropagation(), e.removeEventListener("click", st, true);
      }
      function at() {
        e.addEventListener("click", st, true), e.setTimeout(() => {
          e.removeEventListener("click", st, true);
        }, 0);
      }
      function lt(e2, t2) {
        const i2 = e2.getBoundingClientRect();
        return ht(e2, i2, t2);
      }
      function ct(e2, t2) {
        const i2 = e2.getBoundingClientRect(), r2 = [];
        for (let n2 = 0; n2 < t2.length; n2++)
          r2.push(ht(e2, i2, t2[n2]));
        return r2;
      }
      function ut(t2) {
        return void 0 !== e.InstallTrigger && 2 === t2.button && t2.ctrlKey && e.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t2.button;
      }
      function ht(e2, t2, i2) {
        const r2 = e2.offsetWidth === t2.width ? 1 : e2.offsetWidth / t2.width;
        return new d((i2.clientX - t2.left) * r2, (i2.clientY - t2.top) * r2);
      }
      function pt(e2, t2, i2) {
        i2[e2] && -1 !== i2[e2].indexOf(t2) || (i2[e2] = i2[e2] || [], i2[e2].push(t2));
      }
      function dt(e2, t2, i2) {
        if (i2 && i2[e2]) {
          const r2 = i2[e2].indexOf(t2);
          -1 !== r2 && i2[e2].splice(r2, 1);
        }
      }
      class Event {
        constructor(e2, t2 = {}) {
          P(this, t2), this.type = e2;
        }
      }
      class ErrorEvent extends Event {
        constructor(e2, t2 = {}) {
          super("error", P({ error: e2 }, t2));
        }
      }
      class Evented {
        on(e2, t2) {
          return this._listeners = this._listeners || {}, pt(e2, t2, this._listeners), this;
        }
        off(e2, t2) {
          return dt(e2, t2, this._listeners), dt(e2, t2, this._oneTimeListeners), this;
        }
        once(e2, t2) {
          return t2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, pt(e2, t2, this._oneTimeListeners), this) : new Promise((t3) => this.once(e2, t3));
        }
        fire(e2, t2) {
          "string" == typeof e2 && (e2 = new Event(e2, t2 || {}));
          const i2 = e2.type;
          if (this.listens(i2)) {
            e2.target = this;
            const t3 = this._listeners && this._listeners[i2] ? this._listeners[i2].slice() : [];
            for (const i3 of t3)
              i3.call(this, e2);
            const r2 = this._oneTimeListeners && this._oneTimeListeners[i2] ? this._oneTimeListeners[i2].slice() : [];
            for (const t4 of r2)
              dt(i2, t4, this._oneTimeListeners), t4.call(this, e2);
            const n2 = this._eventedParent;
            n2 && (P(e2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), n2.fire(e2));
          } else
            e2 instanceof ErrorEvent && console.error(e2.error);
          return this;
        }
        listens(e2) {
          return !!(this._listeners && this._listeners[e2] && this._listeners[e2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e2] && this._oneTimeListeners[e2].length > 0 || this._eventedParent && this._eventedParent.listens(e2));
        }
        setEventedParent(e2, t2) {
          return this._eventedParent = e2, this._eventedParentData = t2, this;
        }
      }
      var ft = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
      function mt(e2, ...t2) {
        for (const i2 of t2)
          for (const t3 in i2)
            e2[t3] = i2[t3];
        return e2;
      }
      function _t(e2) {
        return e2 instanceof Number || e2 instanceof String || e2 instanceof Boolean ? e2.valueOf() : e2;
      }
      function gt(e2) {
        if (Array.isArray(e2))
          return e2.map(gt);
        if (e2 instanceof Object && !(e2 instanceof Number || e2 instanceof String || e2 instanceof Boolean)) {
          const t2 = {};
          for (const i2 in e2)
            t2[i2] = gt(e2[i2]);
          return t2;
        }
        return _t(e2);
      }
      class ParsingError extends Error {
        constructor(e2, t2) {
          super(t2), this.message = t2, this.key = e2;
        }
      }
      var yt = ParsingError;
      class Scope {
        constructor(e2, t2 = []) {
          this.parent = e2, this.bindings = {};
          for (const [e3, i2] of t2)
            this.bindings[e3] = i2;
        }
        concat(e2) {
          return new Scope(this, e2);
        }
        get(e2) {
          if (this.bindings[e2])
            return this.bindings[e2];
          if (this.parent)
            return this.parent.get(e2);
          throw new Error(`${e2} not found in scope.`);
        }
        has(e2) {
          return !!this.bindings[e2] || !!this.parent && this.parent.has(e2);
        }
      }
      var xt = Scope;
      const vt = { kind: "null" }, bt = { kind: "number" }, wt = { kind: "string" }, Tt = { kind: "boolean" }, Et = { kind: "color" }, St = { kind: "object" }, Ct = { kind: "value" }, It = { kind: "collator" }, Mt = { kind: "formatted" }, Dt = { kind: "resolvedImage" };
      function Pt(e2, t2) {
        return { kind: "array", itemType: e2, N: t2 };
      }
      function zt(e2) {
        if ("array" === e2.kind) {
          const t2 = zt(e2.itemType);
          return "number" == typeof e2.N ? `array<${t2}, ${e2.N}>` : "value" === e2.itemType.kind ? "array" : `array<${t2}>`;
        }
        return e2.kind;
      }
      const Lt = [vt, bt, wt, Tt, Et, Mt, St, Pt(Ct), Dt];
      function kt(e2, t2) {
        if ("error" === t2.kind)
          return null;
        if ("array" === e2.kind) {
          if ("array" === t2.kind && (0 === t2.N && "value" === t2.itemType.kind || !kt(e2.itemType, t2.itemType)) && ("number" != typeof e2.N || e2.N === t2.N))
            return null;
        } else {
          if (e2.kind === t2.kind)
            return null;
          if ("value" === e2.kind) {
            for (const e3 of Lt)
              if (!kt(e3, t2))
                return null;
          }
        }
        return `Expected ${zt(e2)} but found ${zt(t2)} instead.`;
      }
      function Bt(e2, t2) {
        return t2.some((t3) => t3.kind === e2.kind);
      }
      function Rt(e2, t2) {
        return t2.some((t3) => "null" === t3 ? null === e2 : "array" === t3 ? Array.isArray(e2) : "object" === t3 ? e2 && !Array.isArray(e2) && "object" == typeof e2 : t3 === typeof e2);
      }
      var Ft, Ot = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
      function Ut(e2) {
        return (e2 = Math.round(e2)) < 0 ? 0 : e2 > 255 ? 255 : e2;
      }
      function Vt(e2) {
        return Ut("%" === e2[e2.length - 1] ? parseFloat(e2) / 100 * 255 : parseInt(e2));
      }
      function jt(e2) {
        return (t2 = "%" === e2[e2.length - 1] ? parseFloat(e2) / 100 : parseFloat(e2)) < 0 ? 0 : t2 > 1 ? 1 : t2;
        var t2;
      }
      function Nt(e2, t2, i2) {
        return i2 < 0 ? i2 += 1 : i2 > 1 && (i2 -= 1), 6 * i2 < 1 ? e2 + (t2 - e2) * i2 * 6 : 2 * i2 < 1 ? t2 : 3 * i2 < 2 ? e2 + (t2 - e2) * (2 / 3 - i2) * 6 : e2;
      }
      try {
        Ft = {}.parseCSSColor = function(e2) {
          var t2, i2 = e2.replace(/ /g, "").toLowerCase();
          if (i2 in Ot)
            return Ot[i2].slice();
          if ("#" === i2[0])
            return 4 === i2.length ? (t2 = parseInt(i2.substr(1), 16)) >= 0 && t2 <= 4095 ? [(3840 & t2) >> 4 | (3840 & t2) >> 8, 240 & t2 | (240 & t2) >> 4, 15 & t2 | (15 & t2) << 4, 1] : null : 7 === i2.length && (t2 = parseInt(i2.substr(1), 16)) >= 0 && t2 <= 16777215 ? [(16711680 & t2) >> 16, (65280 & t2) >> 8, 255 & t2, 1] : null;
          var r2 = i2.indexOf("("), n2 = i2.indexOf(")");
          if (-1 !== r2 && n2 + 1 === i2.length) {
            var o2 = i2.substr(0, r2), s2 = i2.substr(r2 + 1, n2 - (r2 + 1)).split(","), a2 = 1;
            switch (o2) {
              case "rgba":
                if (4 !== s2.length)
                  return null;
                a2 = jt(s2.pop());
              case "rgb":
                return 3 !== s2.length ? null : [Vt(s2[0]), Vt(s2[1]), Vt(s2[2]), a2];
              case "hsla":
                if (4 !== s2.length)
                  return null;
                a2 = jt(s2.pop());
              case "hsl":
                if (3 !== s2.length)
                  return null;
                var l2 = (parseFloat(s2[0]) % 360 + 360) % 360 / 360, c2 = jt(s2[1]), u2 = jt(s2[2]), h2 = u2 <= 0.5 ? u2 * (c2 + 1) : u2 + c2 - u2 * c2, p2 = 2 * u2 - h2;
                return [Ut(255 * Nt(p2, h2, l2 + 1 / 3)), Ut(255 * Nt(p2, h2, l2)), Ut(255 * Nt(p2, h2, l2 - 1 / 3)), a2];
              default:
                return null;
            }
          }
          return null;
        };
      } catch (e2) {
      }
      class Color {
        constructor(e2, t2, i2, r2 = 1) {
          this.r = e2, this.g = t2, this.b = i2, this.a = r2;
        }
        static parse(e2) {
          if (!e2)
            return;
          if (e2 instanceof Color)
            return e2;
          if ("string" != typeof e2)
            return;
          const t2 = Ft(e2);
          return t2 ? new Color(t2[0] / 255 * t2[3], t2[1] / 255 * t2[3], t2[2] / 255 * t2[3], t2[3]) : void 0;
        }
        toString() {
          const [e2, t2, i2, r2] = this.toArray();
          return `rgba(${Math.round(e2)},${Math.round(t2)},${Math.round(i2)},${r2})`;
        }
        toArray() {
          const { r: e2, g: t2, b: i2, a: r2 } = this;
          return 0 === r2 ? [0, 0, 0, 0] : [255 * e2 / r2, 255 * t2 / r2, 255 * i2 / r2, r2];
        }
        toArray01() {
          const { r: e2, g: t2, b: i2, a: r2 } = this;
          return 0 === r2 ? [0, 0, 0, 0] : [e2 / r2, t2 / r2, i2 / r2, r2];
        }
        toArray01PremultipliedAlpha() {
          const { r: e2, g: t2, b: i2, a: r2 } = this;
          return [e2, t2, i2, r2];
        }
      }
      Color.black = new Color(0, 0, 0, 1), Color.white = new Color(1, 1, 1, 1), Color.transparent = new Color(0, 0, 0, 0), Color.red = new Color(1, 0, 0, 1), Color.blue = new Color(0, 0, 1, 1);
      var Gt = Color;
      class Collator {
        constructor(e2, t2, i2) {
          this.sensitivity = e2 ? t2 ? "variant" : "case" : t2 ? "accent" : "base", this.locale = i2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(e2, t2) {
          return this.collator.compare(e2, t2);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class FormattedSection {
        constructor(e2, t2, i2, r2, n2) {
          this.text = e2.normalize ? e2.normalize() : e2, this.image = t2, this.scale = i2, this.fontStack = r2, this.textColor = n2;
        }
      }
      class Formatted {
        constructor(e2) {
          this.sections = e2;
        }
        static fromString(e2) {
          return new Formatted([new FormattedSection(e2, null, null, null, null)]);
        }
        isEmpty() {
          return 0 === this.sections.length || !this.sections.some((e2) => 0 !== e2.text.length || e2.image && 0 !== e2.image.name.length);
        }
        static factory(e2) {
          return e2 instanceof Formatted ? e2 : Formatted.fromString(e2);
        }
        toString() {
          return 0 === this.sections.length ? "" : this.sections.map((e2) => e2.text).join("");
        }
        serialize() {
          const e2 = ["format"];
          for (const t2 of this.sections) {
            if (t2.image) {
              e2.push(["image", t2.image.name]);
              continue;
            }
            e2.push(t2.text);
            const i2 = {};
            t2.fontStack && (i2["text-font"] = ["literal", t2.fontStack.split(",")]), t2.scale && (i2["font-scale"] = t2.scale), t2.textColor && (i2["text-color"] = ["rgba"].concat(t2.textColor.toArray())), e2.push(i2);
          }
          return e2;
        }
      }
      class ResolvedImage {
        constructor(e2) {
          this.name = e2.name, this.available = e2.available;
        }
        toString() {
          return this.name;
        }
        static fromString(e2) {
          return e2 ? new ResolvedImage({ name: e2, available: false }) : null;
        }
        serialize() {
          return ["image", this.name];
        }
      }
      function qt(e2, t2, i2, r2) {
        return "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof i2 && i2 >= 0 && i2 <= 255 ? void 0 === r2 || "number" == typeof r2 && r2 >= 0 && r2 <= 1 ? null : `Invalid rgba value [${[e2, t2, i2, r2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof r2 ? [e2, t2, i2, r2] : [e2, t2, i2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Zt(e2) {
        if (null === e2)
          return true;
        if ("string" == typeof e2)
          return true;
        if ("boolean" == typeof e2)
          return true;
        if ("number" == typeof e2)
          return true;
        if (e2 instanceof Gt)
          return true;
        if (e2 instanceof Collator)
          return true;
        if (e2 instanceof Formatted)
          return true;
        if (e2 instanceof ResolvedImage)
          return true;
        if (Array.isArray(e2)) {
          for (const t2 of e2)
            if (!Zt(t2))
              return false;
          return true;
        }
        if ("object" == typeof e2) {
          for (const t2 in e2)
            if (!Zt(e2[t2]))
              return false;
          return true;
        }
        return false;
      }
      function $t(e2) {
        if (null === e2)
          return vt;
        if ("string" == typeof e2)
          return wt;
        if ("boolean" == typeof e2)
          return Tt;
        if ("number" == typeof e2)
          return bt;
        if (e2 instanceof Gt)
          return Et;
        if (e2 instanceof Collator)
          return It;
        if (e2 instanceof Formatted)
          return Mt;
        if (e2 instanceof ResolvedImage)
          return Dt;
        if (Array.isArray(e2)) {
          const t2 = e2.length;
          let i2;
          for (const t3 of e2) {
            const e3 = $t(t3);
            if (i2) {
              if (i2 === e3)
                continue;
              i2 = Ct;
              break;
            }
            i2 = e3;
          }
          return Pt(i2 || Ct, t2);
        }
        return St;
      }
      function Wt(e2) {
        const t2 = typeof e2;
        return null === e2 ? "" : "string" === t2 || "number" === t2 || "boolean" === t2 ? String(e2) : e2 instanceof Gt || e2 instanceof Formatted || e2 instanceof ResolvedImage ? e2.toString() : JSON.stringify(e2);
      }
      class Literal {
        constructor(e2, t2) {
          this.type = e2, this.value = t2;
        }
        static parse(e2, t2) {
          if (2 !== e2.length)
            return t2.error(`'literal' expression requires exactly one argument, but found ${e2.length - 1} instead.`);
          if (!Zt(e2[1]))
            return t2.error("invalid value");
          const i2 = e2[1];
          let r2 = $t(i2);
          const n2 = t2.expectedType;
          return "array" !== r2.kind || 0 !== r2.N || !n2 || "array" !== n2.kind || "number" == typeof n2.N && 0 !== n2.N || (r2 = n2), new Literal(r2, i2);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Gt ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Formatted ? this.value.serialize() : this.value;
        }
      }
      var Ht = Literal, Xt = class RuntimeError {
        constructor(e2) {
          this.name = "ExpressionEvaluationError", this.message = e2;
        }
        toJSON() {
          return this.message;
        }
      };
      const Kt = { string: wt, number: bt, boolean: Tt, object: St };
      class Assertion {
        constructor(e2, t2) {
          this.type = e2, this.args = t2;
        }
        static parse(e2, t2) {
          if (e2.length < 2)
            return t2.error("Expected at least one argument.");
          let i2, r2 = 1;
          const n2 = e2[0];
          if ("array" === n2) {
            let n3, o3;
            if (e2.length > 2) {
              const i3 = e2[1];
              if ("string" != typeof i3 || !(i3 in Kt) || "object" === i3)
                return t2.error('The item type argument of "array" must be one of string, number, boolean', 1);
              n3 = Kt[i3], r2++;
            } else
              n3 = Ct;
            if (e2.length > 3) {
              if (null !== e2[2] && ("number" != typeof e2[2] || e2[2] < 0 || e2[2] !== Math.floor(e2[2])))
                return t2.error('The length argument to "array" must be a positive integer literal', 2);
              o3 = e2[2], r2++;
            }
            i2 = Pt(n3, o3);
          } else
            i2 = Kt[n2];
          const o2 = [];
          for (; r2 < e2.length; r2++) {
            const i3 = t2.parse(e2[r2], r2, Ct);
            if (!i3)
              return null;
            o2.push(i3);
          }
          return new Assertion(i2, o2);
        }
        evaluate(e2) {
          for (let t2 = 0; t2 < this.args.length; t2++) {
            const i2 = this.args[t2].evaluate(e2);
            if (!kt(this.type, $t(i2)))
              return i2;
            if (t2 === this.args.length - 1)
              throw new Xt(`Expected value to be of type ${zt(this.type)}, but found ${zt($t(i2))} instead.`);
          }
          return null;
        }
        eachChild(e2) {
          this.args.forEach(e2);
        }
        outputDefined() {
          return this.args.every((e2) => e2.outputDefined());
        }
        serialize() {
          const e2 = this.type, t2 = [e2.kind];
          if ("array" === e2.kind) {
            const i2 = e2.itemType;
            if ("string" === i2.kind || "number" === i2.kind || "boolean" === i2.kind) {
              t2.push(i2.kind);
              const r2 = e2.N;
              ("number" == typeof r2 || this.args.length > 1) && t2.push(r2);
            }
          }
          return t2.concat(this.args.map((e3) => e3.serialize()));
        }
      }
      var Yt = Assertion;
      class FormatExpression {
        constructor(e2) {
          this.type = Mt, this.sections = e2;
        }
        static parse(e2, t2) {
          if (e2.length < 2)
            return t2.error("Expected at least one argument.");
          const i2 = e2[1];
          if (!Array.isArray(i2) && "object" == typeof i2)
            return t2.error("First argument must be an image or text section.");
          const r2 = [];
          let n2 = false;
          for (let i3 = 1; i3 <= e2.length - 1; ++i3) {
            const o2 = e2[i3];
            if (n2 && "object" == typeof o2 && !Array.isArray(o2)) {
              n2 = false;
              let e3 = null;
              if (o2["font-scale"] && (e3 = t2.parse(o2["font-scale"], 1, bt), !e3))
                return null;
              let i4 = null;
              if (o2["text-font"] && (i4 = t2.parse(o2["text-font"], 1, Pt(wt)), !i4))
                return null;
              let s2 = null;
              if (o2["text-color"] && (s2 = t2.parse(o2["text-color"], 1, Et), !s2))
                return null;
              const a2 = r2[r2.length - 1];
              a2.scale = e3, a2.font = i4, a2.textColor = s2;
            } else {
              const o3 = t2.parse(e2[i3], 1, Ct);
              if (!o3)
                return null;
              const s2 = o3.type.kind;
              if ("string" !== s2 && "value" !== s2 && "null" !== s2 && "resolvedImage" !== s2)
                return t2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              n2 = true, r2.push({ content: o3, scale: null, font: null, textColor: null });
            }
          }
          return new FormatExpression(r2);
        }
        evaluate(e2) {
          return new Formatted(this.sections.map((t2) => {
            const i2 = t2.content.evaluate(e2);
            return $t(i2) === Dt ? new FormattedSection("", i2, null, null, null) : new FormattedSection(Wt(i2), null, t2.scale ? t2.scale.evaluate(e2) : null, t2.font ? t2.font.evaluate(e2).join(",") : null, t2.textColor ? t2.textColor.evaluate(e2) : null);
          }));
        }
        eachChild(e2) {
          for (const t2 of this.sections)
            e2(t2.content), t2.scale && e2(t2.scale), t2.font && e2(t2.font), t2.textColor && e2(t2.textColor);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const e2 = ["format"];
          for (const t2 of this.sections) {
            e2.push(t2.content.serialize());
            const i2 = {};
            t2.scale && (i2["font-scale"] = t2.scale.serialize()), t2.font && (i2["text-font"] = t2.font.serialize()), t2.textColor && (i2["text-color"] = t2.textColor.serialize()), e2.push(i2);
          }
          return e2;
        }
      }
      class ImageExpression {
        constructor(e2) {
          this.type = Dt, this.input = e2;
        }
        static parse(e2, t2) {
          if (2 !== e2.length)
            return t2.error("Expected two arguments.");
          const i2 = t2.parse(e2[1], 1, wt);
          return i2 ? new ImageExpression(i2) : t2.error("No image name provided.");
        }
        evaluate(e2) {
          const t2 = this.input.evaluate(e2), i2 = ResolvedImage.fromString(t2);
          return i2 && e2.availableImages && (i2.available = e2.availableImages.indexOf(t2) > -1), i2;
        }
        eachChild(e2) {
          e2(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["image", this.input.serialize()];
        }
      }
      const Jt = { "to-boolean": Tt, "to-color": Et, "to-number": bt, "to-string": wt };
      class Coercion {
        constructor(e2, t2) {
          this.type = e2, this.args = t2;
        }
        static parse(e2, t2) {
          if (e2.length < 2)
            return t2.error("Expected at least one argument.");
          const i2 = e2[0];
          if (("to-boolean" === i2 || "to-string" === i2) && 2 !== e2.length)
            return t2.error("Expected one argument.");
          const r2 = Jt[i2], n2 = [];
          for (let i3 = 1; i3 < e2.length; i3++) {
            const r3 = t2.parse(e2[i3], i3, Ct);
            if (!r3)
              return null;
            n2.push(r3);
          }
          return new Coercion(r2, n2);
        }
        evaluate(e2) {
          if ("boolean" === this.type.kind)
            return Boolean(this.args[0].evaluate(e2));
          if ("color" === this.type.kind) {
            let t2, i2;
            for (const r2 of this.args) {
              if (t2 = r2.evaluate(e2), i2 = null, t2 instanceof Gt)
                return t2;
              if ("string" == typeof t2) {
                const i3 = e2.parseColor(t2);
                if (i3)
                  return i3;
              } else if (Array.isArray(t2) && (i2 = t2.length < 3 || t2.length > 4 ? `Invalid rbga value ${JSON.stringify(t2)}: expected an array containing either three or four numeric values.` : qt(t2[0], t2[1], t2[2], t2[3]), !i2))
                return new Gt(t2[0] / 255, t2[1] / 255, t2[2] / 255, t2[3]);
            }
            throw new Xt(i2 || `Could not parse color from value '${"string" == typeof t2 ? t2 : String(JSON.stringify(t2))}'`);
          }
          if ("number" === this.type.kind) {
            let t2 = null;
            for (const i2 of this.args) {
              if (t2 = i2.evaluate(e2), null === t2)
                return 0;
              const r2 = Number(t2);
              if (!isNaN(r2))
                return r2;
            }
            throw new Xt(`Could not convert ${JSON.stringify(t2)} to number.`);
          }
          return "formatted" === this.type.kind ? Formatted.fromString(Wt(this.args[0].evaluate(e2))) : "resolvedImage" === this.type.kind ? ResolvedImage.fromString(Wt(this.args[0].evaluate(e2))) : Wt(this.args[0].evaluate(e2));
        }
        eachChild(e2) {
          this.args.forEach(e2);
        }
        outputDefined() {
          return this.args.every((e2) => e2.outputDefined());
        }
        serialize() {
          if ("formatted" === this.type.kind)
            return new FormatExpression([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if ("resolvedImage" === this.type.kind)
            return new ImageExpression(this.args[0]).serialize();
          const e2 = [`to-${this.type.kind}`];
          return this.eachChild((t2) => {
            e2.push(t2.serialize());
          }), e2;
        }
      }
      var Qt = Coercion;
      const ei = ["Unknown", "Point", "LineString", "Polygon"];
      var ti = class EvaluationContext {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
        }
        id() {
          return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? "number" == typeof this.feature.type ? ei[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        distanceFromCenter() {
          if (this.featureTileCoord && this.featureDistanceData) {
            const e2 = this.featureDistanceData.center, t2 = this.featureDistanceData.scale, { x: i2, y: r2 } = this.featureTileCoord;
            return this.featureDistanceData.bearing[0] * (i2 * t2 - e2[0]) + this.featureDistanceData.bearing[1] * (r2 * t2 - e2[1]);
          }
          return 0;
        }
        parseColor(e2) {
          let t2 = this._parseColorCache[e2];
          return t2 || (t2 = this._parseColorCache[e2] = Gt.parse(e2)), t2;
        }
      };
      class CompoundExpression {
        constructor(e2, t2, i2, r2) {
          this.name = e2, this.type = t2, this._evaluate = i2, this.args = r2;
        }
        evaluate(e2) {
          return this._evaluate(e2, this.args);
        }
        eachChild(e2) {
          this.args.forEach(e2);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return [this.name].concat(this.args.map((e2) => e2.serialize()));
        }
        static parse(e2, t2) {
          const i2 = e2[0], r2 = CompoundExpression.definitions[i2];
          if (!r2)
            return t2.error(`Unknown expression "${i2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const n2 = Array.isArray(r2) ? r2[0] : r2.type, o2 = Array.isArray(r2) ? [[r2[1], r2[2]]] : r2.overloads, s2 = o2.filter(([t3]) => !Array.isArray(t3) || t3.length === e2.length - 1);
          let a2 = null;
          for (const [r3, o3] of s2) {
            a2 = new Ei(t2.registry, t2.path, null, t2.scope);
            const s3 = [];
            let l2 = false;
            for (let t3 = 1; t3 < e2.length; t3++) {
              const i3 = e2[t3], n3 = Array.isArray(r3) ? r3[t3 - 1] : r3.type, o4 = a2.parse(i3, 1 + s3.length, n3);
              if (!o4) {
                l2 = true;
                break;
              }
              s3.push(o4);
            }
            if (!l2)
              if (Array.isArray(r3) && r3.length !== s3.length)
                a2.error(`Expected ${r3.length} arguments, but found ${s3.length} instead.`);
              else {
                for (let e3 = 0; e3 < s3.length; e3++) {
                  const t3 = Array.isArray(r3) ? r3[e3] : r3.type, i3 = s3[e3];
                  a2.concat(e3 + 1).checkSubtype(t3, i3.type);
                }
                if (0 === a2.errors.length)
                  return new CompoundExpression(i2, n2, o3, s3);
              }
          }
          if (1 === s2.length)
            t2.errors.push(...a2.errors);
          else {
            const i3 = (s2.length ? s2 : o2).map(([e3]) => {
              return t3 = e3, Array.isArray(t3) ? `(${t3.map(zt).join(", ")})` : `(${zt(t3.type)}...)`;
              var t3;
            }).join(" | "), r3 = [];
            for (let i4 = 1; i4 < e2.length; i4++) {
              const n3 = t2.parse(e2[i4], 1 + r3.length);
              if (!n3)
                return null;
              r3.push(zt(n3.type));
            }
            t2.error(`Expected arguments of type ${i3}, but found (${r3.join(", ")}) instead.`);
          }
          return null;
        }
        static register(e2, t2) {
          CompoundExpression.definitions = t2;
          for (const i2 in t2)
            e2[i2] = CompoundExpression;
        }
      }
      var ii = CompoundExpression;
      class CollatorExpression {
        constructor(e2, t2, i2) {
          this.type = It, this.locale = i2, this.caseSensitive = e2, this.diacriticSensitive = t2;
        }
        static parse(e2, t2) {
          if (2 !== e2.length)
            return t2.error("Expected one argument.");
          const i2 = e2[1];
          if ("object" != typeof i2 || Array.isArray(i2))
            return t2.error("Collator options argument must be an object.");
          const r2 = t2.parse(void 0 !== i2["case-sensitive"] && i2["case-sensitive"], 1, Tt);
          if (!r2)
            return null;
          const n2 = t2.parse(void 0 !== i2["diacritic-sensitive"] && i2["diacritic-sensitive"], 1, Tt);
          if (!n2)
            return null;
          let o2 = null;
          return i2.locale && (o2 = t2.parse(i2.locale, 1, wt), !o2) ? null : new CollatorExpression(r2, n2, o2);
        }
        evaluate(e2) {
          return new Collator(this.caseSensitive.evaluate(e2), this.diacriticSensitive.evaluate(e2), this.locale ? this.locale.evaluate(e2) : null);
        }
        eachChild(e2) {
          e2(this.caseSensitive), e2(this.diacriticSensitive), this.locale && e2(this.locale);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const e2 = {};
          return e2["case-sensitive"] = this.caseSensitive.serialize(), e2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (e2.locale = this.locale.serialize()), ["collator", e2];
        }
      }
      const ri = 8192;
      function ni(e2, t2) {
        e2[0] = Math.min(e2[0], t2[0]), e2[1] = Math.min(e2[1], t2[1]), e2[2] = Math.max(e2[2], t2[0]), e2[3] = Math.max(e2[3], t2[1]);
      }
      function oi(e2, t2) {
        return !(e2[0] <= t2[0] || e2[2] >= t2[2] || e2[1] <= t2[1] || e2[3] >= t2[3]);
      }
      function si(e2, t2) {
        const i2 = (180 + e2[0]) / 360, r2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e2[1] * Math.PI / 360))) / 360, n2 = Math.pow(2, t2.z);
        return [Math.round(i2 * n2 * ri), Math.round(r2 * n2 * ri)];
      }
      function ai(e2, t2, i2) {
        const r2 = e2[0] - t2[0], n2 = e2[1] - t2[1], o2 = e2[0] - i2[0], s2 = e2[1] - i2[1];
        return r2 * s2 - o2 * n2 == 0 && r2 * o2 <= 0 && n2 * s2 <= 0;
      }
      function li(e2, t2) {
        let i2 = false;
        for (let s2 = 0, a2 = t2.length; s2 < a2; s2++) {
          const a3 = t2[s2];
          for (let t3 = 0, s3 = a3.length; t3 < s3 - 1; t3++) {
            if (ai(e2, a3[t3], a3[t3 + 1]))
              return false;
            (n2 = a3[t3])[1] > (r2 = e2)[1] != (o2 = a3[t3 + 1])[1] > r2[1] && r2[0] < (o2[0] - n2[0]) * (r2[1] - n2[1]) / (o2[1] - n2[1]) + n2[0] && (i2 = !i2);
          }
        }
        var r2, n2, o2;
        return i2;
      }
      function ci(e2, t2) {
        for (let i2 = 0; i2 < t2.length; i2++)
          if (li(e2, t2[i2]))
            return true;
        return false;
      }
      function ui(e2, t2, i2, r2) {
        const n2 = r2[0] - i2[0], o2 = r2[1] - i2[1], s2 = (e2[0] - i2[0]) * o2 - n2 * (e2[1] - i2[1]), a2 = (t2[0] - i2[0]) * o2 - n2 * (t2[1] - i2[1]);
        return s2 > 0 && a2 < 0 || s2 < 0 && a2 > 0;
      }
      function hi(e2, t2, i2) {
        for (const c2 of i2)
          for (let i3 = 0; i3 < c2.length - 1; ++i3)
            if (0 != (a2 = [(s2 = c2[i3 + 1])[0] - (o2 = c2[i3])[0], s2[1] - o2[1]])[0] * (l2 = [(n2 = t2)[0] - (r2 = e2)[0], n2[1] - r2[1]])[1] - a2[1] * l2[0] && ui(r2, n2, o2, s2) && ui(o2, s2, r2, n2))
              return true;
        var r2, n2, o2, s2, a2, l2;
        return false;
      }
      function pi(e2, t2) {
        for (let i2 = 0; i2 < e2.length; ++i2)
          if (!li(e2[i2], t2))
            return false;
        for (let i2 = 0; i2 < e2.length - 1; ++i2)
          if (hi(e2[i2], e2[i2 + 1], t2))
            return false;
        return true;
      }
      function di(e2, t2) {
        for (let i2 = 0; i2 < t2.length; i2++)
          if (pi(e2, t2[i2]))
            return true;
        return false;
      }
      function fi(e2, t2, i2) {
        const r2 = [];
        for (let n2 = 0; n2 < e2.length; n2++) {
          const o2 = [];
          for (let r3 = 0; r3 < e2[n2].length; r3++) {
            const s2 = si(e2[n2][r3], i2);
            ni(t2, s2), o2.push(s2);
          }
          r2.push(o2);
        }
        return r2;
      }
      function mi(e2, t2, i2) {
        const r2 = [];
        for (let n2 = 0; n2 < e2.length; n2++) {
          const o2 = fi(e2[n2], t2, i2);
          r2.push(o2);
        }
        return r2;
      }
      function _i(e2, t2, i2, r2) {
        if (e2[0] < i2[0] || e2[0] > i2[2]) {
          const t3 = 0.5 * r2;
          let n2 = e2[0] - i2[0] > t3 ? -r2 : i2[0] - e2[0] > t3 ? r2 : 0;
          0 === n2 && (n2 = e2[0] - i2[2] > t3 ? -r2 : i2[2] - e2[0] > t3 ? r2 : 0), e2[0] += n2;
        }
        ni(t2, e2);
      }
      function gi(e2, t2, i2, r2) {
        const n2 = Math.pow(2, r2.z) * ri, o2 = [r2.x * ri, r2.y * ri], s2 = [];
        if (!e2)
          return s2;
        for (const r3 of e2)
          for (const e3 of r3) {
            const r4 = [e3.x + o2[0], e3.y + o2[1]];
            _i(r4, t2, i2, n2), s2.push(r4);
          }
        return s2;
      }
      function yi(e2, t2, i2, r2) {
        const n2 = Math.pow(2, r2.z) * ri, o2 = [r2.x * ri, r2.y * ri], s2 = [];
        if (!e2)
          return s2;
        for (const i3 of e2) {
          const e3 = [];
          for (const r3 of i3) {
            const i4 = [r3.x + o2[0], r3.y + o2[1]];
            ni(t2, i4), e3.push(i4);
          }
          s2.push(e3);
        }
        if (t2[2] - t2[0] <= n2 / 2) {
          (a2 = t2)[0] = a2[1] = 1 / 0, a2[2] = a2[3] = -1 / 0;
          for (const e3 of s2)
            for (const r3 of e3)
              _i(r3, t2, i2, n2);
        }
        var a2;
        return s2;
      }
      class Within {
        constructor(e2, t2) {
          this.type = Tt, this.geojson = e2, this.geometries = t2;
        }
        static parse(e2, t2) {
          if (2 !== e2.length)
            return t2.error(`'within' expression requires exactly one argument, but found ${e2.length - 1} instead.`);
          if (Zt(e2[1])) {
            const t3 = e2[1];
            if ("FeatureCollection" === t3.type)
              for (let e3 = 0; e3 < t3.features.length; ++e3) {
                const i2 = t3.features[e3].geometry.type;
                if ("Polygon" === i2 || "MultiPolygon" === i2)
                  return new Within(t3, t3.features[e3].geometry);
              }
            else if ("Feature" === t3.type) {
              const e3 = t3.geometry.type;
              if ("Polygon" === e3 || "MultiPolygon" === e3)
                return new Within(t3, t3.geometry);
            } else if ("Polygon" === t3.type || "MultiPolygon" === t3.type)
              return new Within(t3, t3);
          }
          return t2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e2) {
          if (null != e2.geometry() && null != e2.canonicalID()) {
            if ("Point" === e2.geometryType())
              return function(e3, t2) {
                const i2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = e3.canonicalID();
                if (!n2)
                  return false;
                if ("Polygon" === t2.type) {
                  const o2 = fi(t2.coordinates, r2, n2), s2 = gi(e3.geometry(), i2, r2, n2);
                  if (!oi(i2, r2))
                    return false;
                  for (const e4 of s2)
                    if (!li(e4, o2))
                      return false;
                }
                if ("MultiPolygon" === t2.type) {
                  const o2 = mi(t2.coordinates, r2, n2), s2 = gi(e3.geometry(), i2, r2, n2);
                  if (!oi(i2, r2))
                    return false;
                  for (const e4 of s2)
                    if (!ci(e4, o2))
                      return false;
                }
                return true;
              }(e2, this.geometries);
            if ("LineString" === e2.geometryType())
              return function(e3, t2) {
                const i2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = e3.canonicalID();
                if (!n2)
                  return false;
                if ("Polygon" === t2.type) {
                  const o2 = fi(t2.coordinates, r2, n2), s2 = yi(e3.geometry(), i2, r2, n2);
                  if (!oi(i2, r2))
                    return false;
                  for (const e4 of s2)
                    if (!pi(e4, o2))
                      return false;
                }
                if ("MultiPolygon" === t2.type) {
                  const o2 = mi(t2.coordinates, r2, n2), s2 = yi(e3.geometry(), i2, r2, n2);
                  if (!oi(i2, r2))
                    return false;
                  for (const e4 of s2)
                    if (!di(e4, o2))
                      return false;
                }
                return true;
              }(e2, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["within", this.geojson];
        }
      }
      var xi = Within;
      function vi(e2) {
        if (e2 instanceof ii) {
          if ("get" === e2.name && 1 === e2.args.length)
            return false;
          if ("feature-state" === e2.name)
            return false;
          if ("has" === e2.name && 1 === e2.args.length)
            return false;
          if ("properties" === e2.name || "geometry-type" === e2.name || "id" === e2.name)
            return false;
          if (/^filter-/.test(e2.name))
            return false;
        }
        if (e2 instanceof xi)
          return false;
        let t2 = true;
        return e2.eachChild((e3) => {
          t2 && !vi(e3) && (t2 = false);
        }), t2;
      }
      function bi(e2) {
        if (e2 instanceof ii && "feature-state" === e2.name)
          return false;
        let t2 = true;
        return e2.eachChild((e3) => {
          t2 && !bi(e3) && (t2 = false);
        }), t2;
      }
      function wi(e2, t2) {
        if (e2 instanceof ii && t2.indexOf(e2.name) >= 0)
          return false;
        let i2 = true;
        return e2.eachChild((e3) => {
          i2 && !wi(e3, t2) && (i2 = false);
        }), i2;
      }
      class Var {
        constructor(e2, t2) {
          this.type = t2.type, this.name = e2, this.boundExpression = t2;
        }
        static parse(e2, t2) {
          if (2 !== e2.length || "string" != typeof e2[1])
            return t2.error("'var' expression requires exactly one string literal argument.");
          const i2 = e2[1];
          return t2.scope.has(i2) ? new Var(i2, t2.scope.get(i2)) : t2.error(`Unknown variable "${i2}". Make sure "${i2}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(e2) {
          return this.boundExpression.evaluate(e2);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["var", this.name];
        }
      }
      var Ti = Var;
      class ParsingContext {
        constructor(e2, t2 = [], i2, r2 = new xt(), n2 = []) {
          this.registry = e2, this.path = t2, this.key = t2.map((e3) => `[${e3}]`).join(""), this.scope = r2, this.errors = n2, this.expectedType = i2;
        }
        parse(e2, t2, i2, r2, n2 = {}) {
          return t2 ? this.concat(t2, i2, r2)._parse(e2, n2) : this._parse(e2, n2);
        }
        _parse(e2, t2) {
          function i2(e3, t3, i3) {
            return "assert" === i3 ? new Yt(t3, [e3]) : "coerce" === i3 ? new Qt(t3, [e3]) : e3;
          }
          if (null !== e2 && "string" != typeof e2 && "boolean" != typeof e2 && "number" != typeof e2 || (e2 = ["literal", e2]), Array.isArray(e2)) {
            if (0 === e2.length)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const r2 = e2[0];
            if ("string" != typeof r2)
              return this.error(`Expression name must be a string, but found ${typeof r2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const n2 = this.registry[r2];
            if (n2) {
              let r3 = n2.parse(e2, this);
              if (!r3)
                return null;
              if (this.expectedType) {
                const e3 = this.expectedType, n3 = r3.type;
                if ("string" !== e3.kind && "number" !== e3.kind && "boolean" !== e3.kind && "object" !== e3.kind && "array" !== e3.kind || "value" !== n3.kind)
                  if ("color" !== e3.kind && "formatted" !== e3.kind && "resolvedImage" !== e3.kind || "value" !== n3.kind && "string" !== n3.kind) {
                    if (this.checkSubtype(e3, n3))
                      return null;
                  } else
                    r3 = i2(r3, e3, t2.typeAnnotation || "coerce");
                else
                  r3 = i2(r3, e3, t2.typeAnnotation || "assert");
              }
              if (!(r3 instanceof Ht) && "resolvedImage" !== r3.type.kind && Si(r3)) {
                const e3 = new ti();
                try {
                  r3 = new Ht(r3.type, r3.evaluate(e3));
                } catch (e4) {
                  return this.error(e4.message), null;
                }
              }
              return r3;
            }
            return this.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(void 0 === e2 ? "'undefined' value invalid. Use null instead." : "object" == typeof e2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e2} instead.`);
        }
        concat(e2, t2, i2) {
          const r2 = "number" == typeof e2 ? this.path.concat(e2) : this.path, n2 = i2 ? this.scope.concat(i2) : this.scope;
          return new ParsingContext(this.registry, r2, t2 || null, n2, this.errors);
        }
        error(e2, ...t2) {
          const i2 = `${this.key}${t2.map((e3) => `[${e3}]`).join("")}`;
          this.errors.push(new yt(i2, e2));
        }
        checkSubtype(e2, t2) {
          const i2 = kt(e2, t2);
          return i2 && this.error(i2), i2;
        }
      }
      var Ei = ParsingContext;
      function Si(e2) {
        if (e2 instanceof Ti)
          return Si(e2.boundExpression);
        if (e2 instanceof ii && "error" === e2.name)
          return false;
        if (e2 instanceof CollatorExpression)
          return false;
        if (e2 instanceof xi)
          return false;
        const t2 = e2 instanceof Qt || e2 instanceof Yt;
        let i2 = true;
        return e2.eachChild((e3) => {
          i2 = t2 ? i2 && Si(e3) : i2 && e3 instanceof Ht;
        }), !!i2 && vi(e2) && wi(e2, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]);
      }
      function Ai(e2, t2) {
        const i2 = e2.length - 1;
        let r2, n2, o2 = 0, s2 = i2, a2 = 0;
        for (; o2 <= s2; )
          if (a2 = Math.floor((o2 + s2) / 2), r2 = e2[a2], n2 = e2[a2 + 1], r2 <= t2) {
            if (a2 === i2 || t2 < n2)
              return a2;
            o2 = a2 + 1;
          } else {
            if (!(r2 > t2))
              throw new Xt("Input is not a number.");
            s2 = a2 - 1;
          }
        return 0;
      }
      class Step {
        constructor(e2, t2, i2) {
          this.type = e2, this.input = t2, this.labels = [], this.outputs = [];
          for (const [e3, t3] of i2)
            this.labels.push(e3), this.outputs.push(t3);
        }
        static parse(e2, t2) {
          if (e2.length - 1 < 4)
            return t2.error(`Expected at least 4 arguments, but found only ${e2.length - 1}.`);
          if ((e2.length - 1) % 2 != 0)
            return t2.error("Expected an even number of arguments.");
          const i2 = t2.parse(e2[1], 1, bt);
          if (!i2)
            return null;
          const r2 = [];
          let n2 = null;
          t2.expectedType && "value" !== t2.expectedType.kind && (n2 = t2.expectedType);
          for (let i3 = 1; i3 < e2.length; i3 += 2) {
            const o2 = 1 === i3 ? -1 / 0 : e2[i3], s2 = e2[i3 + 1], a2 = i3, l2 = i3 + 1;
            if ("number" != typeof o2)
              return t2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', a2);
            if (r2.length && r2[r2.length - 1][0] >= o2)
              return t2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', a2);
            const c2 = t2.parse(s2, l2, n2);
            if (!c2)
              return null;
            n2 = n2 || c2.type, r2.push([o2, c2]);
          }
          return new Step(n2, i2, r2);
        }
        evaluate(e2) {
          const t2 = this.labels, i2 = this.outputs;
          if (1 === t2.length)
            return i2[0].evaluate(e2);
          const r2 = this.input.evaluate(e2);
          if (r2 <= t2[0])
            return i2[0].evaluate(e2);
          const n2 = t2.length;
          return r2 >= t2[n2 - 1] ? i2[n2 - 1].evaluate(e2) : i2[Ai(t2, r2)].evaluate(e2);
        }
        eachChild(e2) {
          e2(this.input);
          for (const t2 of this.outputs)
            e2(t2);
        }
        outputDefined() {
          return this.outputs.every((e2) => e2.outputDefined());
        }
        serialize() {
          const e2 = ["step", this.input.serialize()];
          for (let t2 = 0; t2 < this.labels.length; t2++)
            t2 > 0 && e2.push(this.labels[t2]), e2.push(this.outputs[t2].serialize());
          return e2;
        }
      }
      var Ci = Step;
      function Ii(e2, t2, i2) {
        return e2 * (1 - i2) + t2 * i2;
      }
      var Mi = Object.freeze({ __proto__: null, number: Ii, color: function(e2, t2, i2) {
        return new Gt(Ii(e2.r, t2.r, i2), Ii(e2.g, t2.g, i2), Ii(e2.b, t2.b, i2), Ii(e2.a, t2.a, i2));
      }, array: function(e2, t2, i2) {
        return e2.map((e3, r2) => Ii(e3, t2[r2], i2));
      } });
      const Di = 0.95047, Pi = 1.08883, zi = 4 / 29, Li = 6 / 29, ki = 3 * Li * Li, Bi = Math.PI / 180, Ri = 180 / Math.PI;
      function Fi(e2) {
        return e2 > 0.008856451679035631 ? Math.pow(e2, 1 / 3) : e2 / ki + zi;
      }
      function Oi(e2) {
        return e2 > Li ? e2 * e2 * e2 : ki * (e2 - zi);
      }
      function Ui(e2) {
        return 255 * (e2 <= 31308e-7 ? 12.92 * e2 : 1.055 * Math.pow(e2, 1 / 2.4) - 0.055);
      }
      function Vi(e2) {
        return (e2 /= 255) <= 0.04045 ? e2 / 12.92 : Math.pow((e2 + 0.055) / 1.055, 2.4);
      }
      function ji(e2) {
        const t2 = Vi(e2.r), i2 = Vi(e2.g), r2 = Vi(e2.b), n2 = Fi((0.4124564 * t2 + 0.3575761 * i2 + 0.1804375 * r2) / Di), o2 = Fi((0.2126729 * t2 + 0.7151522 * i2 + 0.072175 * r2) / 1);
        return { l: 116 * o2 - 16, a: 500 * (n2 - o2), b: 200 * (o2 - Fi((0.0193339 * t2 + 0.119192 * i2 + 0.9503041 * r2) / Pi)), alpha: e2.a };
      }
      function Ni(e2) {
        let t2 = (e2.l + 16) / 116, i2 = isNaN(e2.a) ? t2 : t2 + e2.a / 500, r2 = isNaN(e2.b) ? t2 : t2 - e2.b / 200;
        return t2 = 1 * Oi(t2), i2 = Di * Oi(i2), r2 = Pi * Oi(r2), new Gt(Ui(3.2404542 * i2 - 1.5371385 * t2 - 0.4985314 * r2), Ui(-0.969266 * i2 + 1.8760108 * t2 + 0.041556 * r2), Ui(0.0556434 * i2 - 0.2040259 * t2 + 1.0572252 * r2), e2.alpha);
      }
      function Gi(e2, t2, i2) {
        const r2 = t2 - e2;
        return e2 + i2 * (r2 > 180 || r2 < -180 ? r2 - 360 * Math.round(r2 / 360) : r2);
      }
      const qi = { forward: ji, reverse: Ni, interpolate: function(e2, t2, i2) {
        return { l: Ii(e2.l, t2.l, i2), a: Ii(e2.a, t2.a, i2), b: Ii(e2.b, t2.b, i2), alpha: Ii(e2.alpha, t2.alpha, i2) };
      } }, Zi = { forward: function(e2) {
        const { l: t2, a: i2, b: r2 } = ji(e2), n2 = Math.atan2(r2, i2) * Ri;
        return { h: n2 < 0 ? n2 + 360 : n2, c: Math.sqrt(i2 * i2 + r2 * r2), l: t2, alpha: e2.a };
      }, reverse: function(e2) {
        const t2 = e2.h * Bi, i2 = e2.c;
        return Ni({ l: e2.l, a: Math.cos(t2) * i2, b: Math.sin(t2) * i2, alpha: e2.alpha });
      }, interpolate: function(e2, t2, i2) {
        return { h: Gi(e2.h, t2.h, i2), c: Ii(e2.c, t2.c, i2), l: Ii(e2.l, t2.l, i2), alpha: Ii(e2.alpha, t2.alpha, i2) };
      } };
      var $i = Object.freeze({ __proto__: null, lab: qi, hcl: Zi });
      class Interpolate {
        constructor(e2, t2, i2, r2, n2) {
          this.type = e2, this.operator = t2, this.interpolation = i2, this.input = r2, this.labels = [], this.outputs = [];
          for (const [e3, t3] of n2)
            this.labels.push(e3), this.outputs.push(t3);
        }
        static interpolationFactor(e2, t2, i2, r2) {
          let n2 = 0;
          if ("exponential" === e2.name)
            n2 = Wi(t2, e2.base, i2, r2);
          else if ("linear" === e2.name)
            n2 = Wi(t2, 1, i2, r2);
          else if ("cubic-bezier" === e2.name) {
            const o2 = e2.controlPoints;
            n2 = new h(o2[0], o2[1], o2[2], o2[3]).solve(Wi(t2, 1, i2, r2));
          }
          return n2;
        }
        static parse(e2, t2) {
          let [i2, r2, n2, ...o2] = e2;
          if (!Array.isArray(r2) || 0 === r2.length)
            return t2.error("Expected an interpolation type expression.", 1);
          if ("linear" === r2[0])
            r2 = { name: "linear" };
          else if ("exponential" === r2[0]) {
            const e3 = r2[1];
            if ("number" != typeof e3)
              return t2.error("Exponential interpolation requires a numeric base.", 1, 1);
            r2 = { name: "exponential", base: e3 };
          } else {
            if ("cubic-bezier" !== r2[0])
              return t2.error(`Unknown interpolation type ${String(r2[0])}`, 1, 0);
            {
              const e3 = r2.slice(1);
              if (4 !== e3.length || e3.some((e4) => "number" != typeof e4 || e4 < 0 || e4 > 1))
                return t2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              r2 = { name: "cubic-bezier", controlPoints: e3 };
            }
          }
          if (e2.length - 1 < 4)
            return t2.error(`Expected at least 4 arguments, but found only ${e2.length - 1}.`);
          if ((e2.length - 1) % 2 != 0)
            return t2.error("Expected an even number of arguments.");
          if (n2 = t2.parse(n2, 2, bt), !n2)
            return null;
          const s2 = [];
          let a2 = null;
          "interpolate-hcl" === i2 || "interpolate-lab" === i2 ? a2 = Et : t2.expectedType && "value" !== t2.expectedType.kind && (a2 = t2.expectedType);
          for (let e3 = 0; e3 < o2.length; e3 += 2) {
            const i3 = o2[e3], r3 = o2[e3 + 1], n3 = e3 + 3, l2 = e3 + 4;
            if ("number" != typeof i3)
              return t2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', n3);
            if (s2.length && s2[s2.length - 1][0] >= i3)
              return t2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', n3);
            const c2 = t2.parse(r3, l2, a2);
            if (!c2)
              return null;
            a2 = a2 || c2.type, s2.push([i3, c2]);
          }
          return "number" === a2.kind || "color" === a2.kind || "array" === a2.kind && "number" === a2.itemType.kind && "number" == typeof a2.N ? new Interpolate(a2, i2, r2, n2, s2) : t2.error(`Type ${zt(a2)} is not interpolatable.`);
        }
        evaluate(e2) {
          const t2 = this.labels, i2 = this.outputs;
          if (1 === t2.length)
            return i2[0].evaluate(e2);
          const r2 = this.input.evaluate(e2);
          if (r2 <= t2[0])
            return i2[0].evaluate(e2);
          const n2 = t2.length;
          if (r2 >= t2[n2 - 1])
            return i2[n2 - 1].evaluate(e2);
          const o2 = Ai(t2, r2), s2 = Interpolate.interpolationFactor(this.interpolation, r2, t2[o2], t2[o2 + 1]), a2 = i2[o2].evaluate(e2), l2 = i2[o2 + 1].evaluate(e2);
          return "interpolate" === this.operator ? Mi[this.type.kind.toLowerCase()](a2, l2, s2) : "interpolate-hcl" === this.operator ? Zi.reverse(Zi.interpolate(Zi.forward(a2), Zi.forward(l2), s2)) : qi.reverse(qi.interpolate(qi.forward(a2), qi.forward(l2), s2));
        }
        eachChild(e2) {
          e2(this.input);
          for (const t2 of this.outputs)
            e2(t2);
        }
        outputDefined() {
          return this.outputs.every((e2) => e2.outputDefined());
        }
        serialize() {
          let e2;
          e2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          const t2 = [this.operator, e2, this.input.serialize()];
          for (let e3 = 0; e3 < this.labels.length; e3++)
            t2.push(this.labels[e3], this.outputs[e3].serialize());
          return t2;
        }
      }
      function Wi(e2, t2, i2, r2) {
        const n2 = r2 - i2, o2 = e2 - i2;
        return 0 === n2 ? 0 : 1 === t2 ? o2 / n2 : (Math.pow(t2, o2) - 1) / (Math.pow(t2, n2) - 1);
      }
      var Hi = Interpolate;
      class Coalesce {
        constructor(e2, t2) {
          this.type = e2, this.args = t2;
        }
        static parse(e2, t2) {
          if (e2.length < 2)
            return t2.error("Expectected at least one argument.");
          let i2 = null;
          const r2 = t2.expectedType;
          r2 && "value" !== r2.kind && (i2 = r2);
          const n2 = [];
          for (const r3 of e2.slice(1)) {
            const e3 = t2.parse(r3, 1 + n2.length, i2, void 0, { typeAnnotation: "omit" });
            if (!e3)
              return null;
            i2 = i2 || e3.type, n2.push(e3);
          }
          const o2 = r2 && n2.some((e3) => kt(r2, e3.type));
          return new Coalesce(o2 ? Ct : i2, n2);
        }
        evaluate(e2) {
          let t2, i2 = null, r2 = 0;
          for (const n2 of this.args) {
            if (r2++, i2 = n2.evaluate(e2), i2 && i2 instanceof ResolvedImage && !i2.available && (t2 || (t2 = i2), i2 = null, r2 === this.args.length))
              return t2;
            if (null !== i2)
              break;
          }
          return i2;
        }
        eachChild(e2) {
          this.args.forEach(e2);
        }
        outputDefined() {
          return this.args.every((e2) => e2.outputDefined());
        }
        serialize() {
          const e2 = ["coalesce"];
          return this.eachChild((t2) => {
            e2.push(t2.serialize());
          }), e2;
        }
      }
      var Xi = Coalesce;
      class Let {
        constructor(e2, t2) {
          this.type = t2.type, this.bindings = [].concat(e2), this.result = t2;
        }
        evaluate(e2) {
          return this.result.evaluate(e2);
        }
        eachChild(e2) {
          for (const t2 of this.bindings)
            e2(t2[1]);
          e2(this.result);
        }
        static parse(e2, t2) {
          if (e2.length < 4)
            return t2.error(`Expected at least 3 arguments, but found ${e2.length - 1} instead.`);
          const i2 = [];
          for (let r3 = 1; r3 < e2.length - 1; r3 += 2) {
            const n2 = e2[r3];
            if ("string" != typeof n2)
              return t2.error(`Expected string, but found ${typeof n2} instead.`, r3);
            if (/[^a-zA-Z0-9_]/.test(n2))
              return t2.error("Variable names must contain only alphanumeric characters or '_'.", r3);
            const o2 = t2.parse(e2[r3 + 1], r3 + 1);
            if (!o2)
              return null;
            i2.push([n2, o2]);
          }
          const r2 = t2.parse(e2[e2.length - 1], e2.length - 1, t2.expectedType, i2);
          return r2 ? new Let(i2, r2) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
        serialize() {
          const e2 = ["let"];
          for (const [t2, i2] of this.bindings)
            e2.push(t2, i2.serialize());
          return e2.push(this.result.serialize()), e2;
        }
      }
      var Ki = Let;
      class At {
        constructor(e2, t2, i2) {
          this.type = e2, this.index = t2, this.input = i2;
        }
        static parse(e2, t2) {
          if (3 !== e2.length)
            return t2.error(`Expected 2 arguments, but found ${e2.length - 1} instead.`);
          const i2 = t2.parse(e2[1], 1, bt), r2 = t2.parse(e2[2], 2, Pt(t2.expectedType || Ct));
          return i2 && r2 ? new At(r2.type.itemType, i2, r2) : null;
        }
        evaluate(e2) {
          const t2 = this.index.evaluate(e2), i2 = this.input.evaluate(e2);
          if (t2 < 0)
            throw new Xt(`Array index out of bounds: ${t2} < 0.`);
          if (t2 >= i2.length)
            throw new Xt(`Array index out of bounds: ${t2} > ${i2.length - 1}.`);
          if (t2 !== Math.floor(t2))
            throw new Xt(`Array index must be an integer, but found ${t2} instead.`);
          return i2[t2];
        }
        eachChild(e2) {
          e2(this.index), e2(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["at", this.index.serialize(), this.input.serialize()];
        }
      }
      var Yi = At;
      class In {
        constructor(e2, t2) {
          this.type = Tt, this.needle = e2, this.haystack = t2;
        }
        static parse(e2, t2) {
          if (3 !== e2.length)
            return t2.error(`Expected 2 arguments, but found ${e2.length - 1} instead.`);
          const i2 = t2.parse(e2[1], 1, Ct), r2 = t2.parse(e2[2], 2, Ct);
          return i2 && r2 ? Bt(i2.type, [Tt, wt, bt, vt, Ct]) ? new In(i2, r2) : t2.error(`Expected first argument to be of type boolean, string, number or null, but found ${zt(i2.type)} instead`) : null;
        }
        evaluate(e2) {
          const t2 = this.needle.evaluate(e2), i2 = this.haystack.evaluate(e2);
          if (null == i2)
            return false;
          if (!Rt(t2, ["boolean", "string", "number", "null"]))
            throw new Xt(`Expected first argument to be of type boolean, string, number or null, but found ${zt($t(t2))} instead.`);
          if (!Rt(i2, ["string", "array"]))
            throw new Xt(`Expected second argument to be of type array or string, but found ${zt($t(i2))} instead.`);
          return i2.indexOf(t2) >= 0;
        }
        eachChild(e2) {
          e2(this.needle), e2(this.haystack);
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var Ji = In;
      class IndexOf {
        constructor(e2, t2, i2) {
          this.type = bt, this.needle = e2, this.haystack = t2, this.fromIndex = i2;
        }
        static parse(e2, t2) {
          if (e2.length <= 2 || e2.length >= 5)
            return t2.error(`Expected 3 or 4 arguments, but found ${e2.length - 1} instead.`);
          const i2 = t2.parse(e2[1], 1, Ct), r2 = t2.parse(e2[2], 2, Ct);
          if (!i2 || !r2)
            return null;
          if (!Bt(i2.type, [Tt, wt, bt, vt, Ct]))
            return t2.error(`Expected first argument to be of type boolean, string, number or null, but found ${zt(i2.type)} instead`);
          if (4 === e2.length) {
            const n2 = t2.parse(e2[3], 3, bt);
            return n2 ? new IndexOf(i2, r2, n2) : null;
          }
          return new IndexOf(i2, r2);
        }
        evaluate(e2) {
          const t2 = this.needle.evaluate(e2), i2 = this.haystack.evaluate(e2);
          if (!Rt(t2, ["boolean", "string", "number", "null"]))
            throw new Xt(`Expected first argument to be of type boolean, string, number or null, but found ${zt($t(t2))} instead.`);
          if (!Rt(i2, ["string", "array"]))
            throw new Xt(`Expected second argument to be of type array or string, but found ${zt($t(i2))} instead.`);
          if (this.fromIndex) {
            const r2 = this.fromIndex.evaluate(e2);
            return i2.indexOf(t2, r2);
          }
          return i2.indexOf(t2);
        }
        eachChild(e2) {
          e2(this.needle), e2(this.haystack), this.fromIndex && e2(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (null != this.fromIndex && void 0 !== this.fromIndex) {
            const e2 = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), e2];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var Qi = IndexOf;
      class Match {
        constructor(e2, t2, i2, r2, n2, o2) {
          this.inputType = e2, this.type = t2, this.input = i2, this.cases = r2, this.outputs = n2, this.otherwise = o2;
        }
        static parse(e2, t2) {
          if (e2.length < 5)
            return t2.error(`Expected at least 4 arguments, but found only ${e2.length - 1}.`);
          if (e2.length % 2 != 1)
            return t2.error("Expected an even number of arguments.");
          let i2, r2;
          t2.expectedType && "value" !== t2.expectedType.kind && (r2 = t2.expectedType);
          const n2 = {}, o2 = [];
          for (let s3 = 2; s3 < e2.length - 1; s3 += 2) {
            let a3 = e2[s3];
            const l2 = e2[s3 + 1];
            Array.isArray(a3) || (a3 = [a3]);
            const c2 = t2.concat(s3);
            if (0 === a3.length)
              return c2.error("Expected at least one branch label.");
            for (const e3 of a3) {
              if ("number" != typeof e3 && "string" != typeof e3)
                return c2.error("Branch labels must be numbers or strings.");
              if ("number" == typeof e3 && Math.abs(e3) > Number.MAX_SAFE_INTEGER)
                return c2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if ("number" == typeof e3 && Math.floor(e3) !== e3)
                return c2.error("Numeric branch labels must be integer values.");
              if (i2) {
                if (c2.checkSubtype(i2, $t(e3)))
                  return null;
              } else
                i2 = $t(e3);
              if (void 0 !== n2[String(e3)])
                return c2.error("Branch labels must be unique.");
              n2[String(e3)] = o2.length;
            }
            const u2 = t2.parse(l2, s3, r2);
            if (!u2)
              return null;
            r2 = r2 || u2.type, o2.push(u2);
          }
          const s2 = t2.parse(e2[1], 1, Ct);
          if (!s2)
            return null;
          const a2 = t2.parse(e2[e2.length - 1], e2.length - 1, r2);
          return a2 ? "value" !== s2.type.kind && t2.concat(1).checkSubtype(i2, s2.type) ? null : new Match(i2, r2, s2, n2, o2, a2) : null;
        }
        evaluate(e2) {
          const t2 = this.input.evaluate(e2);
          return ($t(t2) === this.inputType && this.outputs[this.cases[t2]] || this.otherwise).evaluate(e2);
        }
        eachChild(e2) {
          e2(this.input), this.outputs.forEach(e2), e2(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((e2) => e2.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const e2 = ["match", this.input.serialize()], t2 = Object.keys(this.cases).sort(), i2 = [], r2 = {};
          for (const e3 of t2) {
            const t3 = r2[this.cases[e3]];
            void 0 === t3 ? (r2[this.cases[e3]] = i2.length, i2.push([this.cases[e3], [e3]])) : i2[t3][1].push(e3);
          }
          const n2 = (e3) => "number" === this.inputType.kind ? Number(e3) : e3;
          for (const [t3, r3] of i2)
            e2.push(1 === r3.length ? n2(r3[0]) : r3.map(n2)), e2.push(this.outputs[t3].serialize());
          return e2.push(this.otherwise.serialize()), e2;
        }
      }
      var er = Match;
      class Case {
        constructor(e2, t2, i2) {
          this.type = e2, this.branches = t2, this.otherwise = i2;
        }
        static parse(e2, t2) {
          if (e2.length < 4)
            return t2.error(`Expected at least 3 arguments, but found only ${e2.length - 1}.`);
          if (e2.length % 2 != 0)
            return t2.error("Expected an odd number of arguments.");
          let i2;
          t2.expectedType && "value" !== t2.expectedType.kind && (i2 = t2.expectedType);
          const r2 = [];
          for (let n3 = 1; n3 < e2.length - 1; n3 += 2) {
            const o2 = t2.parse(e2[n3], n3, Tt);
            if (!o2)
              return null;
            const s2 = t2.parse(e2[n3 + 1], n3 + 1, i2);
            if (!s2)
              return null;
            r2.push([o2, s2]), i2 = i2 || s2.type;
          }
          const n2 = t2.parse(e2[e2.length - 1], e2.length - 1, i2);
          return n2 ? new Case(i2, r2, n2) : null;
        }
        evaluate(e2) {
          for (const [t2, i2] of this.branches)
            if (t2.evaluate(e2))
              return i2.evaluate(e2);
          return this.otherwise.evaluate(e2);
        }
        eachChild(e2) {
          for (const [t2, i2] of this.branches)
            e2(t2), e2(i2);
          e2(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([e2, t2]) => t2.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const e2 = ["case"];
          return this.eachChild((t2) => {
            e2.push(t2.serialize());
          }), e2;
        }
      }
      var tr = Case;
      class Slice {
        constructor(e2, t2, i2, r2) {
          this.type = e2, this.input = t2, this.beginIndex = i2, this.endIndex = r2;
        }
        static parse(e2, t2) {
          if (e2.length <= 2 || e2.length >= 5)
            return t2.error(`Expected 3 or 4 arguments, but found ${e2.length - 1} instead.`);
          const i2 = t2.parse(e2[1], 1, Ct), r2 = t2.parse(e2[2], 2, bt);
          if (!i2 || !r2)
            return null;
          if (!Bt(i2.type, [Pt(Ct), wt, Ct]))
            return t2.error(`Expected first argument to be of type array or string, but found ${zt(i2.type)} instead`);
          if (4 === e2.length) {
            const n2 = t2.parse(e2[3], 3, bt);
            return n2 ? new Slice(i2.type, i2, r2, n2) : null;
          }
          return new Slice(i2.type, i2, r2);
        }
        evaluate(e2) {
          const t2 = this.input.evaluate(e2), i2 = this.beginIndex.evaluate(e2);
          if (!Rt(t2, ["string", "array"]))
            throw new Xt(`Expected first argument to be of type array or string, but found ${zt($t(t2))} instead.`);
          if (this.endIndex) {
            const r2 = this.endIndex.evaluate(e2);
            return t2.slice(i2, r2);
          }
          return t2.slice(i2);
        }
        eachChild(e2) {
          e2(this.input), e2(this.beginIndex), this.endIndex && e2(this.endIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (null != this.endIndex && void 0 !== this.endIndex) {
            const e2 = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), e2];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        }
      }
      var ir = Slice;
      function rr(e2, t2) {
        return "==" === e2 || "!=" === e2 ? "boolean" === t2.kind || "string" === t2.kind || "number" === t2.kind || "null" === t2.kind || "value" === t2.kind : "string" === t2.kind || "number" === t2.kind || "value" === t2.kind;
      }
      function nr(e2, t2, i2, r2) {
        return 0 === r2.compare(t2, i2);
      }
      function or(e2, t2, i2) {
        const r2 = "==" !== e2 && "!=" !== e2;
        return class Comparison {
          constructor(e3, t3, i3) {
            this.type = Tt, this.lhs = e3, this.rhs = t3, this.collator = i3, this.hasUntypedArgument = "value" === e3.type.kind || "value" === t3.type.kind;
          }
          static parse(e3, t3) {
            if (3 !== e3.length && 4 !== e3.length)
              return t3.error("Expected two or three arguments.");
            const i3 = e3[0];
            let n2 = t3.parse(e3[1], 1, Ct);
            if (!n2)
              return null;
            if (!rr(i3, n2.type))
              return t3.concat(1).error(`"${i3}" comparisons are not supported for type '${zt(n2.type)}'.`);
            let o2 = t3.parse(e3[2], 2, Ct);
            if (!o2)
              return null;
            if (!rr(i3, o2.type))
              return t3.concat(2).error(`"${i3}" comparisons are not supported for type '${zt(o2.type)}'.`);
            if (n2.type.kind !== o2.type.kind && "value" !== n2.type.kind && "value" !== o2.type.kind)
              return t3.error(`Cannot compare types '${zt(n2.type)}' and '${zt(o2.type)}'.`);
            r2 && ("value" === n2.type.kind && "value" !== o2.type.kind ? n2 = new Yt(o2.type, [n2]) : "value" !== n2.type.kind && "value" === o2.type.kind && (o2 = new Yt(n2.type, [o2])));
            let s2 = null;
            if (4 === e3.length) {
              if ("string" !== n2.type.kind && "string" !== o2.type.kind && "value" !== n2.type.kind && "value" !== o2.type.kind)
                return t3.error("Cannot use collator to compare non-string types.");
              if (s2 = t3.parse(e3[3], 3, It), !s2)
                return null;
            }
            return new Comparison(n2, o2, s2);
          }
          evaluate(n2) {
            const o2 = this.lhs.evaluate(n2), s2 = this.rhs.evaluate(n2);
            if (r2 && this.hasUntypedArgument) {
              const t3 = $t(o2), i3 = $t(s2);
              if (t3.kind !== i3.kind || "string" !== t3.kind && "number" !== t3.kind)
                throw new Xt(`Expected arguments for "${e2}" to be (string, string) or (number, number), but found (${t3.kind}, ${i3.kind}) instead.`);
            }
            if (this.collator && !r2 && this.hasUntypedArgument) {
              const e3 = $t(o2), i3 = $t(s2);
              if ("string" !== e3.kind || "string" !== i3.kind)
                return t2(n2, o2, s2);
            }
            return this.collator ? i2(n2, o2, s2, this.collator.evaluate(n2)) : t2(n2, o2, s2);
          }
          eachChild(e3) {
            e3(this.lhs), e3(this.rhs), this.collator && e3(this.collator);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            const t3 = [e2];
            return this.eachChild((e3) => {
              t3.push(e3.serialize());
            }), t3;
          }
        };
      }
      const sr = or("==", function(e2, t2, i2) {
        return t2 === i2;
      }, nr), ar = or("!=", function(e2, t2, i2) {
        return t2 !== i2;
      }, function(e2, t2, i2, r2) {
        return !nr(0, t2, i2, r2);
      }), lr = or("<", function(e2, t2, i2) {
        return t2 < i2;
      }, function(e2, t2, i2, r2) {
        return r2.compare(t2, i2) < 0;
      }), cr = or(">", function(e2, t2, i2) {
        return t2 > i2;
      }, function(e2, t2, i2, r2) {
        return r2.compare(t2, i2) > 0;
      }), ur = or("<=", function(e2, t2, i2) {
        return t2 <= i2;
      }, function(e2, t2, i2, r2) {
        return r2.compare(t2, i2) <= 0;
      }), hr = or(">=", function(e2, t2, i2) {
        return t2 >= i2;
      }, function(e2, t2, i2, r2) {
        return r2.compare(t2, i2) >= 0;
      });
      class NumberFormat {
        constructor(e2, t2, i2, r2, n2, o2) {
          this.type = wt, this.number = e2, this.locale = t2, this.currency = i2, this.unit = r2, this.minFractionDigits = n2, this.maxFractionDigits = o2;
        }
        static parse(e2, t2) {
          if (3 !== e2.length)
            return t2.error("Expected two arguments.");
          const i2 = t2.parse(e2[1], 1, bt);
          if (!i2)
            return null;
          const r2 = e2[2];
          if ("object" != typeof r2 || Array.isArray(r2))
            return t2.error("NumberFormat options argument must be an object.");
          let n2 = null;
          if (r2.locale && (n2 = t2.parse(r2.locale, 1, wt), !n2))
            return null;
          let o2 = null;
          if (r2.currency && (o2 = t2.parse(r2.currency, 1, wt), !o2))
            return null;
          let s2 = null;
          if (r2.unit && (s2 = t2.parse(r2.unit, 1, wt), !s2))
            return null;
          let a2 = null;
          if (r2["min-fraction-digits"] && (a2 = t2.parse(r2["min-fraction-digits"], 1, bt), !a2))
            return null;
          let l2 = null;
          return r2["max-fraction-digits"] && (l2 = t2.parse(r2["max-fraction-digits"], 1, bt), !l2) ? null : new NumberFormat(i2, n2, o2, s2, a2, l2);
        }
        evaluate(e2) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e2) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(e2) : void 0, unit: this.unit ? this.unit.evaluate(e2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e2) : void 0 }).format(this.number.evaluate(e2));
        }
        eachChild(e2) {
          e2(this.number), this.locale && e2(this.locale), this.currency && e2(this.currency), this.unit && e2(this.unit), this.minFractionDigits && e2(this.minFractionDigits), this.maxFractionDigits && e2(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const e2 = {};
          return this.locale && (e2.locale = this.locale.serialize()), this.currency && (e2.currency = this.currency.serialize()), this.unit && (e2.unit = this.unit.serialize()), this.minFractionDigits && (e2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (e2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), e2];
        }
      }
      class Length {
        constructor(e2) {
          this.type = bt, this.input = e2;
        }
        static parse(e2, t2) {
          if (2 !== e2.length)
            return t2.error(`Expected 1 argument, but found ${e2.length - 1} instead.`);
          const i2 = t2.parse(e2[1], 1);
          return i2 ? "array" !== i2.type.kind && "string" !== i2.type.kind && "value" !== i2.type.kind ? t2.error(`Expected argument of type string or array, but found ${zt(i2.type)} instead.`) : new Length(i2) : null;
        }
        evaluate(e2) {
          const t2 = this.input.evaluate(e2);
          if ("string" == typeof t2)
            return t2.length;
          if (Array.isArray(t2))
            return t2.length;
          throw new Xt(`Expected value to be of type string or array, but found ${zt($t(t2))} instead.`);
        }
        eachChild(e2) {
          e2(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const e2 = ["length"];
          return this.eachChild((t2) => {
            e2.push(t2.serialize());
          }), e2;
        }
      }
      const pr = { "==": sr, "!=": ar, ">": cr, "<": lr, ">=": hr, "<=": ur, array: Yt, at: Yi, boolean: Yt, case: tr, coalesce: Xi, collator: CollatorExpression, format: FormatExpression, image: ImageExpression, in: Ji, "index-of": Qi, interpolate: Hi, "interpolate-hcl": Hi, "interpolate-lab": Hi, length: Length, let: Ki, literal: Ht, match: er, number: Yt, "number-format": NumberFormat, object: Yt, slice: ir, step: Ci, string: Yt, "to-boolean": Qt, "to-color": Qt, "to-number": Qt, "to-string": Qt, var: Ti, within: xi };
      function dr(e2, [t2, i2, r2, n2]) {
        t2 = t2.evaluate(e2), i2 = i2.evaluate(e2), r2 = r2.evaluate(e2);
        const o2 = n2 ? n2.evaluate(e2) : 1, s2 = qt(t2, i2, r2, o2);
        if (s2)
          throw new Xt(s2);
        return new Gt(t2 / 255 * o2, i2 / 255 * o2, r2 / 255 * o2, o2);
      }
      function fr(e2, t2) {
        return e2 in t2;
      }
      function mr(e2, t2) {
        const i2 = t2[e2];
        return void 0 === i2 ? null : i2;
      }
      function _r(e2) {
        return { type: e2 };
      }
      ii.register(pr, { error: [{ kind: "error" }, [wt], (e2, [t2]) => {
        throw new Xt(t2.evaluate(e2));
      }], typeof: [wt, [Ct], (e2, [t2]) => zt($t(t2.evaluate(e2)))], "to-rgba": [Pt(bt, 4), [Et], (e2, [t2]) => t2.evaluate(e2).toArray()], rgb: [Et, [bt, bt, bt], dr], rgba: [Et, [bt, bt, bt, bt], dr], has: { type: Tt, overloads: [[[wt], (e2, [t2]) => fr(t2.evaluate(e2), e2.properties())], [[wt, St], (e2, [t2, i2]) => fr(t2.evaluate(e2), i2.evaluate(e2))]] }, get: { type: Ct, overloads: [[[wt], (e2, [t2]) => mr(t2.evaluate(e2), e2.properties())], [[wt, St], (e2, [t2, i2]) => mr(t2.evaluate(e2), i2.evaluate(e2))]] }, "feature-state": [Ct, [wt], (e2, [t2]) => mr(t2.evaluate(e2), e2.featureState || {})], properties: [St, [], (e2) => e2.properties()], "geometry-type": [wt, [], (e2) => e2.geometryType()], id: [Ct, [], (e2) => e2.id()], zoom: [bt, [], (e2) => e2.globals.zoom], pitch: [bt, [], (e2) => e2.globals.pitch || 0], "distance-from-center": [bt, [], (e2) => e2.distanceFromCenter()], "heatmap-density": [bt, [], (e2) => e2.globals.heatmapDensity || 0], "line-progress": [bt, [], (e2) => e2.globals.lineProgress || 0], "sky-radial-progress": [bt, [], (e2) => e2.globals.skyRadialProgress || 0], accumulated: [Ct, [], (e2) => void 0 === e2.globals.accumulated ? null : e2.globals.accumulated], "+": [bt, _r(bt), (e2, t2) => {
        let i2 = 0;
        for (const r2 of t2)
          i2 += r2.evaluate(e2);
        return i2;
      }], "*": [bt, _r(bt), (e2, t2) => {
        let i2 = 1;
        for (const r2 of t2)
          i2 *= r2.evaluate(e2);
        return i2;
      }], "-": { type: bt, overloads: [[[bt, bt], (e2, [t2, i2]) => t2.evaluate(e2) - i2.evaluate(e2)], [[bt], (e2, [t2]) => -t2.evaluate(e2)]] }, "/": [bt, [bt, bt], (e2, [t2, i2]) => t2.evaluate(e2) / i2.evaluate(e2)], "%": [bt, [bt, bt], (e2, [t2, i2]) => t2.evaluate(e2) % i2.evaluate(e2)], ln2: [bt, [], () => Math.LN2], pi: [bt, [], () => Math.PI], e: [bt, [], () => Math.E], "^": [bt, [bt, bt], (e2, [t2, i2]) => Math.pow(t2.evaluate(e2), i2.evaluate(e2))], sqrt: [bt, [bt], (e2, [t2]) => Math.sqrt(t2.evaluate(e2))], log10: [bt, [bt], (e2, [t2]) => Math.log(t2.evaluate(e2)) / Math.LN10], ln: [bt, [bt], (e2, [t2]) => Math.log(t2.evaluate(e2))], log2: [bt, [bt], (e2, [t2]) => Math.log(t2.evaluate(e2)) / Math.LN2], sin: [bt, [bt], (e2, [t2]) => Math.sin(t2.evaluate(e2))], cos: [bt, [bt], (e2, [t2]) => Math.cos(t2.evaluate(e2))], tan: [bt, [bt], (e2, [t2]) => Math.tan(t2.evaluate(e2))], asin: [bt, [bt], (e2, [t2]) => Math.asin(t2.evaluate(e2))], acos: [bt, [bt], (e2, [t2]) => Math.acos(t2.evaluate(e2))], atan: [bt, [bt], (e2, [t2]) => Math.atan(t2.evaluate(e2))], min: [bt, _r(bt), (e2, t2) => Math.min(...t2.map((t3) => t3.evaluate(e2)))], max: [bt, _r(bt), (e2, t2) => Math.max(...t2.map((t3) => t3.evaluate(e2)))], abs: [bt, [bt], (e2, [t2]) => Math.abs(t2.evaluate(e2))], round: [bt, [bt], (e2, [t2]) => {
        const i2 = t2.evaluate(e2);
        return i2 < 0 ? -Math.round(-i2) : Math.round(i2);
      }], floor: [bt, [bt], (e2, [t2]) => Math.floor(t2.evaluate(e2))], ceil: [bt, [bt], (e2, [t2]) => Math.ceil(t2.evaluate(e2))], "filter-==": [Tt, [wt, Ct], (e2, [t2, i2]) => e2.properties()[t2.value] === i2.value], "filter-id-==": [Tt, [Ct], (e2, [t2]) => e2.id() === t2.value], "filter-type-==": [Tt, [wt], (e2, [t2]) => e2.geometryType() === t2.value], "filter-<": [Tt, [wt, Ct], (e2, [t2, i2]) => {
        const r2 = e2.properties()[t2.value], n2 = i2.value;
        return typeof r2 == typeof n2 && r2 < n2;
      }], "filter-id-<": [Tt, [Ct], (e2, [t2]) => {
        const i2 = e2.id(), r2 = t2.value;
        return typeof i2 == typeof r2 && i2 < r2;
      }], "filter->": [Tt, [wt, Ct], (e2, [t2, i2]) => {
        const r2 = e2.properties()[t2.value], n2 = i2.value;
        return typeof r2 == typeof n2 && r2 > n2;
      }], "filter-id->": [Tt, [Ct], (e2, [t2]) => {
        const i2 = e2.id(), r2 = t2.value;
        return typeof i2 == typeof r2 && i2 > r2;
      }], "filter-<=": [Tt, [wt, Ct], (e2, [t2, i2]) => {
        const r2 = e2.properties()[t2.value], n2 = i2.value;
        return typeof r2 == typeof n2 && r2 <= n2;
      }], "filter-id-<=": [Tt, [Ct], (e2, [t2]) => {
        const i2 = e2.id(), r2 = t2.value;
        return typeof i2 == typeof r2 && i2 <= r2;
      }], "filter->=": [Tt, [wt, Ct], (e2, [t2, i2]) => {
        const r2 = e2.properties()[t2.value], n2 = i2.value;
        return typeof r2 == typeof n2 && r2 >= n2;
      }], "filter-id->=": [Tt, [Ct], (e2, [t2]) => {
        const i2 = e2.id(), r2 = t2.value;
        return typeof i2 == typeof r2 && i2 >= r2;
      }], "filter-has": [Tt, [Ct], (e2, [t2]) => t2.value in e2.properties()], "filter-has-id": [Tt, [], (e2) => null !== e2.id() && void 0 !== e2.id()], "filter-type-in": [Tt, [Pt(wt)], (e2, [t2]) => t2.value.indexOf(e2.geometryType()) >= 0], "filter-id-in": [Tt, [Pt(Ct)], (e2, [t2]) => t2.value.indexOf(e2.id()) >= 0], "filter-in-small": [Tt, [wt, Pt(Ct)], (e2, [t2, i2]) => i2.value.indexOf(e2.properties()[t2.value]) >= 0], "filter-in-large": [Tt, [wt, Pt(Ct)], (e2, [t2, i2]) => function(e3, t3, i3, r2) {
        for (; i3 <= r2; ) {
          const n2 = i3 + r2 >> 1;
          if (t3[n2] === e3)
            return true;
          t3[n2] > e3 ? r2 = n2 - 1 : i3 = n2 + 1;
        }
        return false;
      }(e2.properties()[t2.value], i2.value, 0, i2.value.length - 1)], all: { type: Tt, overloads: [[[Tt, Tt], (e2, [t2, i2]) => t2.evaluate(e2) && i2.evaluate(e2)], [_r(Tt), (e2, t2) => {
        for (const i2 of t2)
          if (!i2.evaluate(e2))
            return false;
        return true;
      }]] }, any: { type: Tt, overloads: [[[Tt, Tt], (e2, [t2, i2]) => t2.evaluate(e2) || i2.evaluate(e2)], [_r(Tt), (e2, t2) => {
        for (const i2 of t2)
          if (i2.evaluate(e2))
            return true;
        return false;
      }]] }, "!": [Tt, [Tt], (e2, [t2]) => !t2.evaluate(e2)], "is-supported-script": [Tt, [wt], (e2, [t2]) => {
        const i2 = e2.globals && e2.globals.isSupportedScript;
        return !i2 || i2(t2.evaluate(e2));
      }], upcase: [wt, [wt], (e2, [t2]) => t2.evaluate(e2).toUpperCase()], downcase: [wt, [wt], (e2, [t2]) => t2.evaluate(e2).toLowerCase()], concat: [wt, _r(Ct), (e2, t2) => t2.map((t3) => Wt(t3.evaluate(e2))).join("")], "resolved-locale": [wt, [It], (e2, [t2]) => t2.evaluate(e2).resolvedLocale()] });
      var gr = pr;
      function yr(e2) {
        return { result: "success", value: e2 };
      }
      function xr(e2) {
        return { result: "error", value: e2 };
      }
      function vr(e2) {
        return "data-driven" === e2["property-type"];
      }
      function br(e2) {
        return !!e2.expression && e2.expression.parameters.indexOf("zoom") > -1;
      }
      function wr(e2) {
        return !!e2.expression && e2.expression.interpolated;
      }
      function Tr(e2) {
        return e2 instanceof Number ? "number" : e2 instanceof String ? "string" : e2 instanceof Boolean ? "boolean" : Array.isArray(e2) ? "array" : null === e2 ? "null" : typeof e2;
      }
      function Er(e2) {
        return "object" == typeof e2 && null !== e2 && !Array.isArray(e2);
      }
      function Sr(e2) {
        return e2;
      }
      function Ar(e2, t2) {
        const i2 = "color" === t2.type, r2 = e2.stops && "object" == typeof e2.stops[0][0], n2 = r2 || !(r2 || void 0 !== e2.property), o2 = e2.type || (wr(t2) ? "exponential" : "interval");
        if (i2 && ((e2 = mt({}, e2)).stops && (e2.stops = e2.stops.map((e3) => [e3[0], Gt.parse(e3[1])])), e2.default = Gt.parse(e2.default ? e2.default : t2.default)), e2.colorSpace && "rgb" !== e2.colorSpace && !$i[e2.colorSpace])
          throw new Error(`Unknown color space: ${e2.colorSpace}`);
        let s2, a2, l2;
        if ("exponential" === o2)
          s2 = Dr;
        else if ("interval" === o2)
          s2 = Mr;
        else if ("categorical" === o2) {
          s2 = Ir, a2 = /* @__PURE__ */ Object.create(null);
          for (const t3 of e2.stops)
            a2[t3[0]] = t3[1];
          l2 = typeof e2.stops[0][0];
        } else {
          if ("identity" !== o2)
            throw new Error(`Unknown function type "${o2}"`);
          s2 = Pr;
        }
        if (r2) {
          const i3 = {}, r3 = [];
          for (let t3 = 0; t3 < e2.stops.length; t3++) {
            const n4 = e2.stops[t3], o4 = n4[0].zoom;
            void 0 === i3[o4] && (i3[o4] = { zoom: o4, type: e2.type, property: e2.property, default: e2.default, stops: [] }, r3.push(o4)), i3[o4].stops.push([n4[0].value, n4[1]]);
          }
          const n3 = [];
          for (const e3 of r3)
            n3.push([i3[e3].zoom, Ar(i3[e3], t2)]);
          const o3 = { name: "linear" };
          return { kind: "composite", interpolationType: o3, interpolationFactor: Hi.interpolationFactor.bind(void 0, o3), zoomStops: n3.map((e3) => e3[0]), evaluate: ({ zoom: i4 }, r4) => Dr({ stops: n3, base: e2.base }, t2, i4).evaluate(i4, r4) };
        }
        if (n2) {
          const i3 = "exponential" === o2 ? { name: "exponential", base: void 0 !== e2.base ? e2.base : 1 } : null;
          return { kind: "camera", interpolationType: i3, interpolationFactor: Hi.interpolationFactor.bind(void 0, i3), zoomStops: e2.stops.map((e3) => e3[0]), evaluate: ({ zoom: i4 }) => s2(e2, t2, i4, a2, l2) };
        }
        return { kind: "source", evaluate(i3, r3) {
          const n3 = r3 && r3.properties ? r3.properties[e2.property] : void 0;
          return void 0 === n3 ? Cr(e2.default, t2.default) : s2(e2, t2, n3, a2, l2);
        } };
      }
      function Cr(e2, t2, i2) {
        return void 0 !== e2 ? e2 : void 0 !== t2 ? t2 : void 0 !== i2 ? i2 : void 0;
      }
      function Ir(e2, t2, i2, r2, n2) {
        return Cr(typeof i2 === n2 ? r2[i2] : void 0, e2.default, t2.default);
      }
      function Mr(e2, t2, i2) {
        if ("number" !== Tr(i2))
          return Cr(e2.default, t2.default);
        const r2 = e2.stops.length;
        if (1 === r2)
          return e2.stops[0][1];
        if (i2 <= e2.stops[0][0])
          return e2.stops[0][1];
        if (i2 >= e2.stops[r2 - 1][0])
          return e2.stops[r2 - 1][1];
        const n2 = Ai(e2.stops.map((e3) => e3[0]), i2);
        return e2.stops[n2][1];
      }
      function Dr(e2, t2, i2) {
        const r2 = void 0 !== e2.base ? e2.base : 1;
        if ("number" !== Tr(i2))
          return Cr(e2.default, t2.default);
        const n2 = e2.stops.length;
        if (1 === n2)
          return e2.stops[0][1];
        if (i2 <= e2.stops[0][0])
          return e2.stops[0][1];
        if (i2 >= e2.stops[n2 - 1][0])
          return e2.stops[n2 - 1][1];
        const o2 = Ai(e2.stops.map((e3) => e3[0]), i2), s2 = function(e3, t3, i3, r3) {
          const n3 = r3 - i3, o3 = e3 - i3;
          return 0 === n3 ? 0 : 1 === t3 ? o3 / n3 : (Math.pow(t3, o3) - 1) / (Math.pow(t3, n3) - 1);
        }(i2, r2, e2.stops[o2][0], e2.stops[o2 + 1][0]), a2 = e2.stops[o2][1], l2 = e2.stops[o2 + 1][1];
        let c2 = Mi[t2.type] || Sr;
        if (e2.colorSpace && "rgb" !== e2.colorSpace) {
          const t3 = $i[e2.colorSpace];
          c2 = (e3, i3) => t3.reverse(t3.interpolate(t3.forward(e3), t3.forward(i3), s2));
        }
        return "function" == typeof a2.evaluate ? { evaluate(...e3) {
          const t3 = a2.evaluate.apply(void 0, e3), i3 = l2.evaluate.apply(void 0, e3);
          if (void 0 !== t3 && void 0 !== i3)
            return c2(t3, i3, s2);
        } } : c2(a2, l2, s2);
      }
      function Pr(e2, t2, i2) {
        return "color" === t2.type ? i2 = Gt.parse(i2) : "formatted" === t2.type ? i2 = Formatted.fromString(i2.toString()) : "resolvedImage" === t2.type ? i2 = ResolvedImage.fromString(i2.toString()) : Tr(i2) === t2.type || "enum" === t2.type && t2.values[i2] || (i2 = void 0), Cr(i2, e2.default, t2.default);
      }
      class StyleExpression {
        constructor(e2, t2) {
          this.expression = e2, this._warningHistory = {}, this._evaluator = new ti(), this._defaultValue = t2 ? function(e3) {
            return "color" === e3.type && (Er(e3.default) || Array.isArray(e3.default)) ? new Gt(0, 0, 0, 0) : "color" === e3.type ? Gt.parse(e3.default) || null : void 0 === e3.default ? null : e3.default;
          }(t2) : null, this._enumValues = t2 && "enum" === t2.type ? t2.values : null;
        }
        evaluateWithoutErrorHandling(e2, t2, i2, r2, n2, o2, s2, a2) {
          return this._evaluator.globals = e2, this._evaluator.feature = t2, this._evaluator.featureState = i2, this._evaluator.canonical = r2 || null, this._evaluator.availableImages = n2 || null, this._evaluator.formattedSection = o2, this._evaluator.featureTileCoord = s2 || null, this._evaluator.featureDistanceData = a2 || null, this.expression.evaluate(this._evaluator);
        }
        evaluate(e2, t2, i2, r2, n2, o2, s2, a2) {
          this._evaluator.globals = e2, this._evaluator.feature = t2 || null, this._evaluator.featureState = i2 || null, this._evaluator.canonical = r2 || null, this._evaluator.availableImages = n2 || null, this._evaluator.formattedSection = o2 || null, this._evaluator.featureTileCoord = s2 || null, this._evaluator.featureDistanceData = a2 || null;
          try {
            const e3 = this.expression.evaluate(this._evaluator);
            if (null == e3 || "number" == typeof e3 && e3 != e3)
              return this._defaultValue;
            if (this._enumValues && !(e3 in this._enumValues))
              throw new Xt(`Expected value to be one of ${Object.keys(this._enumValues).map((e4) => JSON.stringify(e4)).join(", ")}, but found ${JSON.stringify(e3)} instead.`);
            return e3;
          } catch (e3) {
            return this._warningHistory[e3.message] || (this._warningHistory[e3.message] = true, "undefined" != typeof console && console.warn(e3.message)), this._defaultValue;
          }
        }
      }
      function zr(e2) {
        return Array.isArray(e2) && e2.length > 0 && "string" == typeof e2[0] && e2[0] in gr;
      }
      function Lr(e2, t2) {
        const i2 = new Ei(gr, [], t2 ? function(e3) {
          const t3 = { color: Et, string: wt, number: bt, enum: wt, boolean: Tt, formatted: Mt, resolvedImage: Dt };
          return "array" === e3.type ? Pt(t3[e3.value] || Ct, e3.length) : t3[e3.type];
        }(t2) : void 0), r2 = i2.parse(e2, void 0, void 0, void 0, t2 && "string" === t2.type ? { typeAnnotation: "coerce" } : void 0);
        return r2 ? yr(new StyleExpression(r2, t2)) : xr(i2.errors);
      }
      class ZoomConstantExpression {
        constructor(e2, t2) {
          this.kind = e2, this._styleExpression = t2, this.isStateDependent = "constant" !== e2 && !bi(t2.expression);
        }
        evaluateWithoutErrorHandling(e2, t2, i2, r2, n2, o2) {
          return this._styleExpression.evaluateWithoutErrorHandling(e2, t2, i2, r2, n2, o2);
        }
        evaluate(e2, t2, i2, r2, n2, o2) {
          return this._styleExpression.evaluate(e2, t2, i2, r2, n2, o2);
        }
      }
      class ZoomDependentExpression {
        constructor(e2, t2, i2, r2) {
          this.kind = e2, this.zoomStops = i2, this._styleExpression = t2, this.isStateDependent = "camera" !== e2 && !bi(t2.expression), this.interpolationType = r2;
        }
        evaluateWithoutErrorHandling(e2, t2, i2, r2, n2, o2) {
          return this._styleExpression.evaluateWithoutErrorHandling(e2, t2, i2, r2, n2, o2);
        }
        evaluate(e2, t2, i2, r2, n2, o2) {
          return this._styleExpression.evaluate(e2, t2, i2, r2, n2, o2);
        }
        interpolationFactor(e2, t2, i2) {
          return this.interpolationType ? Hi.interpolationFactor(this.interpolationType, e2, t2, i2) : 0;
        }
      }
      function kr(e2, t2) {
        if ("error" === (e2 = Lr(e2, t2)).result)
          return e2;
        const i2 = e2.value.expression, r2 = vi(i2);
        if (!r2 && !vr(t2))
          return xr([new yt("", "data expressions not supported")]);
        const n2 = wi(i2, ["zoom", "pitch", "distance-from-center"]);
        if (!n2 && !br(t2))
          return xr([new yt("", "zoom expressions not supported")]);
        const o2 = Br(i2);
        return o2 || n2 ? o2 instanceof yt ? xr([o2]) : o2 instanceof Hi && !wr(t2) ? xr([new yt("", '"interpolate" expressions cannot be used with this property')]) : yr(o2 ? new ZoomDependentExpression(r2 ? "camera" : "composite", e2.value, o2.labels, o2 instanceof Hi ? o2.interpolation : void 0) : new ZoomConstantExpression(r2 ? "constant" : "source", e2.value)) : xr([new yt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class StylePropertyFunction {
        constructor(e2, t2) {
          this._parameters = e2, this._specification = t2, mt(this, Ar(this._parameters, this._specification));
        }
        static deserialize(e2) {
          return new StylePropertyFunction(e2._parameters, e2._specification);
        }
        static serialize(e2) {
          return { _parameters: e2._parameters, _specification: e2._specification };
        }
      }
      function Br(e2) {
        let t2 = null;
        if (e2 instanceof Ki)
          t2 = Br(e2.result);
        else if (e2 instanceof Xi) {
          for (const i2 of e2.args)
            if (t2 = Br(i2), t2)
              break;
        } else
          (e2 instanceof Ci || e2 instanceof Hi) && e2.input instanceof ii && "zoom" === e2.input.name && (t2 = e2);
        return t2 instanceof yt || e2.eachChild((e3) => {
          const i2 = Br(e3);
          i2 instanceof yt ? t2 = i2 : !t2 && i2 ? t2 = new yt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t2 && i2 && t2 !== i2 && (t2 = new yt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), t2;
      }
      class ValidationError {
        constructor(e2, t2, i2, r2) {
          this.message = (e2 ? `${e2}: ` : "") + i2, r2 && (this.identifier = r2), null != t2 && t2.__line__ && (this.line = t2.__line__);
        }
      }
      function Rr(e2) {
        const t2 = e2.key, i2 = e2.value, r2 = e2.valueSpec || {}, n2 = e2.objectElementValidators || {}, o2 = e2.style, s2 = e2.styleSpec;
        let a2 = [];
        const l2 = Tr(i2);
        if ("object" !== l2)
          return [new ValidationError(t2, i2, `object expected, ${l2} found`)];
        for (const e3 in i2) {
          const l3 = e3.split(".")[0], c2 = r2[l3] || r2["*"];
          let u2;
          n2[l3] ? u2 = n2[l3] : r2[l3] ? u2 = gn : n2["*"] ? u2 = n2["*"] : r2["*"] && (u2 = gn), u2 ? a2 = a2.concat(u2({ key: (t2 ? `${t2}.` : t2) + e3, value: i2[e3], valueSpec: c2, style: o2, styleSpec: s2, object: i2, objectKey: e3 }, i2)) : a2.push(new ValidationError(t2, i2[e3], `unknown property "${e3}"`));
        }
        for (const e3 in r2)
          n2[e3] || r2[e3].required && void 0 === r2[e3].default && void 0 === i2[e3] && a2.push(new ValidationError(t2, i2, `missing required property "${e3}"`));
        return a2;
      }
      function Fr(e2) {
        const t2 = e2.value, i2 = e2.valueSpec, r2 = e2.style, n2 = e2.styleSpec, o2 = e2.key, s2 = e2.arrayElementValidator || gn;
        if ("array" !== Tr(t2))
          return [new ValidationError(o2, t2, `array expected, ${Tr(t2)} found`)];
        if (i2.length && t2.length !== i2.length)
          return [new ValidationError(o2, t2, `array length ${i2.length} expected, length ${t2.length} found`)];
        if (i2["min-length"] && t2.length < i2["min-length"])
          return [new ValidationError(o2, t2, `array length at least ${i2["min-length"]} expected, length ${t2.length} found`)];
        let a2 = { type: i2.value, values: i2.values, minimum: i2.minimum, maximum: i2.maximum, function: void 0 };
        n2.$version < 7 && (a2.function = i2.function), "object" === Tr(i2.value) && (a2 = i2.value);
        let l2 = [];
        for (let e3 = 0; e3 < t2.length; e3++)
          l2 = l2.concat(s2({ array: t2, arrayIndex: e3, value: t2[e3], valueSpec: a2, style: r2, styleSpec: n2, key: `${o2}[${e3}]` }));
        return l2;
      }
      function Or(e2) {
        const t2 = e2.key, i2 = e2.value, r2 = e2.valueSpec;
        let n2 = Tr(i2);
        if ("number" === n2 && i2 != i2 && (n2 = "NaN"), "number" !== n2)
          return [new ValidationError(t2, i2, `number expected, ${n2} found`)];
        if ("minimum" in r2) {
          let n3 = r2.minimum;
          if ("array" === Tr(r2.minimum) && (n3 = r2.minimum[e2.arrayIndex]), i2 < n3)
            return [new ValidationError(t2, i2, `${i2} is less than the minimum value ${n3}`)];
        }
        if ("maximum" in r2) {
          let n3 = r2.maximum;
          if ("array" === Tr(r2.maximum) && (n3 = r2.maximum[e2.arrayIndex]), i2 > n3)
            return [new ValidationError(t2, i2, `${i2} is greater than the maximum value ${n3}`)];
        }
        return [];
      }
      function Ur(e2) {
        const t2 = e2.valueSpec, i2 = _t(e2.value.type);
        let r2, n2, o2, s2 = {};
        const a2 = "categorical" !== i2 && void 0 === e2.value.property, l2 = !a2, c2 = "array" === Tr(e2.value.stops) && "array" === Tr(e2.value.stops[0]) && "object" === Tr(e2.value.stops[0][0]), u2 = Rr({ key: e2.key, value: e2.value, valueSpec: e2.styleSpec.function, style: e2.style, styleSpec: e2.styleSpec, objectElementValidators: { stops: function(e3) {
          if ("identity" === i2)
            return [new ValidationError(e3.key, e3.value, 'identity function may not have a "stops" property')];
          let t3 = [];
          const r3 = e3.value;
          return t3 = t3.concat(Fr({ key: e3.key, value: r3, valueSpec: e3.valueSpec, style: e3.style, styleSpec: e3.styleSpec, arrayElementValidator: h2 })), "array" === Tr(r3) && 0 === r3.length && t3.push(new ValidationError(e3.key, r3, "array must have at least one stop")), t3;
        }, default: function(e3) {
          return gn({ key: e3.key, value: e3.value, valueSpec: t2, style: e3.style, styleSpec: e3.styleSpec });
        } } });
        return "identity" === i2 && a2 && u2.push(new ValidationError(e2.key, e2.value, 'missing required property "property"')), "identity" === i2 || e2.value.stops || u2.push(new ValidationError(e2.key, e2.value, 'missing required property "stops"')), "exponential" === i2 && e2.valueSpec.expression && !wr(e2.valueSpec) && u2.push(new ValidationError(e2.key, e2.value, "exponential functions not supported")), e2.styleSpec.$version >= 8 && (l2 && !vr(e2.valueSpec) ? u2.push(new ValidationError(e2.key, e2.value, "property functions not supported")) : a2 && !br(e2.valueSpec) && u2.push(new ValidationError(e2.key, e2.value, "zoom functions not supported"))), "categorical" !== i2 && !c2 || void 0 !== e2.value.property || u2.push(new ValidationError(e2.key, e2.value, '"property" property is required')), u2;
        function h2(e3) {
          let i3 = [];
          const r3 = e3.value, a3 = e3.key;
          if ("array" !== Tr(r3))
            return [new ValidationError(a3, r3, `array expected, ${Tr(r3)} found`)];
          if (2 !== r3.length)
            return [new ValidationError(a3, r3, `array length 2 expected, length ${r3.length} found`)];
          if (c2) {
            if ("object" !== Tr(r3[0]))
              return [new ValidationError(a3, r3, `object expected, ${Tr(r3[0])} found`)];
            if (void 0 === r3[0].zoom)
              return [new ValidationError(a3, r3, "object stop key must have zoom")];
            if (void 0 === r3[0].value)
              return [new ValidationError(a3, r3, "object stop key must have value")];
            const t3 = _t(r3[0].zoom);
            if ("number" != typeof t3)
              return [new ValidationError(a3, r3[0].zoom, "stop zoom values must be numbers")];
            if (o2 && o2 > t3)
              return [new ValidationError(a3, r3[0].zoom, "stop zoom values must appear in ascending order")];
            t3 !== o2 && (o2 = t3, n2 = void 0, s2 = {}), i3 = i3.concat(Rr({ key: `${a3}[0]`, value: r3[0], valueSpec: { zoom: {} }, style: e3.style, styleSpec: e3.styleSpec, objectElementValidators: { zoom: Or, value: p2 } }));
          } else
            i3 = i3.concat(p2({ key: `${a3}[0]`, value: r3[0], valueSpec: {}, style: e3.style, styleSpec: e3.styleSpec }, r3));
          return zr(gt(r3[1])) ? i3.concat([new ValidationError(`${a3}[1]`, r3[1], "expressions are not allowed in function stops.")]) : i3.concat(gn({ key: `${a3}[1]`, value: r3[1], valueSpec: t2, style: e3.style, styleSpec: e3.styleSpec }));
        }
        function p2(e3, o3) {
          const a3 = Tr(e3.value), l3 = _t(e3.value), c3 = null !== e3.value ? e3.value : o3;
          if (r2) {
            if (a3 !== r2)
              return [new ValidationError(e3.key, c3, `${a3} stop domain type must match previous stop domain type ${r2}`)];
          } else
            r2 = a3;
          if ("number" !== a3 && "string" !== a3 && "boolean" !== a3 && "number" != typeof l3 && "string" != typeof l3 && "boolean" != typeof l3)
            return [new ValidationError(e3.key, c3, "stop domain value must be a number, string, or boolean")];
          if ("number" !== a3 && "categorical" !== i2) {
            let r3 = `number expected, ${a3} found`;
            return vr(t2) && void 0 === i2 && (r3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ValidationError(e3.key, c3, r3)];
          }
          return "categorical" !== i2 || "number" !== a3 || "number" == typeof l3 && isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== i2 && "number" === a3 && "number" == typeof l3 && "number" == typeof n2 && void 0 !== n2 && l3 < n2 ? [new ValidationError(e3.key, c3, "stop domain values must appear in ascending order")] : (n2 = l3, "categorical" === i2 && l3 in s2 ? [new ValidationError(e3.key, c3, "stop domain values must be unique")] : (s2[l3] = true, [])) : [new ValidationError(e3.key, c3, `integer expected, found ${String(l3)}`)];
        }
      }
      function Vr(e2) {
        const t2 = ("property" === e2.expressionContext ? kr : Lr)(gt(e2.value), e2.valueSpec);
        if ("error" === t2.result)
          return t2.value.map((t3) => new ValidationError(`${e2.key}${t3.key}`, e2.value, t3.message));
        const i2 = t2.value.expression || t2.value._styleExpression.expression;
        if ("property" === e2.expressionContext && "text-font" === e2.propertyKey && !i2.outputDefined())
          return [new ValidationError(e2.key, e2.value, `Invalid data expression for "${e2.propertyKey}". Output values must be contained as literals within the expression.`)];
        if ("property" === e2.expressionContext && "layout" === e2.propertyType && !bi(i2))
          return [new ValidationError(e2.key, e2.value, '"feature-state" data expressions are not supported with layout properties.')];
        if ("filter" === e2.expressionContext)
          return jr(i2, e2);
        if (e2.expressionContext && 0 === e2.expressionContext.indexOf("cluster")) {
          if (!wi(i2, ["zoom", "feature-state"]))
            return [new ValidationError(e2.key, e2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if ("cluster-initial" === e2.expressionContext && !vi(i2))
            return [new ValidationError(e2.key, e2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function jr(e2, t2) {
        const i2 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
        if (t2.valueSpec && t2.valueSpec.expression)
          for (const e3 of t2.valueSpec.expression.parameters)
            i2.delete(e3);
        if (0 === i2.size)
          return [];
        const r2 = [];
        return e2 instanceof ii && i2.has(e2.name) ? [new ValidationError(t2.key, t2.value, `["${e2.name}"] expression is not supported in a filter for a ${t2.object.type} layer with id: ${t2.object.id}`)] : (e2.eachChild((e3) => {
          r2.push(...jr(e3, t2));
        }), r2);
      }
      function Nr(e2) {
        const t2 = e2.key, i2 = e2.value, r2 = e2.valueSpec, n2 = [];
        return Array.isArray(r2.values) ? -1 === r2.values.indexOf(_t(i2)) && n2.push(new ValidationError(t2, i2, `expected one of [${r2.values.join(", ")}], ${JSON.stringify(i2)} found`)) : -1 === Object.keys(r2.values).indexOf(_t(i2)) && n2.push(new ValidationError(t2, i2, `expected one of [${Object.keys(r2.values).join(", ")}], ${JSON.stringify(i2)} found`)), n2;
      }
      function Gr(e2) {
        if (true === e2 || false === e2)
          return true;
        if (!Array.isArray(e2) || 0 === e2.length)
          return false;
        switch (e2[0]) {
          case "has":
            return e2.length >= 2 && "$id" !== e2[1] && "$type" !== e2[1];
          case "in":
            return e2.length >= 3 && ("string" != typeof e2[1] || Array.isArray(e2[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return 3 !== e2.length || Array.isArray(e2[1]) || Array.isArray(e2[2]);
          case "any":
          case "all":
            for (const t2 of e2.slice(1))
              if (!Gr(t2) && "boolean" != typeof t2)
                return false;
            return true;
          default:
            return true;
        }
      }
      function qr(e2, t2 = "fill") {
        if (null == e2)
          return { filter: () => true, needGeometry: false, needFeature: false };
        Gr(e2) || (e2 = Yr(e2));
        const i2 = e2;
        let r2 = true;
        try {
          r2 = function(e3) {
            if (!Wr(e3))
              return e3;
            let t3 = gt(e3);
            return $r(t3), t3 = Zr(t3), t3;
          }(i2);
        } catch (e3) {
          console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(i2, null, 2)}
        `);
        }
        const n2 = ft[`filter_${t2}`], o2 = Lr(r2, n2);
        let s2 = null;
        if ("error" === o2.result)
          throw new Error(o2.value.map((e3) => `${e3.key}: ${e3.message}`).join(", "));
        s2 = (e3, t3, i3) => o2.value.evaluate(e3, t3, {}, i3);
        let a2 = null, l2 = null;
        if (r2 !== i2) {
          const e3 = Lr(i2, n2);
          if ("error" === e3.result)
            throw new Error(e3.value.map((e4) => `${e4.key}: ${e4.message}`).join(", "));
          a2 = (t3, i3, r3, n3, o3) => e3.value.evaluate(t3, i3, {}, r3, void 0, void 0, n3, o3), l2 = !vi(e3.value.expression);
        }
        return { filter: s2, dynamicFilter: a2 || void 0, needGeometry: Kr(r2), needFeature: !!l2 };
      }
      function Zr(e2) {
        if (!Array.isArray(e2))
          return e2;
        const t2 = function(e3) {
          if (Hr.has(e3[0])) {
            for (let t3 = 1; t3 < e3.length; t3++)
              if (Wr(e3[t3]))
                return true;
          }
          return e3;
        }(e2);
        return true === t2 ? t2 : t2.map((e3) => Zr(e3));
      }
      function $r(e2) {
        let t2 = false;
        const i2 = [];
        if ("case" === e2[0]) {
          for (let r2 = 1; r2 < e2.length - 1; r2 += 2)
            t2 = t2 || Wr(e2[r2]), i2.push(e2[r2 + 1]);
          i2.push(e2[e2.length - 1]);
        } else if ("match" === e2[0]) {
          t2 = t2 || Wr(e2[1]);
          for (let t3 = 2; t3 < e2.length - 1; t3 += 2)
            i2.push(e2[t3 + 1]);
          i2.push(e2[e2.length - 1]);
        } else if ("step" === e2[0]) {
          t2 = t2 || Wr(e2[1]);
          for (let t3 = 1; t3 < e2.length - 1; t3 += 2)
            i2.push(e2[t3 + 1]);
        }
        t2 && (e2.length = 0, e2.push("any", ...i2));
        for (let t3 = 1; t3 < e2.length; t3++)
          $r(e2[t3]);
      }
      function Wr(e2) {
        if (!Array.isArray(e2))
          return false;
        if ("pitch" === (t2 = e2[0]) || "distance-from-center" === t2)
          return true;
        var t2;
        for (let t3 = 1; t3 < e2.length; t3++)
          if (Wr(e2[t3]))
            return true;
        return false;
      }
      const Hr = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
      function Xr(e2, t2) {
        return e2 < t2 ? -1 : e2 > t2 ? 1 : 0;
      }
      function Kr(e2) {
        if (!Array.isArray(e2))
          return false;
        if ("within" === e2[0])
          return true;
        for (let t2 = 1; t2 < e2.length; t2++)
          if (Kr(e2[t2]))
            return true;
        return false;
      }
      function Yr(e2) {
        if (!e2)
          return true;
        const t2 = e2[0];
        return e2.length <= 1 ? "any" !== t2 : "==" === t2 ? Jr(e2[1], e2[2], "==") : "!=" === t2 ? tn(Jr(e2[1], e2[2], "==")) : "<" === t2 || ">" === t2 || "<=" === t2 || ">=" === t2 ? Jr(e2[1], e2[2], t2) : "any" === t2 ? (i2 = e2.slice(1), ["any"].concat(i2.map(Yr))) : "all" === t2 ? ["all"].concat(e2.slice(1).map(Yr)) : "none" === t2 ? ["all"].concat(e2.slice(1).map(Yr).map(tn)) : "in" === t2 ? Qr(e2[1], e2.slice(2)) : "!in" === t2 ? tn(Qr(e2[1], e2.slice(2))) : "has" === t2 ? en(e2[1]) : "!has" === t2 ? tn(en(e2[1])) : "within" !== t2 || e2;
        var i2;
      }
      function Jr(e2, t2, i2) {
        switch (e2) {
          case "$type":
            return [`filter-type-${i2}`, t2];
          case "$id":
            return [`filter-id-${i2}`, t2];
          default:
            return [`filter-${i2}`, e2, t2];
        }
      }
      function Qr(e2, t2) {
        if (0 === t2.length)
          return false;
        switch (e2) {
          case "$type":
            return ["filter-type-in", ["literal", t2]];
          case "$id":
            return ["filter-id-in", ["literal", t2]];
          default:
            return t2.length > 200 && !t2.some((e3) => typeof e3 != typeof t2[0]) ? ["filter-in-large", e2, ["literal", t2.sort(Xr)]] : ["filter-in-small", e2, ["literal", t2]];
        }
      }
      function en(e2) {
        switch (e2) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", e2];
        }
      }
      function tn(e2) {
        return ["!", e2];
      }
      function rn(e2) {
        return Gr(gt(e2.value)) ? Vr(mt({}, e2, { expressionContext: "filter", valueSpec: e2.styleSpec[`filter_${e2.layerType || "fill"}`] })) : nn(e2);
      }
      function nn(e2) {
        const t2 = e2.value, i2 = e2.key;
        if ("array" !== Tr(t2))
          return [new ValidationError(i2, t2, `array expected, ${Tr(t2)} found`)];
        const r2 = e2.styleSpec;
        let n2, o2 = [];
        if (t2.length < 1)
          return [new ValidationError(i2, t2, "filter array must have at least 1 element")];
        switch (o2 = o2.concat(Nr({ key: `${i2}[0]`, value: t2[0], valueSpec: r2.filter_operator, style: e2.style, styleSpec: e2.styleSpec })), _t(t2[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            t2.length >= 2 && "$type" === _t(t2[1]) && o2.push(new ValidationError(i2, t2, `"$type" cannot be use with operator "${t2[0]}"`));
          case "==":
          case "!=":
            3 !== t2.length && o2.push(new ValidationError(i2, t2, `filter array for operator "${t2[0]}" must have 3 elements`));
          case "in":
          case "!in":
            t2.length >= 2 && (n2 = Tr(t2[1]), "string" !== n2 && o2.push(new ValidationError(`${i2}[1]`, t2[1], `string expected, ${n2} found`)));
            for (let s2 = 2; s2 < t2.length; s2++)
              n2 = Tr(t2[s2]), "$type" === _t(t2[1]) ? o2 = o2.concat(Nr({ key: `${i2}[${s2}]`, value: t2[s2], valueSpec: r2.geometry_type, style: e2.style, styleSpec: e2.styleSpec })) : "string" !== n2 && "number" !== n2 && "boolean" !== n2 && o2.push(new ValidationError(`${i2}[${s2}]`, t2[s2], `string, number, or boolean expected, ${n2} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let r3 = 1; r3 < t2.length; r3++)
              o2 = o2.concat(nn({ key: `${i2}[${r3}]`, value: t2[r3], style: e2.style, styleSpec: e2.styleSpec }));
            break;
          case "has":
          case "!has":
            n2 = Tr(t2[1]), 2 !== t2.length ? o2.push(new ValidationError(i2, t2, `filter array for "${t2[0]}" operator must have 2 elements`)) : "string" !== n2 && o2.push(new ValidationError(`${i2}[1]`, t2[1], `string expected, ${n2} found`));
            break;
          case "within":
            n2 = Tr(t2[1]), 2 !== t2.length ? o2.push(new ValidationError(i2, t2, `filter array for "${t2[0]}" operator must have 2 elements`)) : "object" !== n2 && o2.push(new ValidationError(`${i2}[1]`, t2[1], `object expected, ${n2} found`));
        }
        return o2;
      }
      function on(e2, t2) {
        const i2 = e2.key, r2 = e2.style, n2 = e2.styleSpec, o2 = e2.value, s2 = e2.objectKey, a2 = n2[`${t2}_${e2.layerType}`];
        if (!a2)
          return [];
        const l2 = s2.match(/^(.*)-transition$/);
        if ("paint" === t2 && l2 && a2[l2[1]] && a2[l2[1]].transition)
          return gn({ key: i2, value: o2, valueSpec: n2.transition, style: r2, styleSpec: n2 });
        const c2 = e2.valueSpec || a2[s2];
        if (!c2)
          return [new ValidationError(i2, o2, `unknown property "${s2}"`)];
        let u2;
        if ("string" === Tr(o2) && vr(c2) && !c2.tokens && (u2 = /^{([^}]+)}$/.exec(o2)))
          return [new ValidationError(i2, o2, `"${s2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(u2[1])} }\`.`)];
        const h2 = [];
        return "symbol" === e2.layerType && ("text-field" === s2 && r2 && !r2.glyphs && h2.push(new ValidationError(i2, o2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === s2 && Er(gt(o2)) && "identity" === _t(o2.type) && h2.push(new ValidationError(i2, o2, '"text-font" does not support identity functions'))), h2.concat(gn({ key: e2.key, value: o2, valueSpec: c2, style: r2, styleSpec: n2, expressionContext: "property", propertyType: t2, propertyKey: s2 }));
      }
      function sn(e2) {
        return on(e2, "paint");
      }
      function an(e2) {
        return on(e2, "layout");
      }
      function ln(e2) {
        let t2 = [];
        const i2 = e2.value, r2 = e2.key, n2 = e2.style, o2 = e2.styleSpec;
        i2.type || i2.ref || t2.push(new ValidationError(r2, i2, 'either "type" or "ref" is required'));
        let s2 = _t(i2.type);
        const a2 = _t(i2.ref);
        if (i2.id) {
          const o3 = _t(i2.id);
          for (let s3 = 0; s3 < e2.arrayIndex; s3++) {
            const e3 = n2.layers[s3];
            _t(e3.id) === o3 && t2.push(new ValidationError(r2, i2.id, `duplicate layer id "${i2.id}", previously used at line ${e3.id.__line__}`));
          }
        }
        if ("ref" in i2) {
          let e3;
          ["type", "source", "source-layer", "filter", "layout"].forEach((e4) => {
            e4 in i2 && t2.push(new ValidationError(r2, i2[e4], `"${e4}" is prohibited for ref layers`));
          }), n2.layers.forEach((t3) => {
            _t(t3.id) === a2 && (e3 = t3);
          }), e3 ? e3.ref ? t2.push(new ValidationError(r2, i2.ref, "ref cannot reference another ref layer")) : s2 = _t(e3.type) : "string" == typeof a2 && t2.push(new ValidationError(r2, i2.ref, `ref layer "${a2}" not found`));
        } else if ("background" !== s2 && "sky" !== s2)
          if (i2.source) {
            const e3 = n2.sources && n2.sources[i2.source], o3 = e3 && _t(e3.type);
            e3 ? "vector" === o3 && "raster" === s2 ? t2.push(new ValidationError(r2, i2.source, `layer "${i2.id}" requires a raster source`)) : "raster" === o3 && "raster" !== s2 ? t2.push(new ValidationError(r2, i2.source, `layer "${i2.id}" requires a vector source`)) : "vector" !== o3 || i2["source-layer"] ? "raster-dem" === o3 && "hillshade" !== s2 ? t2.push(new ValidationError(r2, i2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s2 || !i2.paint || !i2.paint["line-gradient"] && !i2.paint["line-trim-offset"] || "geojson" === o3 && e3.lineMetrics || t2.push(new ValidationError(r2, i2, `layer "${i2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t2.push(new ValidationError(r2, i2, `layer "${i2.id}" must specify a "source-layer"`)) : t2.push(new ValidationError(r2, i2.source, `source "${i2.source}" not found`));
          } else
            t2.push(new ValidationError(r2, i2, 'missing required property "source"'));
        return t2 = t2.concat(Rr({ key: r2, value: i2, valueSpec: o2.layer, style: e2.style, styleSpec: e2.styleSpec, objectElementValidators: { "*": () => [], type: () => gn({ key: `${r2}.type`, value: i2.type, valueSpec: o2.layer.type, style: e2.style, styleSpec: e2.styleSpec, object: i2, objectKey: "type" }), filter: (e3) => rn(mt({ layerType: s2 }, e3)), layout: (e3) => Rr({ layer: i2, key: e3.key, value: e3.value, valueSpec: {}, style: e3.style, styleSpec: e3.styleSpec, objectElementValidators: { "*": (e4) => an(mt({ layerType: s2 }, e4)) } }), paint: (e3) => Rr({ layer: i2, key: e3.key, value: e3.value, valueSpec: {}, style: e3.style, styleSpec: e3.styleSpec, objectElementValidators: { "*": (e4) => sn(mt({ layerType: s2 }, e4)) } }) } })), t2;
      }
      function cn(e2) {
        const t2 = e2.value, i2 = e2.key, r2 = Tr(t2);
        return "string" !== r2 ? [new ValidationError(i2, t2, `string expected, ${r2} found`)] : [];
      }
      const un = { promoteId: function({ key: e2, value: t2 }) {
        if ("string" === Tr(t2))
          return cn({ key: e2, value: t2 });
        {
          const i2 = [];
          for (const r2 in t2)
            i2.push(...cn({ key: `${e2}.${r2}`, value: t2[r2] }));
          return i2;
        }
      } };
      function hn(e2) {
        const t2 = e2.value, i2 = e2.key, r2 = e2.styleSpec, n2 = e2.style;
        if (!t2.type)
          return [new ValidationError(i2, t2, '"type" is required')];
        const o2 = _t(t2.type);
        let s2;
        switch (o2) {
          case "vector":
          case "raster":
          case "raster-dem":
            return s2 = Rr({ key: i2, value: t2, valueSpec: r2[`source_${o2.replace("-", "_")}`], style: e2.style, styleSpec: r2, objectElementValidators: un }), s2;
          case "geojson":
            if (s2 = Rr({ key: i2, value: t2, valueSpec: r2.source_geojson, style: n2, styleSpec: r2, objectElementValidators: un }), t2.cluster)
              for (const e3 in t2.clusterProperties) {
                const [r3, n3] = t2.clusterProperties[e3], o3 = "string" == typeof r3 ? [r3, ["accumulated"], ["get", e3]] : r3;
                s2.push(...Vr({ key: `${i2}.${e3}.map`, value: n3, expressionContext: "cluster-map" })), s2.push(...Vr({ key: `${i2}.${e3}.reduce`, value: o3, expressionContext: "cluster-reduce" }));
              }
            return s2;
          case "video":
            return Rr({ key: i2, value: t2, valueSpec: r2.source_video, style: n2, styleSpec: r2 });
          case "image":
            return Rr({ key: i2, value: t2, valueSpec: r2.source_image, style: n2, styleSpec: r2 });
          case "canvas":
            return [new ValidationError(i2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return Nr({ key: `${i2}.type`, value: t2.type, valueSpec: { values: pn(r2) }, style: n2, styleSpec: r2 });
        }
      }
      function pn(e2) {
        return e2.source.reduce((t2, i2) => {
          const r2 = e2[i2];
          return "enum" === r2.type.type && (t2 = t2.concat(Object.keys(r2.type.values))), t2;
        }, []);
      }
      function dn(e2) {
        const t2 = e2.value, i2 = e2.styleSpec, r2 = i2.light, n2 = e2.style;
        let o2 = [];
        const s2 = Tr(t2);
        if (void 0 === t2)
          return o2;
        if ("object" !== s2)
          return o2 = o2.concat([new ValidationError("light", t2, `object expected, ${s2} found`)]), o2;
        for (const e3 in t2) {
          const s3 = e3.match(/^(.*)-transition$/);
          o2 = o2.concat(s3 && r2[s3[1]] && r2[s3[1]].transition ? gn({ key: e3, value: t2[e3], valueSpec: i2.transition, style: n2, styleSpec: i2 }) : r2[e3] ? gn({ key: e3, value: t2[e3], valueSpec: r2[e3], style: n2, styleSpec: i2 }) : [new ValidationError(e3, t2[e3], `unknown property "${e3}"`)]);
        }
        return o2;
      }
      function fn(e2) {
        const t2 = e2.value, i2 = e2.key, r2 = e2.style, n2 = e2.styleSpec, o2 = n2.terrain;
        let s2 = [];
        const a2 = Tr(t2);
        if (void 0 === t2)
          return s2;
        if ("object" !== a2)
          return s2 = s2.concat([new ValidationError("terrain", t2, `object expected, ${a2} found`)]), s2;
        for (const e3 in t2) {
          const i3 = e3.match(/^(.*)-transition$/);
          s2 = s2.concat(i3 && o2[i3[1]] && o2[i3[1]].transition ? gn({ key: e3, value: t2[e3], valueSpec: n2.transition, style: r2, styleSpec: n2 }) : o2[e3] ? gn({ key: e3, value: t2[e3], valueSpec: o2[e3], style: r2, styleSpec: n2 }) : [new ValidationError(e3, t2[e3], `unknown property "${e3}"`)]);
        }
        if (t2.source) {
          const e3 = r2.sources && r2.sources[t2.source], n3 = e3 && _t(e3.type);
          e3 ? "raster-dem" !== n3 && s2.push(new ValidationError(i2, t2.source, `terrain cannot be used with a source of type ${String(n3)}, it only be used with a "raster-dem" source type`)) : s2.push(new ValidationError(i2, t2.source, `source "${t2.source}" not found`));
        } else
          s2.push(new ValidationError(i2, t2, 'terrain is missing required property "source"'));
        return s2;
      }
      function mn(e2) {
        const t2 = e2.value, i2 = e2.style, r2 = e2.styleSpec, n2 = r2.fog;
        let o2 = [];
        const s2 = Tr(t2);
        if (void 0 === t2)
          return o2;
        if ("object" !== s2)
          return o2 = o2.concat([new ValidationError("fog", t2, `object expected, ${s2} found`)]), o2;
        for (const e3 in t2) {
          const s3 = e3.match(/^(.*)-transition$/);
          o2 = o2.concat(s3 && n2[s3[1]] && n2[s3[1]].transition ? gn({ key: e3, value: t2[e3], valueSpec: r2.transition, style: i2, styleSpec: r2 }) : n2[e3] ? gn({ key: e3, value: t2[e3], valueSpec: n2[e3], style: i2, styleSpec: r2 }) : [new ValidationError(e3, t2[e3], `unknown property "${e3}"`)]);
        }
        return o2;
      }
      const _n = { "*": () => [], array: Fr, boolean: function(e2) {
        const t2 = e2.value, i2 = e2.key, r2 = Tr(t2);
        return "boolean" !== r2 ? [new ValidationError(i2, t2, `boolean expected, ${r2} found`)] : [];
      }, number: Or, color: function(e2) {
        const t2 = e2.key, i2 = e2.value, r2 = Tr(i2);
        return "string" !== r2 ? [new ValidationError(t2, i2, `color expected, ${r2} found`)] : null === Ft(i2) ? [new ValidationError(t2, i2, `color expected, "${i2}" found`)] : [];
      }, enum: Nr, filter: rn, function: Ur, layer: ln, object: Rr, source: hn, light: dn, terrain: fn, fog: mn, string: cn, formatted: function(e2) {
        return 0 === cn(e2).length ? [] : Vr(e2);
      }, resolvedImage: function(e2) {
        return 0 === cn(e2).length ? [] : Vr(e2);
      }, projection: function(e2) {
        const t2 = e2.value, i2 = e2.styleSpec, r2 = i2.projection, n2 = e2.style;
        let o2 = [];
        const s2 = Tr(t2);
        if ("object" === s2)
          for (const e3 in t2)
            o2 = o2.concat(gn({ key: e3, value: t2[e3], valueSpec: r2[e3], style: n2, styleSpec: i2 }));
        else
          "string" !== s2 && (o2 = o2.concat([new ValidationError("projection", t2, `object or string expected, ${s2} found`)]));
        return o2;
      } };
      function gn(e2) {
        const t2 = e2.value, i2 = e2.valueSpec, r2 = e2.styleSpec;
        return i2.expression && Er(_t(t2)) ? Ur(e2) : i2.expression && zr(gt(t2)) ? Vr(e2) : i2.type && _n[i2.type] ? _n[i2.type](e2) : Rr(mt({}, e2, { valueSpec: i2.type ? r2[i2.type] : i2 }));
      }
      function yn(e2) {
        const t2 = e2.value, i2 = e2.key, r2 = cn(e2);
        return r2.length || (-1 === t2.indexOf("{fontstack}") && r2.push(new ValidationError(i2, t2, '"glyphs" url must include a "{fontstack}" token')), -1 === t2.indexOf("{range}") && r2.push(new ValidationError(i2, t2, '"glyphs" url must include a "{range}" token'))), r2;
      }
      function xn(e2, t2 = ft) {
        return Mn(gn({ key: "", value: e2, valueSpec: t2.$root, styleSpec: t2, style: e2, objectElementValidators: { glyphs: yn, "*": () => [] } }));
      }
      const vn = (e2) => Mn(hn(e2)), bn = (e2) => Mn(dn(e2)), wn = (e2) => Mn(fn(e2)), Tn = (e2) => Mn(mn(e2)), En = (e2) => Mn(ln(e2)), Sn = (e2) => Mn(rn(e2)), An = (e2) => Mn(sn(e2)), Cn = (e2) => Mn(an(e2));
      function Mn(e2) {
        return e2.slice().sort((e3, t2) => e3.line && t2.line ? e3.line - t2.line : 0);
      }
      function Dn(e2, t2) {
        let i2 = false;
        if (t2 && t2.length)
          for (const r2 of t2)
            e2.fire(new ErrorEvent(new Error(r2.message))), i2 = true;
        return i2;
      }
      var Pn = zn;
      function zn(e2, t2, i2) {
        var r2 = this.cells = [];
        if (e2 instanceof ArrayBuffer) {
          this.arrayBuffer = e2;
          var n2 = new Int32Array(this.arrayBuffer);
          e2 = n2[0], this.d = (t2 = n2[1]) + 2 * (i2 = n2[2]);
          for (var o2 = 0; o2 < this.d * this.d; o2++) {
            var s2 = n2[3 + o2], a2 = n2[3 + o2 + 1];
            r2.push(s2 === a2 ? null : n2.subarray(s2, a2));
          }
          var l2 = n2[3 + r2.length + 1];
          this.keys = n2.subarray(n2[3 + r2.length], l2), this.bboxes = n2.subarray(l2), this.insert = this._insertReadonly;
        } else {
          this.d = t2 + 2 * i2;
          for (var c2 = 0; c2 < this.d * this.d; c2++)
            r2.push([]);
          this.keys = [], this.bboxes = [];
        }
        this.n = t2, this.extent = e2, this.padding = i2, this.scale = t2 / e2, this.uid = 0;
        var u2 = i2 / t2 * e2;
        this.min = -u2, this.max = e2 + u2;
      }
      zn.prototype.insert = function(e2, t2, i2, r2, n2) {
        this._forEachCell(t2, i2, r2, n2, this._insertCell, this.uid++), this.keys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(r2), this.bboxes.push(n2);
      }, zn.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      }, zn.prototype._insertCell = function(e2, t2, i2, r2, n2, o2) {
        this.cells[n2].push(o2);
      }, zn.prototype.query = function(e2, t2, i2, r2, n2) {
        var o2 = this.min, s2 = this.max;
        if (e2 <= o2 && t2 <= o2 && s2 <= i2 && s2 <= r2 && !n2)
          return Array.prototype.slice.call(this.keys);
        var a2 = [];
        return this._forEachCell(e2, t2, i2, r2, this._queryCell, a2, {}, n2), a2;
      }, zn.prototype._queryCell = function(e2, t2, i2, r2, n2, o2, s2, a2) {
        var l2 = this.cells[n2];
        if (null !== l2)
          for (var c2 = this.keys, u2 = this.bboxes, h2 = 0; h2 < l2.length; h2++) {
            var p2 = l2[h2];
            if (void 0 === s2[p2]) {
              var d2 = 4 * p2;
              (a2 ? a2(u2[d2 + 0], u2[d2 + 1], u2[d2 + 2], u2[d2 + 3]) : e2 <= u2[d2 + 2] && t2 <= u2[d2 + 3] && i2 >= u2[d2 + 0] && r2 >= u2[d2 + 1]) ? (s2[p2] = true, o2.push(c2[p2])) : s2[p2] = false;
            }
          }
      }, zn.prototype._forEachCell = function(e2, t2, i2, r2, n2, o2, s2, a2) {
        for (var l2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(i2), h2 = this._convertToCellCoord(r2), p2 = l2; p2 <= u2; p2++)
          for (var d2 = c2; d2 <= h2; d2++) {
            var f2 = this.d * d2 + p2;
            if ((!a2 || a2(this._convertFromCellCoord(p2), this._convertFromCellCoord(d2), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(d2 + 1))) && n2.call(this, e2, t2, i2, r2, f2, o2, s2, a2))
              return;
          }
      }, zn.prototype._convertFromCellCoord = function(e2) {
        return (e2 - this.padding) / this.scale;
      }, zn.prototype._convertToCellCoord = function(e2) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(e2 * this.scale) + this.padding));
      }, zn.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer)
          return this.arrayBuffer;
        for (var e2 = this.cells, t2 = 3 + this.cells.length + 1 + 1, i2 = 0, r2 = 0; r2 < this.cells.length; r2++)
          i2 += this.cells[r2].length;
        var n2 = new Int32Array(t2 + i2 + this.keys.length + this.bboxes.length);
        n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
        for (var o2 = t2, s2 = 0; s2 < e2.length; s2++) {
          var a2 = e2[s2];
          n2[3 + s2] = o2, n2.set(a2, o2), o2 += a2.length;
        }
        return n2[3 + e2.length] = o2, n2.set(this.keys, o2), n2[3 + e2.length + 1] = o2 += this.keys.length, n2.set(this.bboxes, o2), o2 += this.bboxes.length, n2.buffer;
      };
      const Ln = {};
      function kn(e2, t2, i2 = {}) {
        Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), Ln[t2] = { klass: e2, omit: i2.omit || [] };
      }
      kn(Object, "Object"), Pn.serialize = function(e2, t2) {
        const i2 = e2.toArrayBuffer();
        return t2 && t2.push(i2), { buffer: i2 };
      }, Pn.deserialize = function(e2) {
        return new Pn(e2.buffer);
      }, Object.defineProperty(Pn, "name", { value: "Grid" }), kn(Pn, "Grid"), kn(Gt, "Color"), kn(Error, "Error"), kn(AJAXError, "AJAXError"), kn(ResolvedImage, "ResolvedImage"), kn(StylePropertyFunction, "StylePropertyFunction"), kn(StyleExpression, "StyleExpression", { omit: ["_evaluator"] }), kn(ZoomDependentExpression, "ZoomDependentExpression"), kn(ZoomConstantExpression, "ZoomConstantExpression"), kn(ii, "CompoundExpression", { omit: ["_evaluate"] });
      for (const e2 in gr)
        Ln[gr[e2]._classRegistryKey] || kn(gr[e2], `Expression${e2}`);
      function Bn(e2) {
        return e2 && "undefined" != typeof ArrayBuffer && (e2 instanceof ArrayBuffer || e2.constructor && "ArrayBuffer" === e2.constructor.name);
      }
      function Rn(t2) {
        return e.ImageBitmap && t2 instanceof e.ImageBitmap;
      }
      function Fn(t2, i2) {
        if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp)
          return t2;
        if (Bn(t2) || Rn(t2))
          return i2 && i2.push(t2), t2;
        if (ArrayBuffer.isView(t2)) {
          const e2 = t2;
          return i2 && i2.push(e2.buffer), e2;
        }
        if (t2 instanceof e.ImageData)
          return i2 && i2.push(t2.data.buffer), t2;
        if (Array.isArray(t2)) {
          const e2 = [];
          for (const r2 of t2)
            e2.push(Fn(r2, i2));
          return e2;
        }
        if ("object" == typeof t2) {
          const e2 = t2.constructor, r2 = e2._classRegistryKey;
          if (!r2)
            throw new Error(`can't serialize object of unregistered class ${r2}`);
          const n2 = e2.serialize ? e2.serialize(t2, i2) : {};
          if (!e2.serialize) {
            for (const e3 in t2)
              t2.hasOwnProperty(e3) && (Ln[r2].omit.indexOf(e3) >= 0 || (n2[e3] = Fn(t2[e3], i2)));
            t2 instanceof Error && (n2.message = t2.message);
          }
          if (n2.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return "Object" !== r2 && (n2.$name = r2), n2;
        }
        throw new Error("can't serialize object of type " + typeof t2);
      }
      function On(t2) {
        if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || Bn(t2) || Rn(t2) || ArrayBuffer.isView(t2) || t2 instanceof e.ImageData)
          return t2;
        if (Array.isArray(t2))
          return t2.map(On);
        if ("object" == typeof t2) {
          const e2 = t2.$name || "Object", { klass: i2 } = Ln[e2];
          if (!i2)
            throw new Error(`can't deserialize unregistered class ${e2}`);
          if (i2.deserialize)
            return i2.deserialize(t2);
          const r2 = Object.create(i2.prototype);
          for (const e3 of Object.keys(t2))
            "$name" !== e3 && (r2[e3] = On(t2[e3]));
          return r2;
        }
        throw new Error("can't deserialize object of type " + typeof t2);
      }
      const Un = (e2) => e2 >= 12288 && e2 <= 12351, Vn = (e2) => e2 >= 12352 && e2 <= 12447, jn = (e2) => e2 >= 12448 && e2 <= 12543, Nn = (e2) => e2 >= 19968 && e2 <= 40959, Gn = (e2) => e2 >= 44032 && e2 <= 55215;
      function qn(e2) {
        for (const t2 of e2)
          if (Zn(t2.charCodeAt(0)))
            return true;
        return false;
      }
      function Zn(e2) {
        return !(746 !== e2 && 747 !== e2 && (e2 < 4352 || !(((e3) => e3 >= 12704 && e3 <= 12735)(e2) || ((e3) => e3 >= 12544 && e3 <= 12591)(e2) || ((e3) => e3 >= 65072 && e3 <= 65103)(e2) && !(e2 >= 65097 && e2 <= 65103) || ((e3) => e3 >= 63744 && e3 <= 64255)(e2) || ((e3) => e3 >= 13056 && e3 <= 13311)(e2) || ((e3) => e3 >= 11904 && e3 <= 12031)(e2) || ((e3) => e3 >= 12736 && e3 <= 12783)(e2) || !(!Un(e2) || e2 >= 12296 && e2 <= 12305 || e2 >= 12308 && e2 <= 12319 || 12336 === e2) || ((e3) => e3 >= 13312 && e3 <= 19903)(e2) || Nn(e2) || ((e3) => e3 >= 12800 && e3 <= 13055)(e2) || ((e3) => e3 >= 12592 && e3 <= 12687)(e2) || ((e3) => e3 >= 43360 && e3 <= 43391)(e2) || ((e3) => e3 >= 55216 && e3 <= 55295)(e2) || ((e3) => e3 >= 4352 && e3 <= 4607)(e2) || Gn(e2) || Vn(e2) || ((e3) => e3 >= 12272 && e3 <= 12287)(e2) || ((e3) => e3 >= 12688 && e3 <= 12703)(e2) || ((e3) => e3 >= 12032 && e3 <= 12255)(e2) || ((e3) => e3 >= 12784 && e3 <= 12799)(e2) || jn(e2) && 12540 !== e2 || !(!((e3) => e3 >= 65280 && e3 <= 65519)(e2) || 65288 === e2 || 65289 === e2 || 65293 === e2 || e2 >= 65306 && e2 <= 65310 || 65339 === e2 || 65341 === e2 || 65343 === e2 || e2 >= 65371 && e2 <= 65503 || 65507 === e2 || e2 >= 65512 && e2 <= 65519) || !(!((e3) => e3 >= 65104 && e3 <= 65135)(e2) || e2 >= 65112 && e2 <= 65118 || e2 >= 65123 && e2 <= 65126) || ((e3) => e3 >= 5120 && e3 <= 5759)(e2) || ((e3) => e3 >= 6320 && e3 <= 6399)(e2) || ((e3) => e3 >= 65040 && e3 <= 65055)(e2) || ((e3) => e3 >= 19904 && e3 <= 19967)(e2) || ((e3) => e3 >= 40960 && e3 <= 42127)(e2) || ((e3) => e3 >= 42128 && e3 <= 42191)(e2))));
      }
      function $n(e2) {
        return e2 >= 1424 && e2 <= 2303 || ((e3) => e3 >= 64336 && e3 <= 65023)(e2) || ((e3) => e3 >= 65136 && e3 <= 65279)(e2);
      }
      function Wn(e2, t2) {
        return !(!t2 && $n(e2) || e2 >= 2304 && e2 <= 3583 || e2 >= 3840 && e2 <= 4255 || ((e3) => e3 >= 6016 && e3 <= 6143)(e2));
      }
      function Hn(e2) {
        for (const t2 of e2)
          if ($n(t2.charCodeAt(0)))
            return true;
        return false;
      }
      const Xn = "deferred", Kn = "loading", Yn = "loaded";
      let Jn = null, Qn = "unavailable", eo = null;
      const to = function(e2) {
        e2 && "string" == typeof e2 && e2.indexOf("NetworkError") > -1 && (Qn = "error"), Jn && Jn(e2);
      };
      function io() {
        ro.fire(new Event("pluginStateChange", { pluginStatus: Qn, pluginURL: eo }));
      }
      const ro = new Evented(), no = function() {
        return Qn;
      }, oo = function() {
        if (Qn !== Xn || !eo)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        Qn = Kn, io(), eo && _e({ url: eo }, (e2) => {
          e2 ? to(e2) : (Qn = Yn, io());
        });
      }, so = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Qn === Yn || null != so.applyArabicShaping, isLoading: () => Qn === Kn, setState(e2) {
        Qn = e2.pluginStatus, eo = e2.pluginURL;
      }, isParsed: () => null != so.applyArabicShaping, getPluginURL: () => eo };
      class EvaluationParameters {
        constructor(e2, t2) {
          this.zoom = e2, t2 ? (this.now = t2.now, this.fadeDuration = t2.fadeDuration, this.transition = t2.transition, this.pitch = t2.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0);
        }
        isSupportedScript(e2) {
          return function(e3, t2) {
            for (const i2 of e3)
              if (!Wn(i2.charCodeAt(0), t2))
                return false;
            return true;
          }(e2, so.isLoaded());
        }
      }
      class PropertyValue {
        constructor(e2, t2) {
          this.property = e2, this.value = t2, this.expression = function(e3, t3) {
            if (Er(e3))
              return new StylePropertyFunction(e3, t3);
            if (zr(e3)) {
              const i2 = kr(e3, t3);
              if ("error" === i2.result)
                throw new Error(i2.value.map((e4) => `${e4.key}: ${e4.message}`).join(", "));
              return i2.value;
            }
            {
              let i2 = e3;
              return "string" == typeof e3 && "color" === t3.type && (i2 = Gt.parse(e3)), { kind: "constant", evaluate: () => i2 };
            }
          }(void 0 === t2 ? e2.specification.default : t2, e2.specification);
        }
        isDataDriven() {
          return "source" === this.expression.kind || "composite" === this.expression.kind;
        }
        possiblyEvaluate(e2, t2, i2) {
          return this.property.possiblyEvaluate(this, e2, t2, i2);
        }
      }
      class TransitionablePropertyValue {
        constructor(e2) {
          this.property = e2, this.value = new PropertyValue(e2, void 0);
        }
        transitioned(e2, t2) {
          return new TransitioningPropertyValue(this.property, this.value, t2, P({}, e2.transition, this.transition), e2.now);
        }
        untransitioned() {
          return new TransitioningPropertyValue(this.property, this.value, null, {}, 0);
        }
      }
      class Transitionable {
        constructor(e2) {
          this._properties = e2, this._values = Object.create(e2.defaultTransitionablePropertyValues);
        }
        getValue(e2) {
          return N(this._values[e2].value.value);
        }
        setValue(e2, t2) {
          this._values.hasOwnProperty(e2) || (this._values[e2] = new TransitionablePropertyValue(this._values[e2].property)), this._values[e2].value = new PropertyValue(this._values[e2].property, null === t2 ? void 0 : N(t2));
        }
        getTransition(e2) {
          return N(this._values[e2].transition);
        }
        setTransition(e2, t2) {
          this._values.hasOwnProperty(e2) || (this._values[e2] = new TransitionablePropertyValue(this._values[e2].property)), this._values[e2].transition = N(t2) || void 0;
        }
        serialize() {
          const e2 = {};
          for (const t2 of Object.keys(this._values)) {
            const i2 = this.getValue(t2);
            void 0 !== i2 && (e2[t2] = i2);
            const r2 = this.getTransition(t2);
            void 0 !== r2 && (e2[`${t2}-transition`] = r2);
          }
          return e2;
        }
        transitioned(e2, t2) {
          const i2 = new Transitioning(this._properties);
          for (const r2 of Object.keys(this._values))
            i2._values[r2] = this._values[r2].transitioned(e2, t2._values[r2]);
          return i2;
        }
        untransitioned() {
          const e2 = new Transitioning(this._properties);
          for (const t2 of Object.keys(this._values))
            e2._values[t2] = this._values[t2].untransitioned();
          return e2;
        }
      }
      class TransitioningPropertyValue {
        constructor(e2, t2, i2, r2, n2) {
          const o2 = r2.delay || 0, s2 = r2.duration || 0;
          n2 = n2 || 0, this.property = e2, this.value = t2, this.begin = n2 + o2, this.end = this.begin + s2, e2.specification.transition && (r2.delay || r2.duration) && (this.prior = i2);
        }
        possiblyEvaluate(e2, t2, i2) {
          const r2 = e2.now || 0, n2 = this.value.possiblyEvaluate(e2, t2, i2), o2 = this.prior;
          if (o2) {
            if (r2 > this.end)
              return this.prior = null, n2;
            if (this.value.isDataDriven())
              return this.prior = null, n2;
            if (r2 < this.begin)
              return o2.possiblyEvaluate(e2, t2, i2);
            {
              const s2 = (r2 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(o2.possiblyEvaluate(e2, t2, i2), n2, b(s2));
            }
          }
          return n2;
        }
      }
      class Transitioning {
        constructor(e2) {
          this._properties = e2, this._values = Object.create(e2.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(e2, t2, i2) {
          const r2 = new PossiblyEvaluated(this._properties);
          for (const n2 of Object.keys(this._values))
            r2._values[n2] = this._values[n2].possiblyEvaluate(e2, t2, i2);
          return r2;
        }
        hasTransition() {
          for (const e2 of Object.keys(this._values))
            if (this._values[e2].prior)
              return true;
          return false;
        }
      }
      class Layout {
        constructor(e2) {
          this._properties = e2, this._values = Object.create(e2.defaultPropertyValues);
        }
        getValue(e2) {
          return N(this._values[e2].value);
        }
        setValue(e2, t2) {
          this._values[e2] = new PropertyValue(this._values[e2].property, null === t2 ? void 0 : N(t2));
        }
        serialize() {
          const e2 = {};
          for (const t2 of Object.keys(this._values)) {
            const i2 = this.getValue(t2);
            void 0 !== i2 && (e2[t2] = i2);
          }
          return e2;
        }
        possiblyEvaluate(e2, t2, i2) {
          const r2 = new PossiblyEvaluated(this._properties);
          for (const n2 of Object.keys(this._values))
            r2._values[n2] = this._values[n2].possiblyEvaluate(e2, t2, i2);
          return r2;
        }
      }
      class PossiblyEvaluatedPropertyValue {
        constructor(e2, t2, i2) {
          this.property = e2, this.value = t2, this.parameters = i2;
        }
        isConstant() {
          return "constant" === this.value.kind;
        }
        constantOr(e2) {
          return "constant" === this.value.kind ? this.value.value : e2;
        }
        evaluate(e2, t2, i2, r2) {
          return this.property.evaluate(this.value, this.parameters, e2, t2, i2, r2);
        }
      }
      class PossiblyEvaluated {
        constructor(e2) {
          this._properties = e2, this._values = Object.create(e2.defaultPossiblyEvaluatedValues);
        }
        get(e2) {
          return this._values[e2];
        }
      }
      class DataConstantProperty {
        constructor(e2) {
          this.specification = e2;
        }
        possiblyEvaluate(e2, t2) {
          return e2.expression.evaluate(t2);
        }
        interpolate(e2, t2, i2) {
          const r2 = Mi[this.specification.type];
          return r2 ? r2(e2, t2, i2) : e2;
        }
      }
      class DataDrivenProperty {
        constructor(e2, t2) {
          this.specification = e2, this.overrides = t2;
        }
        possiblyEvaluate(e2, t2, i2, r2) {
          return new PossiblyEvaluatedPropertyValue(this, "constant" === e2.expression.kind || "camera" === e2.expression.kind ? { kind: "constant", value: e2.expression.evaluate(t2, null, {}, i2, r2) } : e2.expression, t2);
        }
        interpolate(e2, t2, i2) {
          if ("constant" !== e2.value.kind || "constant" !== t2.value.kind)
            return e2;
          if (void 0 === e2.value.value || void 0 === t2.value.value)
            return new PossiblyEvaluatedPropertyValue(this, { kind: "constant", value: void 0 }, e2.parameters);
          const r2 = Mi[this.specification.type];
          return r2 ? new PossiblyEvaluatedPropertyValue(this, { kind: "constant", value: r2(e2.value.value, t2.value.value, i2) }, e2.parameters) : e2;
        }
        evaluate(e2, t2, i2, r2, n2, o2) {
          return "constant" === e2.kind ? e2.value : e2.evaluate(t2, i2, r2, n2, o2);
        }
      }
      class ColorRampProperty {
        constructor(e2) {
          this.specification = e2;
        }
        possiblyEvaluate(e2, t2, i2, r2) {
          return !!e2.expression.evaluate(t2, null, {}, i2, r2);
        }
        interpolate() {
          return false;
        }
      }
      class Properties {
        constructor(e2) {
          this.properties = e2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          const t2 = new EvaluationParameters(0, {});
          for (const i2 in e2) {
            const r2 = e2[i2];
            r2.specification.overridable && this.overridableProperties.push(i2);
            const n2 = this.defaultPropertyValues[i2] = new PropertyValue(r2, void 0), o2 = this.defaultTransitionablePropertyValues[i2] = new TransitionablePropertyValue(r2);
            this.defaultTransitioningPropertyValues[i2] = o2.untransitioned(), this.defaultPossiblyEvaluatedValues[i2] = n2.possiblyEvaluate(t2);
          }
        }
      }
      function ao(e2, t2) {
        return 256 * (e2 = A(Math.floor(e2), 0, 255)) + A(Math.floor(t2), 0, 255);
      }
      kn(DataDrivenProperty, "DataDrivenProperty"), kn(DataConstantProperty, "DataConstantProperty"), kn(ColorRampProperty, "ColorRampProperty");
      const lo = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class Struct {
        constructor(e2, t2) {
          this._structArray = e2, this._pos1 = t2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class StructArray {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(e2, t2) {
          return e2._trim(), t2 && (e2.isTransferred = true, t2.push(e2.arrayBuffer)), { length: e2.length, arrayBuffer: e2.arrayBuffer };
        }
        static deserialize(e2) {
          const t2 = Object.create(this.prototype);
          return t2.arrayBuffer = e2.arrayBuffer, t2.length = e2.length, t2.capacity = e2.arrayBuffer.byteLength / t2.bytesPerElement, t2._refreshViews(), t2;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(e2) {
          this.reserve(e2), this.length = e2;
        }
        reserve(e2) {
          if (e2 > this.capacity) {
            this.capacity = Math.max(e2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const t2 = this.uint8;
            this._refreshViews(), t2 && this.uint8.set(t2);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
        destroy() {
          this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
        }
      }
      function co(e2, t2 = 1) {
        let i2 = 0, r2 = 0;
        return { members: e2.map((e3) => {
          const n2 = lo[e3.type].BYTES_PER_ELEMENT, o2 = i2 = uo(i2, Math.max(t2, n2)), s2 = e3.components || 1;
          return r2 = Math.max(r2, n2), i2 += n2 * s2, { name: e3.name, type: e3.type, components: s2, offset: o2 };
        }), size: uo(i2, Math.max(r2, t2)), alignment: t2 };
      }
      function uo(e2, t2) {
        return Math.ceil(e2 / t2) * t2;
      }
      class StructArrayLayout2i4 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, e2, t2);
        }
        emplace(e2, t2, i2) {
          const r2 = 2 * e2;
          return this.int16[r2 + 0] = t2, this.int16[r2 + 1] = i2, e2;
        }
      }
      StructArrayLayout2i4.prototype.bytesPerElement = 4, kn(StructArrayLayout2i4, "StructArrayLayout2i4");
      class StructArrayLayout3i6 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, e2, t2, i2);
        }
        emplace(e2, t2, i2, r2) {
          const n2 = 3 * e2;
          return this.int16[n2 + 0] = t2, this.int16[n2 + 1] = i2, this.int16[n2 + 2] = r2, e2;
        }
      }
      StructArrayLayout3i6.prototype.bytesPerElement = 6, kn(StructArrayLayout3i6, "StructArrayLayout3i6");
      class StructArrayLayout4i8 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, e2, t2, i2, r2);
        }
        emplace(e2, t2, i2, r2, n2) {
          const o2 = 4 * e2;
          return this.int16[o2 + 0] = t2, this.int16[o2 + 1] = i2, this.int16[o2 + 2] = r2, this.int16[o2 + 3] = n2, e2;
        }
      }
      StructArrayLayout4i8.prototype.bytesPerElement = 8, kn(StructArrayLayout4i8, "StructArrayLayout4i8");
      class StructArrayLayout2i4ub1f12 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2, n2, o2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, e2, t2, i2, r2, n2, o2, s2);
        }
        emplace(e2, t2, i2, r2, n2, o2, s2, a2) {
          const l2 = 6 * e2, c2 = 12 * e2, u2 = 3 * e2;
          return this.int16[l2 + 0] = t2, this.int16[l2 + 1] = i2, this.uint8[c2 + 4] = r2, this.uint8[c2 + 5] = n2, this.uint8[c2 + 6] = o2, this.uint8[c2 + 7] = s2, this.float32[u2 + 2] = a2, e2;
        }
      }
      StructArrayLayout2i4ub1f12.prototype.bytesPerElement = 12, kn(StructArrayLayout2i4ub1f12, "StructArrayLayout2i4ub1f12");
      class StructArrayLayout4f16 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, e2, t2, i2, r2);
        }
        emplace(e2, t2, i2, r2, n2) {
          const o2 = 4 * e2;
          return this.float32[o2 + 0] = t2, this.float32[o2 + 1] = i2, this.float32[o2 + 2] = r2, this.float32[o2 + 3] = n2, e2;
        }
      }
      StructArrayLayout4f16.prototype.bytesPerElement = 16, kn(StructArrayLayout4f16, "StructArrayLayout4f16");
      class StructArrayLayout4ui1f12 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2, n2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, e2, t2, i2, r2, n2);
        }
        emplace(e2, t2, i2, r2, n2, o2) {
          const s2 = 6 * e2, a2 = 3 * e2;
          return this.uint16[s2 + 0] = t2, this.uint16[s2 + 1] = i2, this.uint16[s2 + 2] = r2, this.uint16[s2 + 3] = n2, this.float32[a2 + 2] = o2, e2;
        }
      }
      StructArrayLayout4ui1f12.prototype.bytesPerElement = 12, kn(StructArrayLayout4ui1f12, "StructArrayLayout4ui1f12");
      class StructArrayLayout4ui8 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, e2, t2, i2, r2);
        }
        emplace(e2, t2, i2, r2, n2) {
          const o2 = 4 * e2;
          return this.uint16[o2 + 0] = t2, this.uint16[o2 + 1] = i2, this.uint16[o2 + 2] = r2, this.uint16[o2 + 3] = n2, e2;
        }
      }
      StructArrayLayout4ui8.prototype.bytesPerElement = 8, kn(StructArrayLayout4ui8, "StructArrayLayout4ui8");
      class StructArrayLayout6i12 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2, n2, o2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, e2, t2, i2, r2, n2, o2);
        }
        emplace(e2, t2, i2, r2, n2, o2, s2) {
          const a2 = 6 * e2;
          return this.int16[a2 + 0] = t2, this.int16[a2 + 1] = i2, this.int16[a2 + 2] = r2, this.int16[a2 + 3] = n2, this.int16[a2 + 4] = o2, this.int16[a2 + 5] = s2, e2;
        }
      }
      StructArrayLayout6i12.prototype.bytesPerElement = 12, kn(StructArrayLayout6i12, "StructArrayLayout6i12");
      class StructArrayLayout4i4ui4i24 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2) {
          const p2 = this.length;
          return this.resize(p2 + 1), this.emplace(p2, e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2);
        }
        emplace(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2) {
          const d2 = 12 * e2;
          return this.int16[d2 + 0] = t2, this.int16[d2 + 1] = i2, this.int16[d2 + 2] = r2, this.int16[d2 + 3] = n2, this.uint16[d2 + 4] = o2, this.uint16[d2 + 5] = s2, this.uint16[d2 + 6] = a2, this.uint16[d2 + 7] = l2, this.int16[d2 + 8] = c2, this.int16[d2 + 9] = u2, this.int16[d2 + 10] = h2, this.int16[d2 + 11] = p2, e2;
        }
      }
      StructArrayLayout4i4ui4i24.prototype.bytesPerElement = 24, kn(StructArrayLayout4i4ui4i24, "StructArrayLayout4i4ui4i24");
      class StructArrayLayout3i3f20 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2, n2, o2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, e2, t2, i2, r2, n2, o2);
        }
        emplace(e2, t2, i2, r2, n2, o2, s2) {
          const a2 = 10 * e2, l2 = 5 * e2;
          return this.int16[a2 + 0] = t2, this.int16[a2 + 1] = i2, this.int16[a2 + 2] = r2, this.float32[l2 + 2] = n2, this.float32[l2 + 3] = o2, this.float32[l2 + 4] = s2, e2;
        }
      }
      StructArrayLayout3i3f20.prototype.bytesPerElement = 20, kn(StructArrayLayout3i3f20, "StructArrayLayout3i3f20");
      class StructArrayLayout1ul4 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e2) {
          const t2 = this.length;
          return this.resize(t2 + 1), this.emplace(t2, e2);
        }
        emplace(e2, t2) {
          return this.uint32[1 * e2 + 0] = t2, e2;
        }
      }
      StructArrayLayout1ul4.prototype.bytesPerElement = 4, kn(StructArrayLayout1ul4, "StructArrayLayout1ul4");
      class StructArrayLayout5i4f1i1ul2ui40 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2) {
          const d2 = this.length;
          return this.resize(d2 + 1), this.emplace(d2, e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2);
        }
        emplace(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2) {
          const f2 = 20 * e2, m2 = 10 * e2;
          return this.int16[f2 + 0] = t2, this.int16[f2 + 1] = i2, this.int16[f2 + 2] = r2, this.int16[f2 + 3] = n2, this.int16[f2 + 4] = o2, this.float32[m2 + 3] = s2, this.float32[m2 + 4] = a2, this.float32[m2 + 5] = l2, this.float32[m2 + 6] = c2, this.int16[f2 + 14] = u2, this.uint32[m2 + 8] = h2, this.uint16[f2 + 18] = p2, this.uint16[f2 + 19] = d2, e2;
        }
      }
      StructArrayLayout5i4f1i1ul2ui40.prototype.bytesPerElement = 40, kn(StructArrayLayout5i4f1i1ul2ui40, "StructArrayLayout5i4f1i1ul2ui40");
      class StructArrayLayout3i2i2i16 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2, n2, o2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, e2, t2, i2, r2, n2, o2, s2);
        }
        emplace(e2, t2, i2, r2, n2, o2, s2, a2) {
          const l2 = 8 * e2;
          return this.int16[l2 + 0] = t2, this.int16[l2 + 1] = i2, this.int16[l2 + 2] = r2, this.int16[l2 + 4] = n2, this.int16[l2 + 5] = o2, this.int16[l2 + 6] = s2, this.int16[l2 + 7] = a2, e2;
        }
      }
      StructArrayLayout3i2i2i16.prototype.bytesPerElement = 16, kn(StructArrayLayout3i2i2i16, "StructArrayLayout3i2i2i16");
      class StructArrayLayout2f1f2i16 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2, n2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, e2, t2, i2, r2, n2);
        }
        emplace(e2, t2, i2, r2, n2, o2) {
          const s2 = 4 * e2, a2 = 8 * e2;
          return this.float32[s2 + 0] = t2, this.float32[s2 + 1] = i2, this.float32[s2 + 2] = r2, this.int16[a2 + 6] = n2, this.int16[a2 + 7] = o2, e2;
        }
      }
      StructArrayLayout2f1f2i16.prototype.bytesPerElement = 16, kn(StructArrayLayout2f1f2i16, "StructArrayLayout2f1f2i16");
      class StructArrayLayout2ub2f12 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, e2, t2, i2, r2);
        }
        emplace(e2, t2, i2, r2, n2) {
          const o2 = 12 * e2, s2 = 3 * e2;
          return this.uint8[o2 + 0] = t2, this.uint8[o2 + 1] = i2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, e2;
        }
      }
      StructArrayLayout2ub2f12.prototype.bytesPerElement = 12, kn(StructArrayLayout2ub2f12, "StructArrayLayout2ub2f12");
      class StructArrayLayout3f12 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, e2, t2, i2);
        }
        emplace(e2, t2, i2, r2) {
          const n2 = 3 * e2;
          return this.float32[n2 + 0] = t2, this.float32[n2 + 1] = i2, this.float32[n2 + 2] = r2, e2;
        }
      }
      StructArrayLayout3f12.prototype.bytesPerElement = 12, kn(StructArrayLayout3f12, "StructArrayLayout3f12");
      class StructArrayLayout3ui6 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, e2, t2, i2);
        }
        emplace(e2, t2, i2, r2) {
          const n2 = 3 * e2;
          return this.uint16[n2 + 0] = t2, this.uint16[n2 + 1] = i2, this.uint16[n2 + 2] = r2, e2;
        }
      }
      StructArrayLayout3ui6.prototype.bytesPerElement = 6, kn(StructArrayLayout3ui6, "StructArrayLayout3ui6");
      class StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2, m2, _2, g2, y2, x2, v2) {
          const b2 = this.length;
          return this.resize(b2 + 1), this.emplace(b2, e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2, m2, _2, g2, y2, x2, v2);
        }
        emplace(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2, m2, _2, g2, y2, x2, v2, b2) {
          const w2 = 30 * e2, T2 = 15 * e2, E2 = 60 * e2;
          return this.int16[w2 + 0] = t2, this.int16[w2 + 1] = i2, this.int16[w2 + 2] = r2, this.float32[T2 + 2] = n2, this.float32[T2 + 3] = o2, this.uint16[w2 + 8] = s2, this.uint16[w2 + 9] = a2, this.uint32[T2 + 5] = l2, this.uint32[T2 + 6] = c2, this.uint32[T2 + 7] = u2, this.uint16[w2 + 16] = h2, this.uint16[w2 + 17] = p2, this.uint16[w2 + 18] = d2, this.float32[T2 + 10] = f2, this.float32[T2 + 11] = m2, this.uint8[E2 + 48] = _2, this.uint8[E2 + 49] = g2, this.uint8[E2 + 50] = y2, this.uint32[T2 + 13] = x2, this.int16[w2 + 28] = v2, this.uint8[E2 + 58] = b2, e2;
        }
      }
      StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60.prototype.bytesPerElement = 60, kn(StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
      class StructArrayLayout3i2f6i15ui1ul3f76 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2, m2, _2, g2, y2, x2, v2, b2, w2, T2, E2, S2, A2, C2, I2, M2) {
          const D2 = this.length;
          return this.resize(D2 + 1), this.emplace(D2, e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2, m2, _2, g2, y2, x2, v2, b2, w2, T2, E2, S2, A2, C2, I2, M2);
        }
        emplace(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2, m2, _2, g2, y2, x2, v2, b2, w2, T2, E2, S2, A2, C2, I2, M2, D2) {
          const P2 = 38 * e2, z2 = 19 * e2;
          return this.int16[P2 + 0] = t2, this.int16[P2 + 1] = i2, this.int16[P2 + 2] = r2, this.float32[z2 + 2] = n2, this.float32[z2 + 3] = o2, this.int16[P2 + 8] = s2, this.int16[P2 + 9] = a2, this.int16[P2 + 10] = l2, this.int16[P2 + 11] = c2, this.int16[P2 + 12] = u2, this.int16[P2 + 13] = h2, this.uint16[P2 + 14] = p2, this.uint16[P2 + 15] = d2, this.uint16[P2 + 16] = f2, this.uint16[P2 + 17] = m2, this.uint16[P2 + 18] = _2, this.uint16[P2 + 19] = g2, this.uint16[P2 + 20] = y2, this.uint16[P2 + 21] = x2, this.uint16[P2 + 22] = v2, this.uint16[P2 + 23] = b2, this.uint16[P2 + 24] = w2, this.uint16[P2 + 25] = T2, this.uint16[P2 + 26] = E2, this.uint16[P2 + 27] = S2, this.uint16[P2 + 28] = A2, this.uint32[z2 + 15] = C2, this.float32[z2 + 16] = I2, this.float32[z2 + 17] = M2, this.float32[z2 + 18] = D2, e2;
        }
      }
      StructArrayLayout3i2f6i15ui1ul3f76.prototype.bytesPerElement = 76, kn(StructArrayLayout3i2f6i15ui1ul3f76, "StructArrayLayout3i2f6i15ui1ul3f76");
      class StructArrayLayout1f4 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e2) {
          const t2 = this.length;
          return this.resize(t2 + 1), this.emplace(t2, e2);
        }
        emplace(e2, t2) {
          return this.float32[1 * e2 + 0] = t2, e2;
        }
      }
      StructArrayLayout1f4.prototype.bytesPerElement = 4, kn(StructArrayLayout1f4, "StructArrayLayout1f4");
      class StructArrayLayout5f20 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2, n2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, e2, t2, i2, r2, n2);
        }
        emplace(e2, t2, i2, r2, n2, o2) {
          const s2 = 5 * e2;
          return this.float32[s2 + 0] = t2, this.float32[s2 + 1] = i2, this.float32[s2 + 2] = r2, this.float32[s2 + 3] = n2, this.float32[s2 + 4] = o2, e2;
        }
      }
      StructArrayLayout5f20.prototype.bytesPerElement = 20, kn(StructArrayLayout5f20, "StructArrayLayout5f20");
      class StructArrayLayout1ul3ui12 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2, i2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, e2, t2, i2, r2);
        }
        emplace(e2, t2, i2, r2, n2) {
          const o2 = 6 * e2;
          return this.uint32[3 * e2 + 0] = t2, this.uint16[o2 + 2] = i2, this.uint16[o2 + 3] = r2, this.uint16[o2 + 4] = n2, e2;
        }
      }
      StructArrayLayout1ul3ui12.prototype.bytesPerElement = 12, kn(StructArrayLayout1ul3ui12, "StructArrayLayout1ul3ui12");
      class StructArrayLayout2ui4 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, e2, t2);
        }
        emplace(e2, t2, i2) {
          const r2 = 2 * e2;
          return this.uint16[r2 + 0] = t2, this.uint16[r2 + 1] = i2, e2;
        }
      }
      StructArrayLayout2ui4.prototype.bytesPerElement = 4, kn(StructArrayLayout2ui4, "StructArrayLayout2ui4");
      class StructArrayLayout1ui2 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e2) {
          const t2 = this.length;
          return this.resize(t2 + 1), this.emplace(t2, e2);
        }
        emplace(e2, t2) {
          return this.uint16[1 * e2 + 0] = t2, e2;
        }
      }
      StructArrayLayout1ui2.prototype.bytesPerElement = 2, kn(StructArrayLayout1ui2, "StructArrayLayout1ui2");
      class StructArrayLayout2f8 extends StructArray {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e2, t2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, e2, t2);
        }
        emplace(e2, t2, i2) {
          const r2 = 2 * e2;
          return this.float32[r2 + 0] = t2, this.float32[r2 + 1] = i2, e2;
        }
      }
      StructArrayLayout2f8.prototype.bytesPerElement = 8, kn(StructArrayLayout2f8, "StructArrayLayout2f8");
      class CollisionBoxStruct extends Struct {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get tileAnchorY() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get x1() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get y1() {
          return this._structArray.float32[this._pos4 + 4];
        }
        get x2() {
          return this._structArray.float32[this._pos4 + 5];
        }
        get y2() {
          return this._structArray.float32[this._pos4 + 6];
        }
        get padding() {
          return this._structArray.int16[this._pos2 + 14];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 8];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
      }
      CollisionBoxStruct.prototype.size = 40;
      class CollisionBoxArray extends StructArrayLayout5i4f1i1ul2ui40 {
        get(e2) {
          return new CollisionBoxStruct(this, e2);
        }
      }
      kn(CollisionBoxArray, "CollisionBoxArray");
      class PlacedSymbolStruct extends Struct {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 5];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 6];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 10];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 11];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 48];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 49];
        }
        set placedOrientation(e2) {
          this._structArray.uint8[this._pos1 + 49] = e2;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 50];
        }
        set hidden(e2) {
          this._structArray.uint8[this._pos1 + 50] = e2;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 13];
        }
        set crossTileID(e2) {
          this._structArray.uint32[this._pos4 + 13] = e2;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 28];
        }
        get flipState() {
          return this._structArray.uint8[this._pos1 + 58];
        }
        set flipState(e2) {
          this._structArray.uint8[this._pos1 + 58] = e2;
        }
      }
      PlacedSymbolStruct.prototype.size = 60;
      class PlacedSymbolArray extends StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60 {
        get(e2) {
          return new PlacedSymbolStruct(this, e2);
        }
      }
      kn(PlacedSymbolArray, "PlacedSymbolArray");
      class SymbolInstanceStruct extends Struct {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 8];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 9];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 10];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 11];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 12];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 13];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 23];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 24];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 25];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 26];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 27];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 28];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 15];
        }
        set crossTileID(e2) {
          this._structArray.uint32[this._pos4 + 15] = e2;
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 16];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 17];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 18];
        }
      }
      SymbolInstanceStruct.prototype.size = 76;
      class SymbolInstanceArray extends StructArrayLayout3i2f6i15ui1ul3f76 {
        get(e2) {
          return new SymbolInstanceStruct(this, e2);
        }
      }
      kn(SymbolInstanceArray, "SymbolInstanceArray");
      class GlyphOffsetArray extends StructArrayLayout1f4 {
        getoffsetX(e2) {
          return this.float32[1 * e2 + 0];
        }
      }
      kn(GlyphOffsetArray, "GlyphOffsetArray");
      class SymbolLineVertexArray extends StructArrayLayout2i4 {
        getx(e2) {
          return this.int16[2 * e2 + 0];
        }
        gety(e2) {
          return this.int16[2 * e2 + 1];
        }
      }
      kn(SymbolLineVertexArray, "SymbolLineVertexArray");
      class FeatureIndexStruct extends Struct {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get layoutVertexArrayOffset() {
          return this._structArray.uint16[this._pos2 + 4];
        }
      }
      FeatureIndexStruct.prototype.size = 12;
      class FeatureIndexArray extends StructArrayLayout1ul3ui12 {
        get(e2) {
          return new FeatureIndexStruct(this, e2);
        }
      }
      kn(FeatureIndexArray, "FeatureIndexArray");
      class FillExtrusionCentroidArray extends StructArrayLayout2ui4 {
        geta_centroid_pos0(e2) {
          return this.uint16[2 * e2 + 0];
        }
        geta_centroid_pos1(e2) {
          return this.uint16[2 * e2 + 1];
        }
      }
      kn(FillExtrusionCentroidArray, "FillExtrusionCentroidArray");
      const ho = co([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), po = co([{ name: "a_dash", components: 4, type: "Uint16" }]);
      var fo = { exports: {} }, mo = { exports: {} };
      !function(e2) {
        e2.exports = function(e3, t2) {
          var i2, r2, n2, o2, s2, a2, l2, c2;
          for (r2 = e3.length - (i2 = 3 & e3.length), n2 = t2, s2 = 3432918353, a2 = 461845907, c2 = 0; c2 < r2; )
            l2 = 255 & e3.charCodeAt(c2) | (255 & e3.charCodeAt(++c2)) << 8 | (255 & e3.charCodeAt(++c2)) << 16 | (255 & e3.charCodeAt(++c2)) << 24, ++c2, n2 = 27492 + (65535 & (o2 = 5 * (65535 & (n2 = (n2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * s2 + (((l2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 13 | n2 >>> 19)) + ((5 * (n2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (o2 >>> 16) & 65535) << 16);
          switch (l2 = 0, i2) {
            case 3:
              l2 ^= (255 & e3.charCodeAt(c2 + 2)) << 16;
            case 2:
              l2 ^= (255 & e3.charCodeAt(c2 + 1)) << 8;
            case 1:
              n2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & e3.charCodeAt(c2))) * s2 + (((l2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295;
          }
          return n2 ^= e3.length, n2 = 2246822507 * (65535 & (n2 ^= n2 >>> 16)) + ((2246822507 * (n2 >>> 16) & 65535) << 16) & 4294967295, n2 = 3266489909 * (65535 & (n2 ^= n2 >>> 13)) + ((3266489909 * (n2 >>> 16) & 65535) << 16) & 4294967295, (n2 ^= n2 >>> 16) >>> 0;
        };
      }(mo);
      var _o = { exports: {} };
      !function(e2) {
        e2.exports = function(e3, t2) {
          for (var i2, r2 = e3.length, n2 = t2 ^ r2, o2 = 0; r2 >= 4; )
            i2 = 1540483477 * (65535 & (i2 = 255 & e3.charCodeAt(o2) | (255 & e3.charCodeAt(++o2)) << 8 | (255 & e3.charCodeAt(++o2)) << 16 | (255 & e3.charCodeAt(++o2)) << 24)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), n2 = 1540483477 * (65535 & n2) + ((1540483477 * (n2 >>> 16) & 65535) << 16) ^ (i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 24)) + ((1540483477 * (i2 >>> 16) & 65535) << 16)), r2 -= 4, ++o2;
          switch (r2) {
            case 3:
              n2 ^= (255 & e3.charCodeAt(o2 + 2)) << 16;
            case 2:
              n2 ^= (255 & e3.charCodeAt(o2 + 1)) << 8;
            case 1:
              n2 = 1540483477 * (65535 & (n2 ^= 255 & e3.charCodeAt(o2))) + ((1540483477 * (n2 >>> 16) & 65535) << 16);
          }
          return n2 = 1540483477 * (65535 & (n2 ^= n2 >>> 13)) + ((1540483477 * (n2 >>> 16) & 65535) << 16), (n2 ^= n2 >>> 15) >>> 0;
        };
      }(_o);
      var go = mo.exports, yo = _o.exports;
      fo.exports = go, fo.exports.murmur3 = go, fo.exports.murmur2 = yo;
      class FeaturePositionMap {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = false;
        }
        add(e2, t2, i2, r2) {
          this.ids.push(xo(e2)), this.positions.push(t2, i2, r2);
        }
        getPositions(e2) {
          const t2 = xo(e2);
          let i2 = 0, r2 = this.ids.length - 1;
          for (; i2 < r2; ) {
            const e3 = i2 + r2 >> 1;
            this.ids[e3] >= t2 ? r2 = e3 : i2 = e3 + 1;
          }
          const n2 = [];
          for (; this.ids[i2] === t2; )
            n2.push({ index: this.positions[3 * i2], start: this.positions[3 * i2 + 1], end: this.positions[3 * i2 + 2] }), i2++;
          return n2;
        }
        static serialize(e2, t2) {
          const i2 = new Float64Array(e2.ids), r2 = new Uint32Array(e2.positions);
          return vo(i2, r2, 0, i2.length - 1), t2 && t2.push(i2.buffer, r2.buffer), { ids: i2, positions: r2 };
        }
        static deserialize(e2) {
          const t2 = new FeaturePositionMap();
          return t2.ids = e2.ids, t2.positions = e2.positions, t2.indexed = true, t2;
        }
      }
      function xo(e2) {
        const t2 = +e2;
        return !isNaN(t2) && Number.MIN_SAFE_INTEGER <= t2 && t2 <= Number.MAX_SAFE_INTEGER ? t2 : fo.exports(String(e2));
      }
      function vo(e2, t2, i2, r2) {
        for (; i2 < r2; ) {
          const n2 = e2[i2 + r2 >> 1];
          let o2 = i2 - 1, s2 = r2 + 1;
          for (; ; ) {
            do {
              o2++;
            } while (e2[o2] < n2);
            do {
              s2--;
            } while (e2[s2] > n2);
            if (o2 >= s2)
              break;
            bo(e2, o2, s2), bo(t2, 3 * o2, 3 * s2), bo(t2, 3 * o2 + 1, 3 * s2 + 1), bo(t2, 3 * o2 + 2, 3 * s2 + 2);
          }
          s2 - i2 < r2 - s2 ? (vo(e2, t2, i2, s2), i2 = s2 + 1) : (vo(e2, t2, s2 + 1, r2), r2 = s2);
        }
      }
      function bo(e2, t2, i2) {
        const r2 = e2[t2];
        e2[t2] = e2[i2], e2[i2] = r2;
      }
      kn(FeaturePositionMap, "FeaturePositionMap");
      class Uniform {
        constructor(e2) {
          this.gl = e2.gl, this.initialized = false;
        }
        fetchUniformLocation(e2, t2) {
          return this.location || this.initialized || (this.location = this.gl.getUniformLocation(e2, t2), this.initialized = true), !!this.location;
        }
      }
      class Uniform1i extends Uniform {
        constructor(e2) {
          super(e2), this.current = 0;
        }
        set(e2, t2, i2) {
          this.fetchUniformLocation(e2, t2) && this.current !== i2 && (this.current = i2, this.gl.uniform1i(this.location, i2));
        }
      }
      class Uniform1f extends Uniform {
        constructor(e2) {
          super(e2), this.current = 0;
        }
        set(e2, t2, i2) {
          this.fetchUniformLocation(e2, t2) && this.current !== i2 && (this.current = i2, this.gl.uniform1f(this.location, i2));
        }
      }
      class Uniform2f extends Uniform {
        constructor(e2) {
          super(e2), this.current = [0, 0];
        }
        set(e2, t2, i2) {
          this.fetchUniformLocation(e2, t2) && (i2[0] === this.current[0] && i2[1] === this.current[1] || (this.current = i2, this.gl.uniform2f(this.location, i2[0], i2[1])));
        }
      }
      class Uniform3f extends Uniform {
        constructor(e2) {
          super(e2), this.current = [0, 0, 0];
        }
        set(e2, t2, i2) {
          this.fetchUniformLocation(e2, t2) && (i2[0] === this.current[0] && i2[1] === this.current[1] && i2[2] === this.current[2] || (this.current = i2, this.gl.uniform3f(this.location, i2[0], i2[1], i2[2])));
        }
      }
      class Uniform4f extends Uniform {
        constructor(e2) {
          super(e2), this.current = [0, 0, 0, 0];
        }
        set(e2, t2, i2) {
          this.fetchUniformLocation(e2, t2) && (i2[0] === this.current[0] && i2[1] === this.current[1] && i2[2] === this.current[2] && i2[3] === this.current[3] || (this.current = i2, this.gl.uniform4f(this.location, i2[0], i2[1], i2[2], i2[3])));
        }
      }
      class UniformColor extends Uniform {
        constructor(e2) {
          super(e2), this.current = Gt.transparent;
        }
        set(e2, t2, i2) {
          this.fetchUniformLocation(e2, t2) && (i2.r === this.current.r && i2.g === this.current.g && i2.b === this.current.b && i2.a === this.current.a || (this.current = i2, this.gl.uniform4f(this.location, i2.r, i2.g, i2.b, i2.a)));
        }
      }
      const wo = new Float32Array(16);
      class UniformMatrix4f extends Uniform {
        constructor(e2) {
          super(e2), this.current = wo;
        }
        set(e2, t2, i2) {
          if (this.fetchUniformLocation(e2, t2)) {
            if (i2[12] !== this.current[12] || i2[0] !== this.current[0])
              return this.current = i2, void this.gl.uniformMatrix4fv(this.location, false, i2);
            for (let e3 = 1; e3 < 16; e3++)
              if (i2[e3] !== this.current[e3]) {
                this.current = i2, this.gl.uniformMatrix4fv(this.location, false, i2);
                break;
              }
          }
        }
      }
      const To = new Float32Array(9);
      class UniformMatrix3f extends Uniform {
        constructor(e2) {
          super(e2), this.current = To;
        }
        set(e2, t2, i2) {
          if (this.fetchUniformLocation(e2, t2)) {
            for (let e3 = 0; e3 < 9; e3++)
              if (i2[e3] !== this.current[e3]) {
                this.current = i2, this.gl.uniformMatrix3fv(this.location, false, i2);
                break;
              }
          }
        }
      }
      const Eo = new Float32Array(4);
      class UniformMatrix2f extends Uniform {
        constructor(e2) {
          super(e2), this.current = Eo;
        }
        set(e2, t2, i2) {
          if (this.fetchUniformLocation(e2, t2)) {
            for (let e3 = 0; e3 < 4; e3++)
              if (i2[e3] !== this.current[e3]) {
                this.current = i2, this.gl.uniformMatrix2fv(this.location, false, i2);
                break;
              }
          }
        }
      }
      function So(e2) {
        return [ao(255 * e2.r, 255 * e2.g), ao(255 * e2.b, 255 * e2.a)];
      }
      class ConstantBinder {
        constructor(e2, t2, i2) {
          this.value = e2, this.uniformNames = t2.map((e3) => `u_${e3}`), this.type = i2;
        }
        setUniform(e2, t2, i2, r2, n2) {
          t2.set(e2, n2, r2.constantOr(this.value));
        }
        getBinding(e2, t2) {
          return "color" === this.type ? new UniformColor(e2) : new Uniform1f(e2);
        }
      }
      class PatternConstantBinder {
        constructor(e2, t2) {
          this.uniformNames = t2.map((e3) => `u_${e3}`), this.pattern = null, this.pixelRatio = 1;
        }
        setConstantPatternPositions(e2) {
          this.pixelRatio = e2.pixelRatio || 1, this.pattern = e2.tl.concat(e2.br);
        }
        setUniform(e2, t2, i2, r2, n2) {
          const o2 = "u_pattern" === n2 || "u_dash" === n2 ? this.pattern : "u_pixel_ratio" === n2 ? this.pixelRatio : null;
          o2 && t2.set(e2, n2, o2);
        }
        getBinding(e2, t2) {
          return "u_pattern" === t2 || "u_dash" === t2 ? new Uniform4f(e2) : new Uniform1f(e2);
        }
      }
      class SourceExpressionBinder {
        constructor(e2, t2, i2, r2) {
          this.expression = e2, this.type = i2, this.maxValue = 0, this.paintVertexAttributes = t2.map((e3) => ({ name: `a_${e3}`, type: "Float32", components: "color" === i2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new r2();
        }
        populatePaintArray(e2, t2, i2, r2, n2, o2) {
          const s2 = this.paintVertexArray.length, a2 = this.expression.evaluate(new EvaluationParameters(0), t2, {}, n2, r2, o2);
          this.paintVertexArray.resize(e2), this._setPaintValue(s2, e2, a2);
        }
        updatePaintArray(e2, t2, i2, r2, n2) {
          const o2 = this.expression.evaluate({ zoom: 0 }, i2, r2, void 0, n2);
          this._setPaintValue(e2, t2, o2);
        }
        _setPaintValue(e2, t2, i2) {
          if ("color" === this.type) {
            const r2 = So(i2);
            for (let i3 = e2; i3 < t2; i3++)
              this.paintVertexArray.emplace(i3, r2[0], r2[1]);
          } else {
            for (let r2 = e2; r2 < t2; r2++)
              this.paintVertexArray.emplace(r2, i2);
            this.maxValue = Math.max(this.maxValue, Math.abs(i2));
          }
        }
        upload(e2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class CompositeExpressionBinder {
        constructor(e2, t2, i2, r2, n2, o2) {
          this.expression = e2, this.uniformNames = t2.map((e3) => `u_${e3}_t`), this.type = i2, this.useIntegerZoom = r2, this.zoom = n2, this.maxValue = 0, this.paintVertexAttributes = t2.map((e3) => ({ name: `a_${e3}`, type: "Float32", components: "color" === i2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new o2();
        }
        populatePaintArray(e2, t2, i2, r2, n2, o2) {
          const s2 = this.expression.evaluate(new EvaluationParameters(this.zoom), t2, {}, n2, r2, o2), a2 = this.expression.evaluate(new EvaluationParameters(this.zoom + 1), t2, {}, n2, r2, o2), l2 = this.paintVertexArray.length;
          this.paintVertexArray.resize(e2), this._setPaintValue(l2, e2, s2, a2);
        }
        updatePaintArray(e2, t2, i2, r2, n2) {
          const o2 = this.expression.evaluate({ zoom: this.zoom }, i2, r2, void 0, n2), s2 = this.expression.evaluate({ zoom: this.zoom + 1 }, i2, r2, void 0, n2);
          this._setPaintValue(e2, t2, o2, s2);
        }
        _setPaintValue(e2, t2, i2, r2) {
          if ("color" === this.type) {
            const n2 = So(i2), o2 = So(r2);
            for (let i3 = e2; i3 < t2; i3++)
              this.paintVertexArray.emplace(i3, n2[0], n2[1], o2[0], o2[1]);
          } else {
            for (let n2 = e2; n2 < t2; n2++)
              this.paintVertexArray.emplace(n2, i2, r2);
            this.maxValue = Math.max(this.maxValue, Math.abs(i2), Math.abs(r2));
          }
        }
        upload(e2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(e2, t2, i2, r2, n2) {
          const o2 = this.useIntegerZoom ? Math.floor(i2.zoom) : i2.zoom, s2 = A(this.expression.interpolationFactor(o2, this.zoom, this.zoom + 1), 0, 1);
          t2.set(e2, n2, s2);
        }
        getBinding(e2, t2) {
          return new Uniform1f(e2);
        }
      }
      class PatternCompositeBinder {
        constructor(e2, t2, i2, r2, n2) {
          this.expression = e2, this.layerId = n2, this.paintVertexAttributes = ("array" === i2 ? po : ho).members;
          for (let e3 = 0; e3 < t2.length; ++e3)
            ;
          this.paintVertexArray = new r2();
        }
        populatePaintArray(e2, t2, i2) {
          const r2 = this.paintVertexArray.length;
          this.paintVertexArray.resize(e2), this._setPaintValues(r2, e2, t2.patterns && t2.patterns[this.layerId], i2);
        }
        updatePaintArray(e2, t2, i2, r2, n2, o2) {
          this._setPaintValues(e2, t2, i2.patterns && i2.patterns[this.layerId], o2);
        }
        _setPaintValues(e2, t2, i2, r2) {
          if (!r2 || !i2)
            return;
          const n2 = r2[i2];
          if (!n2)
            return;
          const { tl: o2, br: s2, pixelRatio: a2 } = n2;
          for (let i3 = e2; i3 < t2; i3++)
            this.paintVertexArray.emplace(i3, o2[0], o2[1], s2[0], s2[1], a2);
        }
        upload(e2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = e2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class ProgramConfiguration {
        constructor(e2, t2, i2 = () => true) {
          this.binders = {}, this._buffers = [];
          const r2 = [];
          for (const n2 in e2.paint._values) {
            if (!i2(n2))
              continue;
            const o2 = e2.paint.get(n2);
            if (!(o2 instanceof PossiblyEvaluatedPropertyValue && vr(o2.property.specification)))
              continue;
            const s2 = Co(n2, e2.type), a2 = o2.value, l2 = o2.property.specification.type, c2 = o2.property.useIntegerZoom, u2 = "line-dasharray" === n2 || n2.endsWith("pattern"), h2 = "line-dasharray" === n2 && "constant" !== e2.layout.get("line-cap").value.kind;
            if ("constant" !== a2.kind || h2)
              if ("source" === a2.kind || h2 || u2) {
                const t3 = Do(n2, l2, "source");
                this.binders[n2] = u2 ? new PatternCompositeBinder(a2, s2, l2, t3, e2.id) : new SourceExpressionBinder(a2, s2, l2, t3), r2.push(`/a_${n2}`);
              } else {
                const e3 = Do(n2, l2, "composite");
                this.binders[n2] = new CompositeExpressionBinder(a2, s2, l2, c2, t2, e3), r2.push(`/z_${n2}`);
              }
            else
              this.binders[n2] = u2 ? new PatternConstantBinder(a2.value, s2) : new ConstantBinder(a2.value, s2, l2), r2.push(`/u_${n2}`);
          }
          this.cacheKey = r2.sort().join("");
        }
        getMaxValue(e2) {
          const t2 = this.binders[e2];
          return t2 instanceof SourceExpressionBinder || t2 instanceof CompositeExpressionBinder ? t2.maxValue : 0;
        }
        populatePaintArrays(e2, t2, i2, r2, n2, o2) {
          for (const s2 in this.binders) {
            const a2 = this.binders[s2];
            (a2 instanceof SourceExpressionBinder || a2 instanceof CompositeExpressionBinder || a2 instanceof PatternCompositeBinder) && a2.populatePaintArray(e2, t2, i2, r2, n2, o2);
          }
        }
        setConstantPatternPositions(e2) {
          for (const t2 in this.binders) {
            const i2 = this.binders[t2];
            i2 instanceof PatternConstantBinder && i2.setConstantPatternPositions(e2);
          }
        }
        updatePaintArrays(e2, t2, i2, r2, n2, o2) {
          let s2 = false;
          for (const a2 in e2) {
            const l2 = t2.getPositions(a2);
            for (const t3 of l2) {
              const l3 = i2.feature(t3.index);
              for (const i3 in this.binders) {
                const c2 = this.binders[i3];
                if ((c2 instanceof SourceExpressionBinder || c2 instanceof CompositeExpressionBinder || c2 instanceof PatternCompositeBinder) && true === c2.expression.isStateDependent) {
                  const u2 = r2.paint.get(i3);
                  c2.expression = u2.value, c2.updatePaintArray(t3.start, t3.end, l3, e2[a2], n2, o2), s2 = true;
                }
              }
            }
          }
          return s2;
        }
        defines() {
          const e2 = [];
          for (const t2 in this.binders) {
            const i2 = this.binders[t2];
            (i2 instanceof ConstantBinder || i2 instanceof PatternConstantBinder) && e2.push(...i2.uniformNames.map((e3) => `#define HAS_UNIFORM_${e3}`));
          }
          return e2;
        }
        getBinderAttributes() {
          const e2 = [];
          for (const t2 in this.binders) {
            const i2 = this.binders[t2];
            if (i2 instanceof SourceExpressionBinder || i2 instanceof CompositeExpressionBinder || i2 instanceof PatternCompositeBinder)
              for (let t3 = 0; t3 < i2.paintVertexAttributes.length; t3++)
                e2.push(i2.paintVertexAttributes[t3].name);
          }
          return e2;
        }
        getBinderUniforms() {
          const e2 = [];
          for (const t2 in this.binders) {
            const i2 = this.binders[t2];
            if (i2 instanceof ConstantBinder || i2 instanceof PatternConstantBinder || i2 instanceof CompositeExpressionBinder)
              for (const t3 of i2.uniformNames)
                e2.push(t3);
          }
          return e2;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(e2) {
          const t2 = [];
          for (const i2 in this.binders) {
            const r2 = this.binders[i2];
            if (r2 instanceof ConstantBinder || r2 instanceof PatternConstantBinder || r2 instanceof CompositeExpressionBinder)
              for (const n2 of r2.uniformNames)
                t2.push({ name: n2, property: i2, binding: r2.getBinding(e2, n2) });
          }
          return t2;
        }
        setUniforms(e2, t2, i2, r2, n2) {
          for (const { name: t3, property: o2, binding: s2 } of i2)
            this.binders[o2].setUniform(e2, s2, n2, r2.get(o2), t3);
        }
        updatePaintBuffers() {
          this._buffers = [];
          for (const e2 in this.binders) {
            const t2 = this.binders[e2];
            (t2 instanceof SourceExpressionBinder || t2 instanceof CompositeExpressionBinder || t2 instanceof PatternCompositeBinder) && t2.paintVertexBuffer && this._buffers.push(t2.paintVertexBuffer);
          }
        }
        upload(e2) {
          for (const t2 in this.binders) {
            const i2 = this.binders[t2];
            (i2 instanceof SourceExpressionBinder || i2 instanceof CompositeExpressionBinder || i2 instanceof PatternCompositeBinder) && i2.upload(e2);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const e2 in this.binders) {
            const t2 = this.binders[e2];
            (t2 instanceof SourceExpressionBinder || t2 instanceof CompositeExpressionBinder || t2 instanceof PatternCompositeBinder) && t2.destroy();
          }
        }
      }
      class ProgramConfigurationSet {
        constructor(e2, t2, i2 = () => true) {
          this.programConfigurations = {};
          for (const r2 of e2)
            this.programConfigurations[r2.id] = new ProgramConfiguration(r2, t2, i2);
          this.needsUpload = false, this._featureMap = new FeaturePositionMap(), this._bufferOffset = 0;
        }
        populatePaintArrays(e2, t2, i2, r2, n2, o2, s2) {
          for (const i3 in this.programConfigurations)
            this.programConfigurations[i3].populatePaintArrays(e2, t2, r2, n2, o2, s2);
          void 0 !== t2.id && this._featureMap.add(t2.id, i2, this._bufferOffset, e2), this._bufferOffset = e2, this.needsUpload = true;
        }
        updatePaintArrays(e2, t2, i2, r2, n2) {
          for (const o2 of i2)
            this.needsUpload = this.programConfigurations[o2.id].updatePaintArrays(e2, this._featureMap, t2, o2, r2, n2) || this.needsUpload;
        }
        get(e2) {
          return this.programConfigurations[e2];
        }
        upload(e2) {
          if (this.needsUpload) {
            for (const t2 in this.programConfigurations)
              this.programConfigurations[t2].upload(e2);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (const e2 in this.programConfigurations)
            this.programConfigurations[e2].destroy();
        }
      }
      const Ao = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
      function Co(e2, t2) {
        return Ao[e2] || [e2.replace(`${t2}-`, "").replace(/-/g, "_")];
      }
      const Io = { "line-pattern": { source: StructArrayLayout4ui1f12, composite: StructArrayLayout4ui1f12 }, "fill-pattern": { source: StructArrayLayout4ui1f12, composite: StructArrayLayout4ui1f12 }, "fill-extrusion-pattern": { source: StructArrayLayout4ui1f12, composite: StructArrayLayout4ui1f12 }, "line-dasharray": { source: StructArrayLayout4ui8, composite: StructArrayLayout4ui8 } }, Mo = { color: { source: StructArrayLayout2f8, composite: StructArrayLayout4f16 }, number: { source: StructArrayLayout1f4, composite: StructArrayLayout2f8 } };
      function Do(e2, t2, i2) {
        const r2 = Io[e2];
        return r2 && r2[i2] || Mo[t2][i2];
      }
      kn(ConstantBinder, "ConstantBinder"), kn(PatternConstantBinder, "PatternConstantBinder"), kn(SourceExpressionBinder, "SourceExpressionBinder"), kn(PatternCompositeBinder, "PatternCompositeBinder"), kn(CompositeExpressionBinder, "CompositeExpressionBinder"), kn(ProgramConfiguration, "ProgramConfiguration", { omit: ["_buffers"] }), kn(ProgramConfigurationSet, "ProgramConfigurationSet");
      const Po = "-transition";
      class StyleLayer extends Evented {
        constructor(e2, t2) {
          if (super(), this.id = e2.id, this.type = e2.type, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, "custom" !== e2.type && (this.metadata = e2.metadata, this.minzoom = e2.minzoom, this.maxzoom = e2.maxzoom, "background" !== e2.type && "sky" !== e2.type && (this.source = e2.source, this.sourceLayer = e2["source-layer"], this.filter = e2.filter), t2.layout && (this._unevaluatedLayout = new Layout(t2.layout)), t2.paint)) {
            this._transitionablePaint = new Transitionable(t2.paint);
            for (const t3 in e2.paint)
              this.setPaintProperty(t3, e2.paint[t3], { validate: false });
            for (const t3 in e2.layout)
              this.setLayoutProperty(t3, e2.layout[t3], { validate: false });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new PossiblyEvaluated(t2.paint);
          }
        }
        getLayoutProperty(e2) {
          return "visibility" === e2 ? this.visibility : this._unevaluatedLayout.getValue(e2);
        }
        setLayoutProperty(e2, t2, i2 = {}) {
          null != t2 && this._validate(Cn, `layers.${this.id}.layout.${e2}`, e2, t2, i2) || ("visibility" !== e2 ? this._unevaluatedLayout.setValue(e2, t2) : this.visibility = t2);
        }
        getPaintProperty(e2) {
          return U(e2, Po) ? this._transitionablePaint.getTransition(e2.slice(0, -Po.length)) : this._transitionablePaint.getValue(e2);
        }
        setPaintProperty(e2, t2, i2 = {}) {
          if (null != t2 && this._validate(An, `layers.${this.id}.paint.${e2}`, e2, t2, i2))
            return false;
          if (U(e2, Po))
            return this._transitionablePaint.setTransition(e2.slice(0, -Po.length), t2 || void 0), false;
          {
            const i3 = this._transitionablePaint._values[e2], r2 = i3.value.isDataDriven(), n2 = i3.value;
            this._transitionablePaint.setValue(e2, t2), this._handleSpecialPaintPropertyUpdate(e2);
            const o2 = this._transitionablePaint._values[e2].value, s2 = o2.isDataDriven(), a2 = U(e2, "pattern") || "line-dasharray" === e2;
            return s2 || r2 || a2 || this._handleOverridablePaintPropertyUpdate(e2, n2, o2);
          }
        }
        _handleSpecialPaintPropertyUpdate(e2) {
        }
        getProgramIds() {
          return null;
        }
        getProgramConfiguration(e2) {
          return null;
        }
        _handleOverridablePaintPropertyUpdate(e2, t2, i2) {
          return false;
        }
        isHidden(e2) {
          return !!(this.minzoom && e2 < this.minzoom) || !!(this.maxzoom && e2 >= this.maxzoom) || "none" === this.visibility;
        }
        updateTransitions(e2) {
          this._transitioningPaint = this._transitionablePaint.transitioned(e2, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(e2, t2) {
          this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e2, void 0, t2)), this.paint = this._transitioningPaint.possiblyEvaluate(e2, void 0, t2);
        }
        serialize() {
          const e2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (e2.layout = e2.layout || {}, e2.layout.visibility = this.visibility), j(e2, (e3, t2) => !(void 0 === e3 || "layout" === t2 && !Object.keys(e3).length || "paint" === t2 && !Object.keys(e3).length));
        }
        _validate(e2, t2, i2, r2, n2 = {}) {
          return (!n2 || false !== n2.validate) && Dn(this, e2.call(xn, { key: t2, layerType: this.type, objectKey: i2, value: r2, styleSpec: ft, style: { glyphs: true, sprite: true } }));
        }
        is3D() {
          return false;
        }
        isSky() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        resize() {
        }
        isStateDependent() {
          for (const e2 in this.paint._values) {
            const t2 = this.paint.get(e2);
            if (t2 instanceof PossiblyEvaluatedPropertyValue && vr(t2.property.specification) && ("source" === t2.value.kind || "composite" === t2.value.kind) && t2.value.isStateDependent)
              return true;
          }
          return false;
        }
        compileFilter() {
          this._filterCompiled || (this._featureFilter = qr(this.filter), this._filterCompiled = true);
        }
        invalidateCompiledFilter() {
          this._filterCompiled = false;
        }
        dynamicFilter() {
          return this._featureFilter.dynamicFilter;
        }
        dynamicFilterNeedsFeature() {
          return this._featureFilter.needFeature;
        }
      }
      const zo = co([{ name: "a_pos", components: 2, type: "Int16" }], 4), Lo = co([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
      class SegmentVector {
        constructor(e2 = []) {
          this.segments = e2;
        }
        prepareSegment(e2, t2, i2, r2) {
          let n2 = this.segments[this.segments.length - 1];
          return e2 > SegmentVector.MAX_VERTEX_ARRAY_LENGTH && Z(`Max vertices per segment is ${SegmentVector.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e2}`), (!n2 || n2.vertexLength + e2 > SegmentVector.MAX_VERTEX_ARRAY_LENGTH || n2.sortKey !== r2) && (n2 = { vertexOffset: t2.length, primitiveOffset: i2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== r2 && (n2.sortKey = r2), this.segments.push(n2)), n2;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const e2 of this.segments)
            for (const t2 in e2.vaos)
              e2.vaos[t2].destroy();
        }
        static simpleSegment(e2, t2, i2, r2) {
          return new SegmentVector([{ vertexOffset: e2, primitiveOffset: t2, vertexLength: i2, primitiveLength: r2, vaos: {}, sortKey: 0 }]);
        }
      }
      SegmentVector.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, kn(SegmentVector, "SegmentVector");
      var ko = 8192;
      class LngLatBounds {
        constructor(e2, t2) {
          e2 && (t2 ? this.setSouthWest(e2).setNorthEast(t2) : 4 === e2.length ? this.setSouthWest([e2[0], e2[1]]).setNorthEast([e2[2], e2[3]]) : this.setSouthWest(e2[0]).setNorthEast(e2[1]));
        }
        setNorthEast(e2) {
          return this._ne = e2 instanceof LngLat ? new LngLat(e2.lng, e2.lat) : LngLat.convert(e2), this;
        }
        setSouthWest(e2) {
          return this._sw = e2 instanceof LngLat ? new LngLat(e2.lng, e2.lat) : LngLat.convert(e2), this;
        }
        extend(e2) {
          const t2 = this._sw, i2 = this._ne;
          let r2, n2;
          if (e2 instanceof LngLat)
            r2 = e2, n2 = e2;
          else {
            if (!(e2 instanceof LngLatBounds))
              return Array.isArray(e2) ? 4 === e2.length || e2.every(Array.isArray) ? this.extend(LngLatBounds.convert(e2)) : this.extend(LngLat.convert(e2)) : "object" == typeof e2 && null !== e2 && e2.hasOwnProperty("lat") && e2.hasOwnProperty("lon") ? this.extend(LngLat.convert(e2)) : this;
            if (r2 = e2._sw, n2 = e2._ne, !r2 || !n2)
              return this;
          }
          return t2 || i2 ? (t2.lng = Math.min(r2.lng, t2.lng), t2.lat = Math.min(r2.lat, t2.lat), i2.lng = Math.max(n2.lng, i2.lng), i2.lat = Math.max(n2.lat, i2.lat)) : (this._sw = new LngLat(r2.lng, r2.lat), this._ne = new LngLat(n2.lng, n2.lat)), this;
        }
        getCenter() {
          return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new LngLat(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new LngLat(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(e2) {
          const { lng: t2, lat: i2 } = LngLat.convert(e2);
          let r2 = this._sw.lng <= t2 && t2 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (r2 = this._sw.lng >= t2 && t2 >= this._ne.lng), this._sw.lat <= i2 && i2 <= this._ne.lat && r2;
        }
        static convert(e2) {
          return !e2 || e2 instanceof LngLatBounds ? e2 : new LngLatBounds(e2);
        }
      }
      const Bo = 63710088e-1;
      class LngLat {
        constructor(e2, t2) {
          if (isNaN(e2) || isNaN(t2))
            throw new Error(`Invalid LngLat object: (${e2}, ${t2})`);
          if (this.lng = +e2, this.lat = +t2, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new LngLat(I(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(e2) {
          const t2 = Math.PI / 180, i2 = this.lat * t2, r2 = e2.lat * t2, n2 = Math.sin(i2) * Math.sin(r2) + Math.cos(i2) * Math.cos(r2) * Math.cos((e2.lng - this.lng) * t2);
          return Bo * Math.acos(Math.min(n2, 1));
        }
        toBounds(e2 = 0) {
          const t2 = 360 * e2 / 40075017, i2 = t2 / Math.cos(Math.PI / 180 * this.lat);
          return new LngLatBounds(new LngLat(this.lng - i2, this.lat - t2), new LngLat(this.lng + i2, this.lat + t2));
        }
        static convert(e2) {
          if (e2 instanceof LngLat)
            return e2;
          if (Array.isArray(e2) && (2 === e2.length || 3 === e2.length))
            return new LngLat(Number(e2[0]), Number(e2[1]));
          if (!Array.isArray(e2) && "object" == typeof e2 && null !== e2)
            return new LngLat(Number("lng" in e2 ? e2.lng : e2.lon), Number(e2.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const Ro = 2 * Math.PI * Bo;
      function Fo(e2) {
        return Ro * Math.cos(e2 * Math.PI / 180);
      }
      function Oo(e2) {
        return (180 + e2) / 360;
      }
      function Uo(e2) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e2 * Math.PI / 360))) / 360;
      }
      function Vo(e2, t2) {
        return e2 / Fo(t2);
      }
      function jo(e2) {
        return 360 * e2 - 180;
      }
      function No(e2) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * e2) * Math.PI / 180)) - 90;
      }
      function Go(e2, t2) {
        return e2 * Fo(No(t2));
      }
      const qo = 85.051129;
      function Zo(e2) {
        return 1 / Math.cos(e2 * Math.PI / 180);
      }
      class MercatorCoordinate {
        constructor(e2, t2, i2 = 0) {
          this.x = +e2, this.y = +t2, this.z = +i2;
        }
        static fromLngLat(e2, t2 = 0) {
          const i2 = LngLat.convert(e2);
          return new MercatorCoordinate(Oo(i2.lng), Uo(i2.lat), Vo(t2, i2.lat));
        }
        toLngLat() {
          return new LngLat(jo(this.x), No(this.y));
        }
        toAltitude() {
          return Go(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Ro * Zo(No(this.y));
        }
      }
      function $o(e2, t2, i2, r2, n2, o2, s2, a2, l2) {
        const c2 = (t2 + r2) / 2, u2 = (i2 + n2) / 2, h2 = new d(c2, u2);
        a2(h2), function(e3, t3, i3, r3, n3, o3) {
          const s3 = i3 - n3, a3 = r3 - o3;
          return Math.abs((r3 - t3) * s3 - (i3 - e3) * a3) / Math.hypot(s3, a3);
        }(h2.x, h2.y, o2.x, o2.y, s2.x, s2.y) >= l2 ? ($o(e2, t2, i2, c2, u2, o2, h2, a2, l2), $o(e2, c2, u2, r2, n2, h2, s2, a2, l2)) : e2.push(s2);
      }
      function Wo(e2, t2, i2) {
        let r2 = e2[0], n2 = r2.x, o2 = r2.y;
        t2(r2);
        const s2 = [r2];
        for (let a2 = 1; a2 < e2.length; a2++) {
          const l2 = e2[a2], { x: c2, y: u2 } = l2;
          t2(l2), $o(s2, n2, o2, c2, u2, r2, l2, t2, i2), n2 = c2, o2 = u2, r2 = l2;
        }
        return s2;
      }
      function Ho(e2, t2, i2, r2) {
        if (r2(t2, i2)) {
          const n2 = t2.add(i2)._mult(0.5);
          Ho(e2, t2, n2, r2), Ho(e2, n2, i2, r2);
        } else
          e2.push(i2);
      }
      function Xo(e2, t2) {
        let i2 = e2[0];
        const r2 = [i2];
        for (let n2 = 1; n2 < e2.length; n2++) {
          const o2 = e2[n2];
          Ho(r2, i2, o2, t2), i2 = o2;
        }
        return r2;
      }
      const Ko = Math.pow(2, 14) - 1, Yo = -Ko - 1;
      function Jo(e2, t2) {
        const i2 = Math.round(e2.x * t2), r2 = Math.round(e2.y * t2);
        return e2.x = A(i2, Yo, Ko), e2.y = A(r2, Yo, Ko), (i2 < e2.x || i2 > e2.x + 1 || r2 < e2.y || r2 > e2.y + 1) && Z("Geometry exceeds allowed extent, reduce your vector tile buffer size"), e2;
      }
      function Qo(e2, t2, i2) {
        const r2 = e2.loadGeometry(), n2 = e2.extent, o2 = ko / n2;
        if (t2 && i2 && i2.projection.isReprojectedInTileSpace) {
          const o3 = 1 << t2.z, { scale: s2, x: a2, y: l2, projection: c2 } = i2, u2 = (e3) => {
            const i3 = jo((t2.x + e3.x / n2) / o3), r3 = No((t2.y + e3.y / n2) / o3), u3 = c2.project(i3, r3);
            e3.x = (u3.x * s2 - a2) * n2, e3.y = (u3.y * s2 - l2) * n2;
          };
          for (let t3 = 0; t3 < r2.length; t3++)
            if (1 !== e2.type)
              r2[t3] = Wo(r2[t3], u2, 1);
            else {
              const e3 = [];
              for (const i3 of r2[t3])
                i3.x < 0 || i3.x >= n2 || i3.y < 0 || i3.y >= n2 || (u2(i3), e3.push(i3));
              r2[t3] = e3;
            }
        }
        for (const e3 of r2)
          for (const t3 of e3)
            Jo(t3, o2);
        return r2;
      }
      function es(e2, t2) {
        return { type: e2.type, id: e2.id, properties: e2.properties, geometry: t2 ? Qo(e2) : [] };
      }
      function ts(e2, t2, i2, r2, n2) {
        e2.emplaceBack(2 * t2 + (r2 + 1) / 2, 2 * i2 + (n2 + 1) / 2);
      }
      function is(e2, t2, i2) {
        const r2 = 16384;
        e2.emplaceBack(t2.x, t2.y, t2.z, i2[0] * r2, i2[1] * r2, i2[2] * r2);
      }
      class CircleBucket {
        constructor(e2) {
          this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((e3) => e3.id), this.index = e2.index, this.hasPattern = false, this.projection = e2.projection, this.layoutVertexArray = new StructArrayLayout2i4(), this.indexArray = new StructArrayLayout3ui6(), this.segments = new SegmentVector(), this.programConfigurations = new ProgramConfigurationSet(e2.layers, e2.zoom), this.stateDependentLayerIds = this.layers.filter((e3) => e3.isStateDependent()).map((e3) => e3.id);
        }
        populate(e2, t2, i2, r2) {
          const n2 = this.layers[0], o2 = [];
          let s2 = null;
          "circle" === n2.type && (s2 = n2.layout.get("circle-sort-key"));
          for (const { feature: t3, id: n3, index: a3, sourceLayerIndex: l2 } of e2) {
            const e3 = this.layers[0]._featureFilter.needGeometry, c2 = es(t3, e3);
            if (!this.layers[0]._featureFilter.filter(new EvaluationParameters(this.zoom), c2, i2))
              continue;
            const u2 = s2 ? s2.evaluate(c2, {}, i2) : void 0, h2 = { id: n3, properties: t3.properties, type: t3.type, sourceLayerIndex: l2, index: a3, geometry: e3 ? c2.geometry : Qo(t3, i2, r2), patterns: {}, sortKey: u2 };
            o2.push(h2);
          }
          s2 && o2.sort((e3, t3) => e3.sortKey - t3.sortKey);
          let a2 = null;
          "globe" === r2.projection.name && (this.globeExtVertexArray = new StructArrayLayout6i12(), a2 = r2.projection);
          for (const r3 of o2) {
            const { geometry: n3, index: o3, sourceLayerIndex: s3 } = r3, l2 = e2[o3].feature;
            this.addFeature(r3, n3, o3, t2.availableImages, i2, a2), t2.featureIndex.insert(l2, n3, o3, s3, this.index);
          }
        }
        update(e2, t2, i2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e2, t2, this.stateDependentLayers, i2, r2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e2) {
          this.uploaded || (this.layoutVertexBuffer = e2.createVertexBuffer(this.layoutVertexArray, zo.members), this.indexBuffer = e2.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = e2.createVertexBuffer(this.globeExtVertexArray, Lo.members))), this.programConfigurations.upload(e2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
        addFeature(e2, t2, i2, r2, n2, o2) {
          for (const i3 of t2)
            for (const t3 of i3) {
              const i4 = t3.x, r3 = t3.y;
              if (i4 < 0 || i4 >= ko || r3 < 0 || r3 >= ko)
                continue;
              if (o2) {
                const e3 = o2.projectTilePoint(i4, r3, n2), t4 = o2.upVector(n2, i4, r3), s3 = this.globeExtVertexArray;
                is(s3, e3, t4), is(s3, e3, t4), is(s3, e3, t4), is(s3, e3, t4);
              }
              const s2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e2.sortKey), a2 = s2.vertexLength;
              ts(this.layoutVertexArray, i4, r3, -1, -1), ts(this.layoutVertexArray, i4, r3, 1, -1), ts(this.layoutVertexArray, i4, r3, 1, 1), ts(this.layoutVertexArray, i4, r3, -1, 1), this.indexArray.emplaceBack(a2, a2 + 1, a2 + 2), this.indexArray.emplaceBack(a2, a2 + 2, a2 + 3), s2.vertexLength += 4, s2.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e2, i2, {}, r2, n2);
        }
      }
      function rs(e2, t2) {
        for (let i2 = 0; i2 < e2.length; i2++)
          if (ps(t2, e2[i2]))
            return true;
        for (let i2 = 0; i2 < t2.length; i2++)
          if (ps(e2, t2[i2]))
            return true;
        return !!as(e2, t2);
      }
      function ns(e2, t2, i2) {
        return !!ps(e2, t2) || !!cs(t2, e2, i2);
      }
      function os(e2, t2) {
        if (1 === e2.length)
          return hs(t2, e2[0]);
        for (let i2 = 0; i2 < t2.length; i2++) {
          const r2 = t2[i2];
          for (let t3 = 0; t3 < r2.length; t3++)
            if (ps(e2, r2[t3]))
              return true;
        }
        for (let i2 = 0; i2 < e2.length; i2++)
          if (hs(t2, e2[i2]))
            return true;
        for (let i2 = 0; i2 < t2.length; i2++)
          if (as(e2, t2[i2]))
            return true;
        return false;
      }
      function ss(e2, t2, i2) {
        if (e2.length > 1) {
          if (as(e2, t2))
            return true;
          for (let r2 = 0; r2 < t2.length; r2++)
            if (cs(t2[r2], e2, i2))
              return true;
        }
        for (let r2 = 0; r2 < e2.length; r2++)
          if (cs(e2[r2], t2, i2))
            return true;
        return false;
      }
      function as(e2, t2) {
        if (0 === e2.length || 0 === t2.length)
          return false;
        for (let i2 = 0; i2 < e2.length - 1; i2++) {
          const r2 = e2[i2], n2 = e2[i2 + 1];
          for (let e3 = 0; e3 < t2.length - 1; e3++)
            if (ls(r2, n2, t2[e3], t2[e3 + 1]))
              return true;
        }
        return false;
      }
      function ls(e2, t2, i2, r2) {
        return $(e2, i2, r2) !== $(t2, i2, r2) && $(e2, t2, i2) !== $(e2, t2, r2);
      }
      function cs(e2, t2, i2) {
        const r2 = i2 * i2;
        if (1 === t2.length)
          return e2.distSqr(t2[0]) < r2;
        for (let i3 = 1; i3 < t2.length; i3++)
          if (us(e2, t2[i3 - 1], t2[i3]) < r2)
            return true;
        return false;
      }
      function us(e2, t2, i2) {
        const r2 = t2.distSqr(i2);
        if (0 === r2)
          return e2.distSqr(t2);
        const n2 = ((e2.x - t2.x) * (i2.x - t2.x) + (e2.y - t2.y) * (i2.y - t2.y)) / r2;
        return e2.distSqr(n2 < 0 ? t2 : n2 > 1 ? i2 : i2.sub(t2)._mult(n2)._add(t2));
      }
      function hs(e2, t2) {
        let i2, r2, n2, o2 = false;
        for (let s2 = 0; s2 < e2.length; s2++) {
          i2 = e2[s2];
          for (let e3 = 0, s3 = i2.length - 1; e3 < i2.length; s3 = e3++)
            r2 = i2[e3], n2 = i2[s3], r2.y > t2.y != n2.y > t2.y && t2.x < (n2.x - r2.x) * (t2.y - r2.y) / (n2.y - r2.y) + r2.x && (o2 = !o2);
        }
        return o2;
      }
      function ps(e2, t2) {
        let i2 = false;
        for (let r2 = 0, n2 = e2.length - 1; r2 < e2.length; n2 = r2++) {
          const o2 = e2[r2], s2 = e2[n2];
          o2.y > t2.y != s2.y > t2.y && t2.x < (s2.x - o2.x) * (t2.y - o2.y) / (s2.y - o2.y) + o2.x && (i2 = !i2);
        }
        return i2;
      }
      function ds(e2, t2, i2, r2, n2) {
        for (const o3 of e2)
          if (t2 <= o3.x && i2 <= o3.y && r2 >= o3.x && n2 >= o3.y)
            return true;
        const o2 = [new d(t2, i2), new d(t2, n2), new d(r2, n2), new d(r2, i2)];
        if (e2.length > 2) {
          for (const t3 of o2)
            if (ps(e2, t3))
              return true;
        }
        for (let t3 = 0; t3 < e2.length - 1; t3++)
          if (fs(e2[t3], e2[t3 + 1], o2))
            return true;
        return false;
      }
      function fs(e2, t2, i2) {
        const r2 = i2[0], n2 = i2[2];
        if (e2.x < r2.x && t2.x < r2.x || e2.x > n2.x && t2.x > n2.x || e2.y < r2.y && t2.y < r2.y || e2.y > n2.y && t2.y > n2.y)
          return false;
        const o2 = $(e2, t2, i2[0]);
        return o2 !== $(e2, t2, i2[1]) || o2 !== $(e2, t2, i2[2]) || o2 !== $(e2, t2, i2[3]);
      }
      function ms(e2, t2, i2) {
        const r2 = t2.paint.get(e2).value;
        return "constant" === r2.kind ? r2.value : i2.programConfigurations.get(t2.id).getMaxValue(e2);
      }
      function _s(e2) {
        return Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]);
      }
      function gs(e2, t2, i2, r2, n2) {
        if (!t2[0] && !t2[1])
          return e2;
        const o2 = d.convert(t2)._mult(n2);
        "viewport" === i2 && o2._rotate(-r2);
        const s2 = [];
        for (let t3 = 0; t3 < e2.length; t3++)
          s2.push(e2[t3].sub(o2));
        return s2;
      }
      function ys(e2, t2, i2, r2) {
        const n2 = d.convert(e2)._mult(r2);
        return "viewport" === t2 && n2._rotate(-i2), n2;
      }
      kn(CircleBucket, "CircleBucket", { omit: ["layers"] });
      const xs = new Properties({ "circle-sort-key": new DataDrivenProperty(ft.layout_circle["circle-sort-key"]) });
      var vs = { paint: new Properties({ "circle-radius": new DataDrivenProperty(ft.paint_circle["circle-radius"]), "circle-color": new DataDrivenProperty(ft.paint_circle["circle-color"]), "circle-blur": new DataDrivenProperty(ft.paint_circle["circle-blur"]), "circle-opacity": new DataDrivenProperty(ft.paint_circle["circle-opacity"]), "circle-translate": new DataConstantProperty(ft.paint_circle["circle-translate"]), "circle-translate-anchor": new DataConstantProperty(ft.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new DataConstantProperty(ft.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new DataConstantProperty(ft.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new DataDrivenProperty(ft.paint_circle["circle-stroke-width"]), "circle-stroke-color": new DataDrivenProperty(ft.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new DataDrivenProperty(ft.paint_circle["circle-stroke-opacity"]) }), layout: xs }, bs = 1e-6, ws = "undefined" != typeof Float32Array ? Float32Array : Array;
      function Ts(e2, t2) {
        var i2 = t2[0], r2 = t2[1], n2 = t2[2], o2 = t2[3], s2 = i2 * o2 - n2 * r2;
        return s2 ? (e2[0] = o2 * (s2 = 1 / s2), e2[1] = -r2 * s2, e2[2] = -n2 * s2, e2[3] = i2 * s2, e2) : null;
      }
      function Es() {
        var e2 = new ws(9);
        return ws != Float32Array && (e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[5] = 0, e2[6] = 0, e2[7] = 0), e2[0] = 1, e2[4] = 1, e2[8] = 1, e2;
      }
      function Ss(e2, t2) {
        var i2 = t2[0], r2 = t2[1], n2 = t2[2], o2 = t2[3], s2 = t2[4], a2 = t2[5], l2 = t2[6], c2 = t2[7], u2 = t2[8];
        return e2[0] = s2 * u2 - a2 * c2, e2[1] = n2 * c2 - r2 * u2, e2[2] = r2 * a2 - n2 * s2, e2[3] = a2 * l2 - o2 * u2, e2[4] = i2 * u2 - n2 * l2, e2[5] = n2 * o2 - i2 * a2, e2[6] = o2 * c2 - s2 * l2, e2[7] = r2 * l2 - i2 * c2, e2[8] = i2 * s2 - r2 * o2, e2;
      }
      function As(e2, t2, i2) {
        var r2 = t2[0], n2 = t2[1], o2 = t2[2], s2 = t2[3], a2 = t2[4], l2 = t2[5], c2 = t2[6], u2 = t2[7], h2 = t2[8], p2 = i2[0], d2 = i2[1], f2 = i2[2], m2 = i2[3], _2 = i2[4], g2 = i2[5], y2 = i2[6], x2 = i2[7], v2 = i2[8];
        return e2[0] = p2 * r2 + d2 * s2 + f2 * c2, e2[1] = p2 * n2 + d2 * a2 + f2 * u2, e2[2] = p2 * o2 + d2 * l2 + f2 * h2, e2[3] = m2 * r2 + _2 * s2 + g2 * c2, e2[4] = m2 * n2 + _2 * a2 + g2 * u2, e2[5] = m2 * o2 + _2 * l2 + g2 * h2, e2[6] = y2 * r2 + x2 * s2 + v2 * c2, e2[7] = y2 * n2 + x2 * a2 + v2 * u2, e2[8] = y2 * o2 + x2 * l2 + v2 * h2, e2;
      }
      function Cs() {
        var e2 = new ws(16);
        return ws != Float32Array && (e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 0, e2[6] = 0, e2[7] = 0, e2[8] = 0, e2[9] = 0, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0), e2[0] = 1, e2[5] = 1, e2[10] = 1, e2[15] = 1, e2;
      }
      function Is(e2) {
        return e2[0] = 1, e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 0, e2[5] = 1, e2[6] = 0, e2[7] = 0, e2[8] = 0, e2[9] = 0, e2[10] = 1, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, e2;
      }
      function Ms(e2, t2) {
        var i2 = t2[0], r2 = t2[1], n2 = t2[2], o2 = t2[3], s2 = t2[4], a2 = t2[5], l2 = t2[6], c2 = t2[7], u2 = t2[8], h2 = t2[9], p2 = t2[10], d2 = t2[11], f2 = t2[12], m2 = t2[13], _2 = t2[14], g2 = t2[15], y2 = i2 * a2 - r2 * s2, x2 = i2 * l2 - n2 * s2, v2 = i2 * c2 - o2 * s2, b2 = r2 * l2 - n2 * a2, w2 = r2 * c2 - o2 * a2, T2 = n2 * c2 - o2 * l2, E2 = u2 * m2 - h2 * f2, S2 = u2 * _2 - p2 * f2, A2 = u2 * g2 - d2 * f2, C2 = h2 * _2 - p2 * m2, I2 = h2 * g2 - d2 * m2, M2 = p2 * g2 - d2 * _2, D2 = y2 * M2 - x2 * I2 + v2 * C2 + b2 * A2 - w2 * S2 + T2 * E2;
        return D2 ? (e2[0] = (a2 * M2 - l2 * I2 + c2 * C2) * (D2 = 1 / D2), e2[1] = (n2 * I2 - r2 * M2 - o2 * C2) * D2, e2[2] = (m2 * T2 - _2 * w2 + g2 * b2) * D2, e2[3] = (p2 * w2 - h2 * T2 - d2 * b2) * D2, e2[4] = (l2 * A2 - s2 * M2 - c2 * S2) * D2, e2[5] = (i2 * M2 - n2 * A2 + o2 * S2) * D2, e2[6] = (_2 * v2 - f2 * T2 - g2 * x2) * D2, e2[7] = (u2 * T2 - p2 * v2 + d2 * x2) * D2, e2[8] = (s2 * I2 - a2 * A2 + c2 * E2) * D2, e2[9] = (r2 * A2 - i2 * I2 - o2 * E2) * D2, e2[10] = (f2 * w2 - m2 * v2 + g2 * y2) * D2, e2[11] = (h2 * v2 - u2 * w2 - d2 * y2) * D2, e2[12] = (a2 * S2 - s2 * C2 - l2 * E2) * D2, e2[13] = (i2 * C2 - r2 * S2 + n2 * E2) * D2, e2[14] = (m2 * x2 - f2 * b2 - _2 * y2) * D2, e2[15] = (u2 * b2 - h2 * x2 + p2 * y2) * D2, e2) : null;
      }
      function Ds(e2, t2, i2) {
        var r2 = t2[0], n2 = t2[1], o2 = t2[2], s2 = t2[3], a2 = t2[4], l2 = t2[5], c2 = t2[6], u2 = t2[7], h2 = t2[8], p2 = t2[9], d2 = t2[10], f2 = t2[11], m2 = t2[12], _2 = t2[13], g2 = t2[14], y2 = t2[15], x2 = i2[0], v2 = i2[1], b2 = i2[2], w2 = i2[3];
        return e2[0] = x2 * r2 + v2 * a2 + b2 * h2 + w2 * m2, e2[1] = x2 * n2 + v2 * l2 + b2 * p2 + w2 * _2, e2[2] = x2 * o2 + v2 * c2 + b2 * d2 + w2 * g2, e2[3] = x2 * s2 + v2 * u2 + b2 * f2 + w2 * y2, e2[4] = (x2 = i2[4]) * r2 + (v2 = i2[5]) * a2 + (b2 = i2[6]) * h2 + (w2 = i2[7]) * m2, e2[5] = x2 * n2 + v2 * l2 + b2 * p2 + w2 * _2, e2[6] = x2 * o2 + v2 * c2 + b2 * d2 + w2 * g2, e2[7] = x2 * s2 + v2 * u2 + b2 * f2 + w2 * y2, e2[8] = (x2 = i2[8]) * r2 + (v2 = i2[9]) * a2 + (b2 = i2[10]) * h2 + (w2 = i2[11]) * m2, e2[9] = x2 * n2 + v2 * l2 + b2 * p2 + w2 * _2, e2[10] = x2 * o2 + v2 * c2 + b2 * d2 + w2 * g2, e2[11] = x2 * s2 + v2 * u2 + b2 * f2 + w2 * y2, e2[12] = (x2 = i2[12]) * r2 + (v2 = i2[13]) * a2 + (b2 = i2[14]) * h2 + (w2 = i2[15]) * m2, e2[13] = x2 * n2 + v2 * l2 + b2 * p2 + w2 * _2, e2[14] = x2 * o2 + v2 * c2 + b2 * d2 + w2 * g2, e2[15] = x2 * s2 + v2 * u2 + b2 * f2 + w2 * y2, e2;
      }
      function Ps(e2, t2, i2) {
        var r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2, m2 = i2[0], _2 = i2[1], g2 = i2[2];
        return t2 === e2 ? (e2[12] = t2[0] * m2 + t2[4] * _2 + t2[8] * g2 + t2[12], e2[13] = t2[1] * m2 + t2[5] * _2 + t2[9] * g2 + t2[13], e2[14] = t2[2] * m2 + t2[6] * _2 + t2[10] * g2 + t2[14], e2[15] = t2[3] * m2 + t2[7] * _2 + t2[11] * g2 + t2[15]) : (n2 = t2[1], o2 = t2[2], s2 = t2[3], a2 = t2[4], l2 = t2[5], c2 = t2[6], u2 = t2[7], h2 = t2[8], p2 = t2[9], d2 = t2[10], f2 = t2[11], e2[0] = r2 = t2[0], e2[1] = n2, e2[2] = o2, e2[3] = s2, e2[4] = a2, e2[5] = l2, e2[6] = c2, e2[7] = u2, e2[8] = h2, e2[9] = p2, e2[10] = d2, e2[11] = f2, e2[12] = r2 * m2 + a2 * _2 + h2 * g2 + t2[12], e2[13] = n2 * m2 + l2 * _2 + p2 * g2 + t2[13], e2[14] = o2 * m2 + c2 * _2 + d2 * g2 + t2[14], e2[15] = s2 * m2 + u2 * _2 + f2 * g2 + t2[15]), e2;
      }
      function zs(e2, t2, i2) {
        var r2 = i2[0], n2 = i2[1], o2 = i2[2];
        return e2[0] = t2[0] * r2, e2[1] = t2[1] * r2, e2[2] = t2[2] * r2, e2[3] = t2[3] * r2, e2[4] = t2[4] * n2, e2[5] = t2[5] * n2, e2[6] = t2[6] * n2, e2[7] = t2[7] * n2, e2[8] = t2[8] * o2, e2[9] = t2[9] * o2, e2[10] = t2[10] * o2, e2[11] = t2[11] * o2, e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
      }
      function Ls(e2, t2, i2) {
        var r2 = Math.sin(i2), n2 = Math.cos(i2), o2 = t2[4], s2 = t2[5], a2 = t2[6], l2 = t2[7], c2 = t2[8], u2 = t2[9], h2 = t2[10], p2 = t2[11];
        return t2 !== e2 && (e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15]), e2[4] = o2 * n2 + c2 * r2, e2[5] = s2 * n2 + u2 * r2, e2[6] = a2 * n2 + h2 * r2, e2[7] = l2 * n2 + p2 * r2, e2[8] = c2 * n2 - o2 * r2, e2[9] = u2 * n2 - s2 * r2, e2[10] = h2 * n2 - a2 * r2, e2[11] = p2 * n2 - l2 * r2, e2;
      }
      function ks(e2, t2, i2) {
        var r2 = Math.sin(i2), n2 = Math.cos(i2), o2 = t2[0], s2 = t2[1], a2 = t2[2], l2 = t2[3], c2 = t2[8], u2 = t2[9], h2 = t2[10], p2 = t2[11];
        return t2 !== e2 && (e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15]), e2[0] = o2 * n2 - c2 * r2, e2[1] = s2 * n2 - u2 * r2, e2[2] = a2 * n2 - h2 * r2, e2[3] = l2 * n2 - p2 * r2, e2[8] = o2 * r2 + c2 * n2, e2[9] = s2 * r2 + u2 * n2, e2[10] = a2 * r2 + h2 * n2, e2[11] = l2 * r2 + p2 * n2, e2;
      }
      function Bs(e2, t2, i2) {
        var r2 = Math.sin(i2), n2 = Math.cos(i2), o2 = t2[0], s2 = t2[1], a2 = t2[2], l2 = t2[3], c2 = t2[4], u2 = t2[5], h2 = t2[6], p2 = t2[7];
        return t2 !== e2 && (e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15]), e2[0] = o2 * n2 + c2 * r2, e2[1] = s2 * n2 + u2 * r2, e2[2] = a2 * n2 + h2 * r2, e2[3] = l2 * n2 + p2 * r2, e2[4] = c2 * n2 - o2 * r2, e2[5] = u2 * n2 - s2 * r2, e2[6] = h2 * n2 - a2 * r2, e2[7] = p2 * n2 - l2 * r2, e2;
      }
      function Rs(e2, t2) {
        return e2[0] = t2[0], e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 0, e2[5] = t2[1], e2[6] = 0, e2[7] = 0, e2[8] = 0, e2[9] = 0, e2[10] = t2[2], e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, e2;
      }
      function Fs(e2, t2, i2) {
        var r2, n2, o2, s2 = i2[0], a2 = i2[1], l2 = i2[2], c2 = Math.hypot(s2, a2, l2);
        return c2 < bs ? null : (s2 *= c2 = 1 / c2, a2 *= c2, l2 *= c2, r2 = Math.sin(t2), n2 = Math.cos(t2), e2[0] = s2 * s2 * (o2 = 1 - n2) + n2, e2[1] = a2 * s2 * o2 + l2 * r2, e2[2] = l2 * s2 * o2 - a2 * r2, e2[3] = 0, e2[4] = s2 * a2 * o2 - l2 * r2, e2[5] = a2 * a2 * o2 + n2, e2[6] = l2 * a2 * o2 + s2 * r2, e2[7] = 0, e2[8] = s2 * l2 * o2 + a2 * r2, e2[9] = a2 * l2 * o2 - s2 * r2, e2[10] = l2 * l2 * o2 + n2, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, e2);
      }
      function Os(e2, t2) {
        var i2 = t2[0], r2 = t2[1], n2 = t2[2], o2 = t2[3], s2 = i2 + i2, a2 = r2 + r2, l2 = n2 + n2, c2 = i2 * s2, u2 = r2 * s2, h2 = r2 * a2, p2 = n2 * s2, d2 = n2 * a2, f2 = n2 * l2, m2 = o2 * s2, _2 = o2 * a2, g2 = o2 * l2;
        return e2[0] = 1 - h2 - f2, e2[1] = u2 + g2, e2[2] = p2 - _2, e2[3] = 0, e2[4] = u2 - g2, e2[5] = 1 - c2 - f2, e2[6] = d2 + m2, e2[7] = 0, e2[8] = p2 + _2, e2[9] = d2 - m2, e2[10] = 1 - c2 - h2, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, e2;
      }
      Math.hypot || (Math.hypot = function() {
        for (var e2 = 0, t2 = arguments.length; t2--; )
          e2 += arguments[t2] * arguments[t2];
        return Math.sqrt(e2);
      });
      var Us = function(e2, t2, i2, r2, n2) {
        var o2, s2 = 1 / Math.tan(t2 / 2);
        return e2[0] = s2 / i2, e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 0, e2[5] = s2, e2[6] = 0, e2[7] = 0, e2[8] = 0, e2[9] = 0, e2[11] = -1, e2[12] = 0, e2[13] = 0, e2[15] = 0, null != n2 && n2 !== 1 / 0 ? (e2[10] = (n2 + r2) * (o2 = 1 / (r2 - n2)), e2[14] = 2 * n2 * r2 * o2) : (e2[10] = -1, e2[14] = -2 * r2), e2;
      }, Vs = function(e2, t2, i2, r2, n2, o2, s2) {
        var a2 = 1 / (t2 - i2), l2 = 1 / (r2 - n2), c2 = 1 / (o2 - s2);
        return e2[0] = -2 * a2, e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 0, e2[5] = -2 * l2, e2[6] = 0, e2[7] = 0, e2[8] = 0, e2[9] = 0, e2[10] = 2 * c2, e2[11] = 0, e2[12] = (t2 + i2) * a2, e2[13] = (n2 + r2) * l2, e2[14] = (s2 + o2) * c2, e2[15] = 1, e2;
      }, js = Ds;
      function Ns() {
        var e2 = new ws(3);
        return ws != Float32Array && (e2[0] = 0, e2[1] = 0, e2[2] = 0), e2;
      }
      function Gs(e2) {
        var t2 = new ws(3);
        return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2;
      }
      function qs(e2) {
        return Math.hypot(e2[0], e2[1], e2[2]);
      }
      function Zs(e2, t2, i2) {
        var r2 = new ws(3);
        return r2[0] = e2, r2[1] = t2, r2[2] = i2, r2;
      }
      function $s(e2, t2, i2) {
        return e2[0] = t2[0] + i2[0], e2[1] = t2[1] + i2[1], e2[2] = t2[2] + i2[2], e2;
      }
      function Ws(e2, t2, i2) {
        return e2[0] = t2[0] - i2[0], e2[1] = t2[1] - i2[1], e2[2] = t2[2] - i2[2], e2;
      }
      function Hs(e2, t2, i2) {
        return e2[0] = t2[0] * i2[0], e2[1] = t2[1] * i2[1], e2[2] = t2[2] * i2[2], e2;
      }
      function Xs(e2, t2, i2) {
        return e2[0] = Math.min(t2[0], i2[0]), e2[1] = Math.min(t2[1], i2[1]), e2[2] = Math.min(t2[2], i2[2]), e2;
      }
      function Ks(e2, t2, i2) {
        return e2[0] = Math.max(t2[0], i2[0]), e2[1] = Math.max(t2[1], i2[1]), e2[2] = Math.max(t2[2], i2[2]), e2;
      }
      function Ys(e2, t2, i2) {
        return e2[0] = t2[0] * i2, e2[1] = t2[1] * i2, e2[2] = t2[2] * i2, e2;
      }
      function Js(e2, t2, i2, r2) {
        return e2[0] = t2[0] + i2[0] * r2, e2[1] = t2[1] + i2[1] * r2, e2[2] = t2[2] + i2[2] * r2, e2;
      }
      function Qs(e2, t2) {
        return Math.hypot(t2[0] - e2[0], t2[1] - e2[1], t2[2] - e2[2]);
      }
      function ea(e2, t2) {
        var i2 = t2[0], r2 = t2[1], n2 = t2[2], o2 = i2 * i2 + r2 * r2 + n2 * n2;
        return o2 > 0 && (o2 = 1 / Math.sqrt(o2)), e2[0] = t2[0] * o2, e2[1] = t2[1] * o2, e2[2] = t2[2] * o2, e2;
      }
      function ta(e2, t2) {
        return e2[0] * t2[0] + e2[1] * t2[1] + e2[2] * t2[2];
      }
      function ia(e2, t2, i2) {
        var r2 = t2[0], n2 = t2[1], o2 = t2[2], s2 = i2[0], a2 = i2[1], l2 = i2[2];
        return e2[0] = n2 * l2 - o2 * a2, e2[1] = o2 * s2 - r2 * l2, e2[2] = r2 * a2 - n2 * s2, e2;
      }
      function ra(e2, t2, i2) {
        var r2 = t2[0], n2 = t2[1], o2 = t2[2], s2 = i2[3] * r2 + i2[7] * n2 + i2[11] * o2 + i2[15];
        return e2[0] = (i2[0] * r2 + i2[4] * n2 + i2[8] * o2 + i2[12]) / (s2 = s2 || 1), e2[1] = (i2[1] * r2 + i2[5] * n2 + i2[9] * o2 + i2[13]) / s2, e2[2] = (i2[2] * r2 + i2[6] * n2 + i2[10] * o2 + i2[14]) / s2, e2;
      }
      function na(e2, t2, i2) {
        var r2 = t2[0], n2 = t2[1], o2 = t2[2];
        return e2[0] = r2 * i2[0] + n2 * i2[3] + o2 * i2[6], e2[1] = r2 * i2[1] + n2 * i2[4] + o2 * i2[7], e2[2] = r2 * i2[2] + n2 * i2[5] + o2 * i2[8], e2;
      }
      function oa(e2, t2, i2) {
        var r2 = i2[0], n2 = i2[1], o2 = i2[2], s2 = t2[0], a2 = t2[1], l2 = t2[2], c2 = n2 * l2 - o2 * a2, u2 = o2 * s2 - r2 * l2, h2 = r2 * a2 - n2 * s2, p2 = n2 * h2 - o2 * u2, d2 = o2 * c2 - r2 * h2, f2 = r2 * u2 - n2 * c2, m2 = 2 * i2[3];
        return u2 *= m2, h2 *= m2, d2 *= 2, f2 *= 2, e2[0] = s2 + (c2 *= m2) + (p2 *= 2), e2[1] = a2 + u2 + d2, e2[2] = l2 + h2 + f2, e2;
      }
      var sa, aa = Ws, la = Hs, ca = function(e2, t2, i2) {
        return e2[0] = t2[0] / i2[0], e2[1] = t2[1] / i2[1], e2[2] = t2[2] / i2[2], e2;
      }, ua = qs;
      function ha(e2, t2, i2) {
        return e2[0] = t2[0] * i2, e2[1] = t2[1] * i2, e2[2] = t2[2] * i2, e2[3] = t2[3] * i2, e2;
      }
      function pa(e2, t2) {
        var i2 = t2[0], r2 = t2[1], n2 = t2[2], o2 = t2[3], s2 = i2 * i2 + r2 * r2 + n2 * n2 + o2 * o2;
        return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), e2[0] = i2 * s2, e2[1] = r2 * s2, e2[2] = n2 * s2, e2[3] = o2 * s2, e2;
      }
      function da(e2, t2, i2) {
        var r2 = t2[0], n2 = t2[1], o2 = t2[2], s2 = t2[3];
        return e2[0] = i2[0] * r2 + i2[4] * n2 + i2[8] * o2 + i2[12] * s2, e2[1] = i2[1] * r2 + i2[5] * n2 + i2[9] * o2 + i2[13] * s2, e2[2] = i2[2] * r2 + i2[6] * n2 + i2[10] * o2 + i2[14] * s2, e2[3] = i2[3] * r2 + i2[7] * n2 + i2[11] * o2 + i2[15] * s2, e2;
      }
      function fa() {
        var e2 = new ws(4);
        return ws != Float32Array && (e2[0] = 0, e2[1] = 0, e2[2] = 0), e2[3] = 1, e2;
      }
      function ma(e2) {
        return e2[0] = 0, e2[1] = 0, e2[2] = 0, e2[3] = 1, e2;
      }
      function _a(e2, t2, i2) {
        i2 *= 0.5;
        var r2 = t2[0], n2 = t2[1], o2 = t2[2], s2 = t2[3], a2 = Math.sin(i2), l2 = Math.cos(i2);
        return e2[0] = r2 * l2 + s2 * a2, e2[1] = n2 * l2 + o2 * a2, e2[2] = o2 * l2 - n2 * a2, e2[3] = s2 * l2 - r2 * a2, e2;
      }
      function ga(e2, t2, i2) {
        i2 *= 0.5;
        var r2 = t2[0], n2 = t2[1], o2 = t2[2], s2 = t2[3], a2 = Math.sin(i2), l2 = Math.cos(i2);
        return e2[0] = r2 * l2 - o2 * a2, e2[1] = n2 * l2 + s2 * a2, e2[2] = o2 * l2 + r2 * a2, e2[3] = s2 * l2 - n2 * a2, e2;
      }
      function ya(e2, t2, i2) {
        i2 *= 0.5;
        var r2 = t2[0], n2 = t2[1], o2 = t2[2], s2 = t2[3], a2 = Math.sin(i2), l2 = Math.cos(i2);
        return e2[0] = r2 * l2 + n2 * a2, e2[1] = n2 * l2 - r2 * a2, e2[2] = o2 * l2 + s2 * a2, e2[3] = s2 * l2 - o2 * a2, e2;
      }
      Ns(), sa = new ws(4), ws != Float32Array && (sa[0] = 0, sa[1] = 0, sa[2] = 0, sa[3] = 0);
      var xa = pa;
      Ns(), Zs(1, 0, 0), Zs(0, 1, 0), fa(), fa(), Es();
      class Ray {
        constructor(e2, t2) {
          this.pos = e2, this.dir = t2;
        }
        intersectsPlane(e2, t2, i2) {
          const r2 = ta(t2, this.dir);
          if (Math.abs(r2) < 1e-6)
            return false;
          const n2 = ((e2[0] - this.pos[0]) * t2[0] + (e2[1] - this.pos[1]) * t2[1] + (e2[2] - this.pos[2]) * t2[2]) / r2;
          return i2[0] = this.pos[0] + this.dir[0] * n2, i2[1] = this.pos[1] + this.dir[1] * n2, i2[2] = this.pos[2] + this.dir[2] * n2, true;
        }
        closestPointOnSphere(e2, t2, i2) {
          if (function(e3, t3) {
            var i3 = e3[0], r3 = e3[1], n3 = e3[2], o3 = t3[0], s3 = t3[1], a3 = t3[2];
            return Math.abs(i3 - o3) <= bs * Math.max(1, Math.abs(i3), Math.abs(o3)) && Math.abs(r3 - s3) <= bs * Math.max(1, Math.abs(r3), Math.abs(s3)) && Math.abs(n3 - a3) <= bs * Math.max(1, Math.abs(n3), Math.abs(a3));
          }(this.pos, e2) || 0 === t2)
            return i2[0] = i2[1] = i2[2] = 0, false;
          const [r2, n2, o2] = this.dir, s2 = this.pos[0] - e2[0], a2 = this.pos[1] - e2[1], l2 = this.pos[2] - e2[2], c2 = r2 * r2 + n2 * n2 + o2 * o2, u2 = 2 * (s2 * r2 + a2 * n2 + l2 * o2), h2 = u2 * u2 - 4 * c2 * (s2 * s2 + a2 * a2 + l2 * l2 - t2 * t2);
          if (h2 < 0) {
            const e3 = Math.max(-u2 / 2, 0), c3 = s2 + r2 * e3, h3 = a2 + n2 * e3, p2 = l2 + o2 * e3, d2 = Math.hypot(c3, h3, p2);
            return i2[0] = c3 * t2 / d2, i2[1] = h3 * t2 / d2, i2[2] = p2 * t2 / d2, false;
          }
          {
            const e3 = (-u2 - Math.sqrt(h2)) / (2 * c2);
            if (e3 < 0) {
              const e4 = Math.hypot(s2, a2, l2);
              return i2[0] = s2 * t2 / e4, i2[1] = a2 * t2 / e4, i2[2] = l2 * t2 / e4, false;
            }
            return i2[0] = s2 + r2 * e3, i2[1] = a2 + n2 * e3, i2[2] = l2 + o2 * e3, true;
          }
        }
      }
      class FrustumCorners {
        constructor(e2, t2, i2, r2, n2) {
          this.TL = e2, this.TR = t2, this.BR = i2, this.BL = r2, this.horizon = n2;
        }
        static fromInvProjectionMatrix(e2, t2, i2) {
          const r2 = [-1, 1, 1], n2 = [1, 1, 1], o2 = [1, -1, 1], s2 = [-1, -1, 1], a2 = ra(r2, r2, e2), l2 = ra(n2, n2, e2), c2 = ra(o2, o2, e2), u2 = ra(s2, s2, e2);
          return new FrustumCorners(a2, l2, c2, u2, t2 / i2);
        }
      }
      class Frustum {
        constructor(e2, t2) {
          this.points = e2, this.planes = t2;
        }
        static fromInvProjectionMatrix(e2, t2, i2, r2) {
          const n2 = Math.pow(2, i2), o2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((i3) => {
            const o3 = da([], i3, e2), s3 = 1 / o3[3] / t2 * n2;
            return function(e3, t3, i4) {
              return e3[0] = t3[0] * i4[0], e3[1] = t3[1] * i4[1], e3[2] = t3[2] * i4[2], e3[3] = t3[3] * i4[3], e3;
            }(o3, o3, [s3, s3, r2 ? 1 / o3[3] : s3, s3]);
          }), s2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e3) => {
            const t3 = ea([], ia([], aa([], o2[e3[0]], o2[e3[1]]), aa([], o2[e3[2]], o2[e3[1]]))), i3 = -ta(t3, o2[e3[1]]);
            return t3.concat(i3);
          });
          return new Frustum(o2, s2);
        }
      }
      class Aabb {
        static fromPoints(e2) {
          const t2 = [1 / 0, 1 / 0, 1 / 0], i2 = [-1 / 0, -1 / 0, -1 / 0];
          for (const r2 of e2)
            Xs(t2, t2, r2), Ks(i2, i2, r2);
          return new Aabb(t2, i2);
        }
        static applyTransform(e2, t2) {
          const i2 = e2.getCorners();
          for (let e3 = 0; e3 < i2.length; ++e3)
            ra(i2[e3], i2[e3], t2);
          return Aabb.fromPoints(i2);
        }
        constructor(e2, t2) {
          this.min = e2, this.max = t2, this.center = Ys([], $s([], this.min, this.max), 0.5);
        }
        quadrant(e2) {
          const t2 = [e2 % 2 == 0, e2 < 2], i2 = Gs(this.min), r2 = Gs(this.max);
          for (let e3 = 0; e3 < t2.length; e3++)
            i2[e3] = t2[e3] ? this.min[e3] : this.center[e3], r2[e3] = t2[e3] ? this.center[e3] : this.max[e3];
          return r2[2] = this.max[2], new Aabb(i2, r2);
        }
        distanceX(e2) {
          return Math.max(Math.min(this.max[0], e2[0]), this.min[0]) - e2[0];
        }
        distanceY(e2) {
          return Math.max(Math.min(this.max[1], e2[1]), this.min[1]) - e2[1];
        }
        distanceZ(e2) {
          return Math.max(Math.min(this.max[2], e2[2]), this.min[2]) - e2[2];
        }
        getCorners() {
          const e2 = this.min, t2 = this.max;
          return [[e2[0], e2[1], e2[2]], [t2[0], e2[1], e2[2]], [t2[0], t2[1], e2[2]], [e2[0], t2[1], e2[2]], [e2[0], e2[1], t2[2]], [t2[0], e2[1], t2[2]], [t2[0], t2[1], t2[2]], [e2[0], t2[1], t2[2]]];
        }
        intersects(e2) {
          const t2 = this.getCorners();
          let i2 = true;
          for (let r2 = 0; r2 < e2.planes.length; r2++) {
            const n2 = e2.planes[r2];
            let o2 = 0;
            for (let e3 = 0; e3 < t2.length; e3++)
              o2 += ta(n2, t2[e3]) + n2[3] >= 0;
            if (0 === o2)
              return 0;
            o2 !== t2.length && (i2 = false);
          }
          if (i2)
            return 2;
          for (let t3 = 0; t3 < 3; t3++) {
            let i3 = Number.MAX_VALUE, r2 = -Number.MAX_VALUE;
            for (let n2 = 0; n2 < e2.points.length; n2++) {
              const o2 = e2.points[n2][t3] - this.min[t3];
              i3 = Math.min(i3, o2), r2 = Math.max(r2, o2);
            }
            if (r2 < 0 || i3 > this.max[t3] - this.min[t3])
              return 0;
          }
          return 1;
        }
      }
      function va(e2, t2, i2, r2, n2, o2, s2, a2, l2) {
        if (o2 && e2.queryGeometry.isAboveHorizon)
          return false;
        o2 && (l2 *= e2.pixelToTileUnitsFactor);
        const c2 = e2.tileID.canonical, u2 = i2.projection.upVectorScale(c2, i2.center.lat, i2.worldSize).metersToTile;
        for (const h2 of t2)
          for (const t3 of h2) {
            const h3 = t3.add(a2), p2 = n2 && i2.elevation ? i2.elevation.exaggeration() * n2.getElevationAt(h3.x, h3.y, true) : 0, d2 = i2.projection.projectTilePoint(h3.x, h3.y, c2);
            if (p2 > 0) {
              const e3 = i2.projection.upVector(c2, h3.x, h3.y);
              d2.x += e3[0] * u2 * p2, d2.y += e3[1] * u2 * p2, d2.z += e3[2] * u2 * p2;
            }
            const f2 = o2 ? h3 : ba(d2.x, d2.y, d2.z, r2), m2 = o2 ? e2.tilespaceRays.map((e3) => Ea(e3, p2)) : e2.queryGeometry.screenGeometry, _2 = da([], [d2.x, d2.y, d2.z, 1], r2);
            if (!s2 && o2 ? l2 *= _2[3] / i2.cameraToCenterDistance : s2 && !o2 && (l2 *= i2.cameraToCenterDistance / _2[3]), o2) {
              const e3 = No((t3.y / ko + c2.y) / (1 << c2.z));
              l2 /= i2.projection.pixelsPerMeter(e3, 1) / Vo(1, e3);
            }
            if (ns(m2, f2, l2))
              return true;
          }
        return false;
      }
      function ba(e2, t2, i2, r2) {
        const n2 = da([], [e2, t2, i2, 1], r2);
        return new d(n2[0] / n2[3], n2[1] / n2[3]);
      }
      const wa = Zs(0, 0, 0), Ta = Zs(0, 0, 1);
      function Ea(e2, t2) {
        const i2 = Ns();
        return wa[2] = t2, e2.intersectsPlane(wa, Ta, i2), new d(i2[0], i2[1]);
      }
      class HeatmapBucket extends CircleBucket {
      }
      function Sa(e2, { width: t2, height: i2 }, r2, n2) {
        if (n2) {
          if (n2 instanceof Uint8ClampedArray)
            n2 = new Uint8Array(n2.buffer);
          else if (n2.length !== t2 * i2 * r2)
            throw new RangeError("mismatched image size");
        } else
          n2 = new Uint8Array(t2 * i2 * r2);
        return e2.width = t2, e2.height = i2, e2.data = n2, e2;
      }
      function Aa(e2, t2, i2) {
        const { width: r2, height: n2 } = t2;
        r2 === e2.width && n2 === e2.height || (Ca(e2, t2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(e2.width, r2), height: Math.min(e2.height, n2) }, i2), e2.width = r2, e2.height = n2, e2.data = t2.data);
      }
      function Ca(e2, t2, i2, r2, n2, o2) {
        if (0 === n2.width || 0 === n2.height)
          return t2;
        if (n2.width > e2.width || n2.height > e2.height || i2.x > e2.width - n2.width || i2.y > e2.height - n2.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (n2.width > t2.width || n2.height > t2.height || r2.x > t2.width - n2.width || r2.y > t2.height - n2.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const s2 = e2.data, a2 = t2.data;
        for (let l2 = 0; l2 < n2.height; l2++) {
          const c2 = ((i2.y + l2) * e2.width + i2.x) * o2, u2 = ((r2.y + l2) * t2.width + r2.x) * o2;
          for (let e3 = 0; e3 < n2.width * o2; e3++)
            a2[u2 + e3] = s2[c2 + e3];
        }
        return t2;
      }
      kn(HeatmapBucket, "HeatmapBucket", { omit: ["layers"] });
      class AlphaImage {
        constructor(e2, t2) {
          Sa(this, e2, 1, t2);
        }
        resize(e2) {
          Aa(this, new AlphaImage(e2), 1);
        }
        clone() {
          return new AlphaImage({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e2, t2, i2, r2, n2) {
          Ca(e2, t2, i2, r2, n2, 1);
        }
      }
      class RGBAImage {
        constructor(e2, t2) {
          Sa(this, e2, 4, t2);
        }
        resize(e2) {
          Aa(this, new RGBAImage(e2), 4);
        }
        replace(e2, t2) {
          t2 ? this.data.set(e2) : this.data = e2 instanceof Uint8ClampedArray ? new Uint8Array(e2.buffer) : e2;
        }
        clone() {
          return new RGBAImage({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e2, t2, i2, r2, n2) {
          Ca(e2, t2, i2, r2, n2, 4);
        }
      }
      kn(AlphaImage, "AlphaImage"), kn(RGBAImage, "RGBAImage");
      var Ia = { paint: new Properties({ "heatmap-radius": new DataDrivenProperty(ft.paint_heatmap["heatmap-radius"]), "heatmap-weight": new DataDrivenProperty(ft.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new DataConstantProperty(ft.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ColorRampProperty(ft.paint_heatmap["heatmap-color"]), "heatmap-opacity": new DataConstantProperty(ft.paint_heatmap["heatmap-opacity"]) }) };
      function Ma(e2) {
        const t2 = {}, i2 = e2.resolution || 256, r2 = e2.clips ? e2.clips.length : 1, n2 = e2.image || new RGBAImage({ width: i2, height: r2 }), o2 = (i3, r3, o3) => {
          t2[e2.evaluationKey] = o3;
          const s2 = e2.expression.evaluate(t2);
          n2.data[i3 + r3 + 0] = Math.floor(255 * s2.r / s2.a), n2.data[i3 + r3 + 1] = Math.floor(255 * s2.g / s2.a), n2.data[i3 + r3 + 2] = Math.floor(255 * s2.b / s2.a), n2.data[i3 + r3 + 3] = Math.floor(255 * s2.a);
        };
        if (e2.clips)
          for (let t3 = 0, n3 = 0; t3 < r2; ++t3, n3 += 4 * i2)
            for (let r3 = 0, s2 = 0; r3 < i2; r3++, s2 += 4) {
              const a2 = r3 / (i2 - 1), { start: l2, end: c2 } = e2.clips[t3];
              o2(n3, s2, l2 * (1 - a2) + c2 * a2);
            }
        else
          for (let e3 = 0, t3 = 0; e3 < i2; e3++, t3 += 4)
            o2(0, t3, e3 / (i2 - 1));
        return n2;
      }
      var Da = { paint: new Properties({ "hillshade-illumination-direction": new DataConstantProperty(ft.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new DataConstantProperty(ft.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new DataConstantProperty(ft.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new DataConstantProperty(ft.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new DataConstantProperty(ft.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new DataConstantProperty(ft.paint_hillshade["hillshade-accent-color"]) }) };
      const Pa = co([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: za } = Pa;
      var La = { exports: {} };
      function ka(e2, t2, i2) {
        i2 = i2 || 2;
        var r2, n2, o2, s2, a2, l2, c2, u2 = t2 && t2.length, h2 = u2 ? t2[0] * i2 : e2.length, p2 = Ba(e2, 0, h2, i2, true), d2 = [];
        if (!p2 || p2.next === p2.prev)
          return d2;
        if (u2 && (p2 = function(e3, t3, i3, r3) {
          var n3, o3, s3, a3 = [];
          for (n3 = 0, o3 = t3.length; n3 < o3; n3++)
            (s3 = Ba(e3, t3[n3] * r3, n3 < o3 - 1 ? t3[n3 + 1] * r3 : e3.length, r3, false)) === s3.next && (s3.steiner = true), a3.push($a(s3));
          for (a3.sort(Na), n3 = 0; n3 < a3.length; n3++)
            i3 = Ga(a3[n3], i3);
          return i3;
        }(e2, t2, p2, i2)), e2.length > 80 * i2) {
          r2 = o2 = e2[0], n2 = s2 = e2[1];
          for (var f2 = i2; f2 < h2; f2 += i2)
            (a2 = e2[f2]) < r2 && (r2 = a2), (l2 = e2[f2 + 1]) < n2 && (n2 = l2), a2 > o2 && (o2 = a2), l2 > s2 && (s2 = l2);
          c2 = 0 !== (c2 = Math.max(o2 - r2, s2 - n2)) ? 32767 / c2 : 0;
        }
        return Fa(p2, d2, i2, r2, n2, c2, 0), d2;
      }
      function Ba(e2, t2, i2, r2, n2) {
        var o2, s2;
        if (n2 === ol(e2, t2, i2, r2) > 0)
          for (o2 = t2; o2 < i2; o2 += r2)
            s2 = il(o2, e2[o2], e2[o2 + 1], s2);
        else
          for (o2 = i2 - r2; o2 >= t2; o2 -= r2)
            s2 = il(o2, e2[o2], e2[o2 + 1], s2);
        return s2 && Ka(s2, s2.next) && (rl(s2), s2 = s2.next), s2;
      }
      function Ra(e2, t2) {
        if (!e2)
          return e2;
        t2 || (t2 = e2);
        var i2, r2 = e2;
        do {
          if (i2 = false, r2.steiner || !Ka(r2, r2.next) && 0 !== Xa(r2.prev, r2, r2.next))
            r2 = r2.next;
          else {
            if (rl(r2), (r2 = t2 = r2.prev) === r2.next)
              break;
            i2 = true;
          }
        } while (i2 || r2 !== t2);
        return t2;
      }
      function Fa(e2, t2, i2, r2, n2, o2, s2) {
        if (e2) {
          !s2 && o2 && function(e3, t3, i3, r3) {
            var n3 = e3;
            do {
              0 === n3.z && (n3.z = Za(n3.x, n3.y, t3, i3, r3)), n3.prevZ = n3.prev, n3.nextZ = n3.next, n3 = n3.next;
            } while (n3 !== e3);
            n3.prevZ.nextZ = null, n3.prevZ = null, function(e4) {
              var t4, i4, r4, n4, o3, s3, a3, l3, c3 = 1;
              do {
                for (i4 = e4, e4 = null, o3 = null, s3 = 0; i4; ) {
                  for (s3++, r4 = i4, a3 = 0, t4 = 0; t4 < c3 && (a3++, r4 = r4.nextZ); t4++)
                    ;
                  for (l3 = c3; a3 > 0 || l3 > 0 && r4; )
                    0 !== a3 && (0 === l3 || !r4 || i4.z <= r4.z) ? (n4 = i4, i4 = i4.nextZ, a3--) : (n4 = r4, r4 = r4.nextZ, l3--), o3 ? o3.nextZ = n4 : e4 = n4, n4.prevZ = o3, o3 = n4;
                  i4 = r4;
                }
                o3.nextZ = null, c3 *= 2;
              } while (s3 > 1);
            }(n3);
          }(e2, r2, n2, o2);
          for (var a2, l2, c2 = e2; e2.prev !== e2.next; )
            if (a2 = e2.prev, l2 = e2.next, o2 ? Ua(e2, r2, n2, o2) : Oa(e2))
              t2.push(a2.i / i2 | 0), t2.push(e2.i / i2 | 0), t2.push(l2.i / i2 | 0), rl(e2), e2 = l2.next, c2 = l2.next;
            else if ((e2 = l2) === c2) {
              s2 ? 1 === s2 ? Fa(e2 = Va(Ra(e2), t2, i2), t2, i2, r2, n2, o2, 2) : 2 === s2 && ja(e2, t2, i2, r2, n2, o2) : Fa(Ra(e2), t2, i2, r2, n2, o2, 1);
              break;
            }
        }
      }
      function Oa(e2) {
        var t2 = e2.prev, i2 = e2, r2 = e2.next;
        if (Xa(t2, i2, r2) >= 0)
          return false;
        for (var n2 = t2.x, o2 = i2.x, s2 = r2.x, a2 = t2.y, l2 = i2.y, c2 = r2.y, u2 = n2 < o2 ? n2 < s2 ? n2 : s2 : o2 < s2 ? o2 : s2, h2 = a2 < l2 ? a2 < c2 ? a2 : c2 : l2 < c2 ? l2 : c2, p2 = n2 > o2 ? n2 > s2 ? n2 : s2 : o2 > s2 ? o2 : s2, d2 = a2 > l2 ? a2 > c2 ? a2 : c2 : l2 > c2 ? l2 : c2, f2 = r2.next; f2 !== t2; ) {
          if (f2.x >= u2 && f2.x <= p2 && f2.y >= h2 && f2.y <= d2 && Wa(n2, a2, o2, l2, s2, c2, f2.x, f2.y) && Xa(f2.prev, f2, f2.next) >= 0)
            return false;
          f2 = f2.next;
        }
        return true;
      }
      function Ua(e2, t2, i2, r2) {
        var n2 = e2.prev, o2 = e2, s2 = e2.next;
        if (Xa(n2, o2, s2) >= 0)
          return false;
        for (var a2 = n2.x, l2 = o2.x, c2 = s2.x, u2 = n2.y, h2 = o2.y, p2 = s2.y, d2 = a2 < l2 ? a2 < c2 ? a2 : c2 : l2 < c2 ? l2 : c2, f2 = u2 < h2 ? u2 < p2 ? u2 : p2 : h2 < p2 ? h2 : p2, m2 = a2 > l2 ? a2 > c2 ? a2 : c2 : l2 > c2 ? l2 : c2, _2 = u2 > h2 ? u2 > p2 ? u2 : p2 : h2 > p2 ? h2 : p2, g2 = Za(d2, f2, t2, i2, r2), y2 = Za(m2, _2, t2, i2, r2), x2 = e2.prevZ, v2 = e2.nextZ; x2 && x2.z >= g2 && v2 && v2.z <= y2; ) {
          if (x2.x >= d2 && x2.x <= m2 && x2.y >= f2 && x2.y <= _2 && x2 !== n2 && x2 !== s2 && Wa(a2, u2, l2, h2, c2, p2, x2.x, x2.y) && Xa(x2.prev, x2, x2.next) >= 0)
            return false;
          if (x2 = x2.prevZ, v2.x >= d2 && v2.x <= m2 && v2.y >= f2 && v2.y <= _2 && v2 !== n2 && v2 !== s2 && Wa(a2, u2, l2, h2, c2, p2, v2.x, v2.y) && Xa(v2.prev, v2, v2.next) >= 0)
            return false;
          v2 = v2.nextZ;
        }
        for (; x2 && x2.z >= g2; ) {
          if (x2.x >= d2 && x2.x <= m2 && x2.y >= f2 && x2.y <= _2 && x2 !== n2 && x2 !== s2 && Wa(a2, u2, l2, h2, c2, p2, x2.x, x2.y) && Xa(x2.prev, x2, x2.next) >= 0)
            return false;
          x2 = x2.prevZ;
        }
        for (; v2 && v2.z <= y2; ) {
          if (v2.x >= d2 && v2.x <= m2 && v2.y >= f2 && v2.y <= _2 && v2 !== n2 && v2 !== s2 && Wa(a2, u2, l2, h2, c2, p2, v2.x, v2.y) && Xa(v2.prev, v2, v2.next) >= 0)
            return false;
          v2 = v2.nextZ;
        }
        return true;
      }
      function Va(e2, t2, i2) {
        var r2 = e2;
        do {
          var n2 = r2.prev, o2 = r2.next.next;
          !Ka(n2, o2) && Ya(n2, r2, r2.next, o2) && el(n2, o2) && el(o2, n2) && (t2.push(n2.i / i2 | 0), t2.push(r2.i / i2 | 0), t2.push(o2.i / i2 | 0), rl(r2), rl(r2.next), r2 = e2 = o2), r2 = r2.next;
        } while (r2 !== e2);
        return Ra(r2);
      }
      function ja(e2, t2, i2, r2, n2, o2) {
        var s2 = e2;
        do {
          for (var a2 = s2.next.next; a2 !== s2.prev; ) {
            if (s2.i !== a2.i && Ha(s2, a2)) {
              var l2 = tl(s2, a2);
              return s2 = Ra(s2, s2.next), l2 = Ra(l2, l2.next), Fa(s2, t2, i2, r2, n2, o2, 0), void Fa(l2, t2, i2, r2, n2, o2, 0);
            }
            a2 = a2.next;
          }
          s2 = s2.next;
        } while (s2 !== e2);
      }
      function Na(e2, t2) {
        return e2.x - t2.x;
      }
      function Ga(e2, t2) {
        var i2 = function(e3, t3) {
          var i3, r3 = t3, n2 = e3.x, o2 = e3.y, s2 = -1 / 0;
          do {
            if (o2 <= r3.y && o2 >= r3.next.y && r3.next.y !== r3.y) {
              var a2 = r3.x + (o2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
              if (a2 <= n2 && a2 > s2 && (s2 = a2, i3 = r3.x < r3.next.x ? r3 : r3.next, a2 === n2))
                return i3;
            }
            r3 = r3.next;
          } while (r3 !== t3);
          if (!i3)
            return null;
          var l2, c2 = i3, u2 = i3.x, h2 = i3.y, p2 = 1 / 0;
          r3 = i3;
          do {
            n2 >= r3.x && r3.x >= u2 && n2 !== r3.x && Wa(o2 < h2 ? n2 : s2, o2, u2, h2, o2 < h2 ? s2 : n2, o2, r3.x, r3.y) && (l2 = Math.abs(o2 - r3.y) / (n2 - r3.x), el(r3, e3) && (l2 < p2 || l2 === p2 && (r3.x > i3.x || r3.x === i3.x && qa(i3, r3))) && (i3 = r3, p2 = l2)), r3 = r3.next;
          } while (r3 !== c2);
          return i3;
        }(e2, t2);
        if (!i2)
          return t2;
        var r2 = tl(i2, e2);
        return Ra(r2, r2.next), Ra(i2, i2.next);
      }
      function qa(e2, t2) {
        return Xa(e2.prev, e2, t2.prev) < 0 && Xa(t2.next, e2, e2.next) < 0;
      }
      function Za(e2, t2, i2, r2, n2) {
        return (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - i2) * n2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) | (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * n2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) << 1;
      }
      function $a(e2) {
        var t2 = e2, i2 = e2;
        do {
          (t2.x < i2.x || t2.x === i2.x && t2.y < i2.y) && (i2 = t2), t2 = t2.next;
        } while (t2 !== e2);
        return i2;
      }
      function Wa(e2, t2, i2, r2, n2, o2, s2, a2) {
        return (n2 - s2) * (t2 - a2) >= (e2 - s2) * (o2 - a2) && (e2 - s2) * (r2 - a2) >= (i2 - s2) * (t2 - a2) && (i2 - s2) * (o2 - a2) >= (n2 - s2) * (r2 - a2);
      }
      function Ha(e2, t2) {
        return e2.next.i !== t2.i && e2.prev.i !== t2.i && !function(e3, t3) {
          var i2 = e3;
          do {
            if (i2.i !== e3.i && i2.next.i !== e3.i && i2.i !== t3.i && i2.next.i !== t3.i && Ya(i2, i2.next, e3, t3))
              return true;
            i2 = i2.next;
          } while (i2 !== e3);
          return false;
        }(e2, t2) && (el(e2, t2) && el(t2, e2) && function(e3, t3) {
          var i2 = e3, r2 = false, n2 = (e3.x + t3.x) / 2, o2 = (e3.y + t3.y) / 2;
          do {
            i2.y > o2 != i2.next.y > o2 && i2.next.y !== i2.y && n2 < (i2.next.x - i2.x) * (o2 - i2.y) / (i2.next.y - i2.y) + i2.x && (r2 = !r2), i2 = i2.next;
          } while (i2 !== e3);
          return r2;
        }(e2, t2) && (Xa(e2.prev, e2, t2.prev) || Xa(e2, t2.prev, t2)) || Ka(e2, t2) && Xa(e2.prev, e2, e2.next) > 0 && Xa(t2.prev, t2, t2.next) > 0);
      }
      function Xa(e2, t2, i2) {
        return (t2.y - e2.y) * (i2.x - t2.x) - (t2.x - e2.x) * (i2.y - t2.y);
      }
      function Ka(e2, t2) {
        return e2.x === t2.x && e2.y === t2.y;
      }
      function Ya(e2, t2, i2, r2) {
        var n2 = Qa(Xa(e2, t2, i2)), o2 = Qa(Xa(e2, t2, r2)), s2 = Qa(Xa(i2, r2, e2)), a2 = Qa(Xa(i2, r2, t2));
        return n2 !== o2 && s2 !== a2 || !(0 !== n2 || !Ja(e2, i2, t2)) || !(0 !== o2 || !Ja(e2, r2, t2)) || !(0 !== s2 || !Ja(i2, e2, r2)) || !(0 !== a2 || !Ja(i2, t2, r2));
      }
      function Ja(e2, t2, i2) {
        return t2.x <= Math.max(e2.x, i2.x) && t2.x >= Math.min(e2.x, i2.x) && t2.y <= Math.max(e2.y, i2.y) && t2.y >= Math.min(e2.y, i2.y);
      }
      function Qa(e2) {
        return e2 > 0 ? 1 : e2 < 0 ? -1 : 0;
      }
      function el(e2, t2) {
        return Xa(e2.prev, e2, e2.next) < 0 ? Xa(e2, t2, e2.next) >= 0 && Xa(e2, e2.prev, t2) >= 0 : Xa(e2, t2, e2.prev) < 0 || Xa(e2, e2.next, t2) < 0;
      }
      function tl(e2, t2) {
        var i2 = new nl(e2.i, e2.x, e2.y), r2 = new nl(t2.i, t2.x, t2.y), n2 = e2.next, o2 = t2.prev;
        return e2.next = t2, t2.prev = e2, i2.next = n2, n2.prev = i2, r2.next = i2, i2.prev = r2, o2.next = r2, r2.prev = o2, r2;
      }
      function il(e2, t2, i2, r2) {
        var n2 = new nl(e2, t2, i2);
        return r2 ? (n2.next = r2.next, n2.prev = r2, r2.next.prev = n2, r2.next = n2) : (n2.prev = n2, n2.next = n2), n2;
      }
      function rl(e2) {
        e2.next.prev = e2.prev, e2.prev.next = e2.next, e2.prevZ && (e2.prevZ.nextZ = e2.nextZ), e2.nextZ && (e2.nextZ.prevZ = e2.prevZ);
      }
      function nl(e2, t2, i2) {
        this.i = e2, this.x = t2, this.y = i2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      function ol(e2, t2, i2, r2) {
        for (var n2 = 0, o2 = t2, s2 = i2 - r2; o2 < i2; o2 += r2)
          n2 += (e2[s2] - e2[o2]) * (e2[o2 + 1] + e2[s2 + 1]), s2 = o2;
        return n2;
      }
      function sl(e2, t2, i2, r2, n2) {
        al(e2, t2, i2 || 0, r2 || e2.length - 1, n2 || cl);
      }
      function al(e2, t2, i2, r2, n2) {
        for (; r2 > i2; ) {
          if (r2 - i2 > 600) {
            var o2 = r2 - i2 + 1, s2 = t2 - i2 + 1, a2 = Math.log(o2), l2 = 0.5 * Math.exp(2 * a2 / 3), c2 = 0.5 * Math.sqrt(a2 * l2 * (o2 - l2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1);
            al(e2, t2, Math.max(i2, Math.floor(t2 - s2 * l2 / o2 + c2)), Math.min(r2, Math.floor(t2 + (o2 - s2) * l2 / o2 + c2)), n2);
          }
          var u2 = e2[t2], h2 = i2, p2 = r2;
          for (ll(e2, i2, t2), n2(e2[r2], u2) > 0 && ll(e2, i2, r2); h2 < p2; ) {
            for (ll(e2, h2, p2), h2++, p2--; n2(e2[h2], u2) < 0; )
              h2++;
            for (; n2(e2[p2], u2) > 0; )
              p2--;
          }
          0 === n2(e2[i2], u2) ? ll(e2, i2, p2) : ll(e2, ++p2, r2), p2 <= t2 && (i2 = p2 + 1), t2 <= p2 && (r2 = p2 - 1);
        }
      }
      function ll(e2, t2, i2) {
        var r2 = e2[t2];
        e2[t2] = e2[i2], e2[i2] = r2;
      }
      function cl(e2, t2) {
        return e2 < t2 ? -1 : e2 > t2 ? 1 : 0;
      }
      function ul(e2, t2) {
        const i2 = e2.length;
        if (i2 <= 1)
          return [e2];
        const r2 = [];
        let n2, o2;
        for (let t3 = 0; t3 < i2; t3++) {
          const i3 = W(e2[t3]);
          0 !== i3 && (e2[t3].area = Math.abs(i3), void 0 === o2 && (o2 = i3 < 0), o2 === i3 < 0 ? (n2 && r2.push(n2), n2 = [e2[t3]]) : n2.push(e2[t3]));
        }
        if (n2 && r2.push(n2), t2 > 1)
          for (let e3 = 0; e3 < r2.length; e3++)
            r2[e3].length <= t2 || (sl(r2[e3], t2, 1, r2[e3].length - 1, hl), r2[e3] = r2[e3].slice(0, t2));
        return r2;
      }
      function hl(e2, t2) {
        return t2.area - e2.area;
      }
      function pl(e2, t2, i2) {
        const r2 = i2.patternDependencies;
        let n2 = false;
        for (const i3 of t2) {
          const t3 = i3.paint.get(`${e2}-pattern`);
          t3.isConstant() || (n2 = true);
          const o2 = t3.constantOr(null);
          o2 && (n2 = true, r2[o2] = true);
        }
        return n2;
      }
      function dl(e2, t2, i2, r2, n2) {
        const o2 = n2.patternDependencies;
        for (const s2 of t2) {
          const t3 = s2.paint.get(`${e2}-pattern`).value;
          if ("constant" !== t3.kind) {
            let e3 = t3.evaluate({ zoom: r2 }, i2, {}, n2.availableImages);
            e3 = e3 && e3.name ? e3.name : e3, o2[e3] = true, i2.patterns[s2.id] = e3;
          }
        }
        return i2;
      }
      La.exports = ka, La.exports.default = ka, ka.deviation = function(e2, t2, i2, r2) {
        var n2 = t2 && t2.length, o2 = Math.abs(ol(e2, 0, n2 ? t2[0] * i2 : e2.length, i2));
        if (n2)
          for (var s2 = 0, a2 = t2.length; s2 < a2; s2++)
            o2 -= Math.abs(ol(e2, t2[s2] * i2, s2 < a2 - 1 ? t2[s2 + 1] * i2 : e2.length, i2));
        var l2 = 0;
        for (s2 = 0; s2 < r2.length; s2 += 3) {
          var c2 = r2[s2] * i2, u2 = r2[s2 + 1] * i2, h2 = r2[s2 + 2] * i2;
          l2 += Math.abs((e2[c2] - e2[h2]) * (e2[u2 + 1] - e2[c2 + 1]) - (e2[c2] - e2[u2]) * (e2[h2 + 1] - e2[c2 + 1]));
        }
        return 0 === o2 && 0 === l2 ? 0 : Math.abs((l2 - o2) / o2);
      }, ka.flatten = function(e2) {
        for (var t2 = e2[0][0].length, i2 = { vertices: [], holes: [], dimensions: t2 }, r2 = 0, n2 = 0; n2 < e2.length; n2++) {
          for (var o2 = 0; o2 < e2[n2].length; o2++)
            for (var s2 = 0; s2 < t2; s2++)
              i2.vertices.push(e2[n2][o2][s2]);
          n2 > 0 && i2.holes.push(r2 += e2[n2 - 1].length);
        }
        return i2;
      };
      class FillBucket {
        constructor(e2) {
          this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((e3) => e3.id), this.index = e2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new StructArrayLayout2i4(), this.indexArray = new StructArrayLayout3ui6(), this.indexArray2 = new StructArrayLayout2ui4(), this.programConfigurations = new ProgramConfigurationSet(e2.layers, e2.zoom), this.segments = new SegmentVector(), this.segments2 = new SegmentVector(), this.stateDependentLayerIds = this.layers.filter((e3) => e3.isStateDependent()).map((e3) => e3.id), this.projection = e2.projection;
        }
        populate(e2, t2, i2, r2) {
          this.hasPattern = pl("fill", this.layers, t2);
          const n2 = this.layers[0].layout.get("fill-sort-key"), o2 = [];
          for (const { feature: s2, id: a2, index: l2, sourceLayerIndex: c2 } of e2) {
            const e3 = this.layers[0]._featureFilter.needGeometry, u2 = es(s2, e3);
            if (!this.layers[0]._featureFilter.filter(new EvaluationParameters(this.zoom), u2, i2))
              continue;
            const h2 = n2 ? n2.evaluate(u2, {}, i2, t2.availableImages) : void 0, p2 = { id: a2, properties: s2.properties, type: s2.type, sourceLayerIndex: c2, index: l2, geometry: e3 ? u2.geometry : Qo(s2, i2, r2), patterns: {}, sortKey: h2 };
            o2.push(p2);
          }
          n2 && o2.sort((e3, t3) => e3.sortKey - t3.sortKey);
          for (const r3 of o2) {
            const { geometry: n3, index: o3, sourceLayerIndex: s2 } = r3;
            if (this.hasPattern) {
              const e3 = dl("fill", this.layers, r3, this.zoom, t2);
              this.patternFeatures.push(e3);
            } else
              this.addFeature(r3, n3, o3, i2, {}, t2.availableImages);
            t2.featureIndex.insert(e2[o3].feature, n3, o3, s2, this.index);
          }
        }
        update(e2, t2, i2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e2, t2, this.stateDependentLayers, i2, r2);
        }
        addFeatures(e2, t2, i2, r2, n2) {
          for (const e3 of this.patternFeatures)
            this.addFeature(e3, e3.geometry, e3.index, t2, i2, r2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e2) {
          this.uploaded || (this.layoutVertexBuffer = e2.createVertexBuffer(this.layoutVertexArray, za), this.indexBuffer = e2.createIndexBuffer(this.indexArray), this.indexBuffer2 = e2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(e2, t2, i2, r2, n2, o2 = []) {
          for (const e3 of ul(t2, 500)) {
            let t3 = 0;
            for (const i4 of e3)
              t3 += i4.length;
            const i3 = this.segments.prepareSegment(t3, this.layoutVertexArray, this.indexArray), r3 = i3.vertexLength, n3 = [], o3 = [];
            for (const t4 of e3) {
              if (0 === t4.length)
                continue;
              t4 !== e3[0] && o3.push(n3.length / 2);
              const i4 = this.segments2.prepareSegment(t4.length, this.layoutVertexArray, this.indexArray2), r4 = i4.vertexLength;
              this.layoutVertexArray.emplaceBack(t4[0].x, t4[0].y), this.indexArray2.emplaceBack(r4 + t4.length - 1, r4), n3.push(t4[0].x), n3.push(t4[0].y);
              for (let e4 = 1; e4 < t4.length; e4++)
                this.layoutVertexArray.emplaceBack(t4[e4].x, t4[e4].y), this.indexArray2.emplaceBack(r4 + e4 - 1, r4 + e4), n3.push(t4[e4].x), n3.push(t4[e4].y);
              i4.vertexLength += t4.length, i4.primitiveLength += t4.length;
            }
            const s2 = La.exports(n3, o3);
            for (let e4 = 0; e4 < s2.length; e4 += 3)
              this.indexArray.emplaceBack(r3 + s2[e4], r3 + s2[e4 + 1], r3 + s2[e4 + 2]);
            i3.vertexLength += t3, i3.primitiveLength += s2.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e2, i2, n2, o2, r2);
        }
      }
      kn(FillBucket, "FillBucket", { omit: ["layers", "patternFeatures"] });
      const fl = new Properties({ "fill-sort-key": new DataDrivenProperty(ft.layout_fill["fill-sort-key"]) });
      var ml = { paint: new Properties({ "fill-antialias": new DataConstantProperty(ft.paint_fill["fill-antialias"]), "fill-opacity": new DataDrivenProperty(ft.paint_fill["fill-opacity"]), "fill-color": new DataDrivenProperty(ft.paint_fill["fill-color"]), "fill-outline-color": new DataDrivenProperty(ft.paint_fill["fill-outline-color"]), "fill-translate": new DataConstantProperty(ft.paint_fill["fill-translate"]), "fill-translate-anchor": new DataConstantProperty(ft.paint_fill["fill-translate-anchor"]), "fill-pattern": new DataDrivenProperty(ft.paint_fill["fill-pattern"]) }), layout: fl };
      const _l = co([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), gl = co([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), yl = co([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: xl } = _l;
      var vl = d, bl = wl;
      function wl(e2, t2, i2, r2, n2) {
        this.properties = {}, this.extent = i2, this.type = 0, this._pbf = e2, this._geometry = -1, this._keys = r2, this._values = n2, e2.readFields(Tl, this, t2);
      }
      function Tl(e2, t2, i2) {
        1 == e2 ? t2.id = i2.readVarint() : 2 == e2 ? function(e3, t3) {
          for (var i3 = e3.readVarint() + e3.pos; e3.pos < i3; ) {
            var r2 = t3._keys[e3.readVarint()], n2 = t3._values[e3.readVarint()];
            t3.properties[r2] = n2;
          }
        }(i2, t2) : 3 == e2 ? t2.type = i2.readVarint() : 4 == e2 && (t2._geometry = i2.pos);
      }
      function El(e2) {
        for (var t2, i2, r2 = 0, n2 = 0, o2 = e2.length, s2 = o2 - 1; n2 < o2; s2 = n2++)
          r2 += ((i2 = e2[s2]).x - (t2 = e2[n2]).x) * (t2.y + i2.y);
        return r2;
      }
      wl.types = ["Unknown", "Point", "LineString", "Polygon"], wl.prototype.loadGeometry = function() {
        var e2 = this._pbf;
        e2.pos = this._geometry;
        for (var t2, i2 = e2.readVarint() + e2.pos, r2 = 1, n2 = 0, o2 = 0, s2 = 0, a2 = []; e2.pos < i2; ) {
          if (n2 <= 0) {
            var l2 = e2.readVarint();
            r2 = 7 & l2, n2 = l2 >> 3;
          }
          if (n2--, 1 === r2 || 2 === r2)
            o2 += e2.readSVarint(), s2 += e2.readSVarint(), 1 === r2 && (t2 && a2.push(t2), t2 = []), t2.push(new vl(o2, s2));
          else {
            if (7 !== r2)
              throw new Error("unknown command " + r2);
            t2 && t2.push(t2[0].clone());
          }
        }
        return t2 && a2.push(t2), a2;
      }, wl.prototype.bbox = function() {
        var e2 = this._pbf;
        e2.pos = this._geometry;
        for (var t2 = e2.readVarint() + e2.pos, i2 = 1, r2 = 0, n2 = 0, o2 = 0, s2 = 1 / 0, a2 = -1 / 0, l2 = 1 / 0, c2 = -1 / 0; e2.pos < t2; ) {
          if (r2 <= 0) {
            var u2 = e2.readVarint();
            i2 = 7 & u2, r2 = u2 >> 3;
          }
          if (r2--, 1 === i2 || 2 === i2)
            (n2 += e2.readSVarint()) < s2 && (s2 = n2), n2 > a2 && (a2 = n2), (o2 += e2.readSVarint()) < l2 && (l2 = o2), o2 > c2 && (c2 = o2);
          else if (7 !== i2)
            throw new Error("unknown command " + i2);
        }
        return [s2, l2, a2, c2];
      }, wl.prototype.toGeoJSON = function(e2, t2, i2) {
        var r2, n2, o2 = this.extent * Math.pow(2, i2), s2 = this.extent * e2, a2 = this.extent * t2, l2 = this.loadGeometry(), c2 = wl.types[this.type];
        function u2(e3) {
          for (var t3 = 0; t3 < e3.length; t3++) {
            var i3 = e3[t3];
            e3[t3] = [360 * (i3.x + s2) / o2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (i3.y + a2) / o2) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var h2 = [];
            for (r2 = 0; r2 < l2.length; r2++)
              h2[r2] = l2[r2][0];
            u2(l2 = h2);
            break;
          case 2:
            for (r2 = 0; r2 < l2.length; r2++)
              u2(l2[r2]);
            break;
          case 3:
            for (l2 = function(e3) {
              var t3 = e3.length;
              if (t3 <= 1)
                return [e3];
              for (var i3, r3, n3 = [], o3 = 0; o3 < t3; o3++) {
                var s3 = El(e3[o3]);
                0 !== s3 && (void 0 === r3 && (r3 = s3 < 0), r3 === s3 < 0 ? (i3 && n3.push(i3), i3 = [e3[o3]]) : i3.push(e3[o3]));
              }
              return i3 && n3.push(i3), n3;
            }(l2), r2 = 0; r2 < l2.length; r2++)
              for (n2 = 0; n2 < l2[r2].length; n2++)
                u2(l2[r2][n2]);
        }
        1 === l2.length ? l2 = l2[0] : c2 = "Multi" + c2;
        var p2 = { type: "Feature", geometry: { type: c2, coordinates: l2 }, properties: this.properties };
        return "id" in this && (p2.id = this.id), p2;
      };
      var Sl = bl, Al = Cl;
      function Cl(e2, t2) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = e2, this._keys = [], this._values = [], this._features = [], e2.readFields(Il, this, t2), this.length = this._features.length;
      }
      function Il(e2, t2, i2) {
        15 === e2 ? t2.version = i2.readVarint() : 1 === e2 ? t2.name = i2.readString() : 5 === e2 ? t2.extent = i2.readVarint() : 2 === e2 ? t2._features.push(i2.pos) : 3 === e2 ? t2._keys.push(i2.readString()) : 4 === e2 && t2._values.push(function(e3) {
          for (var t3 = null, i3 = e3.readVarint() + e3.pos; e3.pos < i3; ) {
            var r2 = e3.readVarint() >> 3;
            t3 = 1 === r2 ? e3.readString() : 2 === r2 ? e3.readFloat() : 3 === r2 ? e3.readDouble() : 4 === r2 ? e3.readVarint64() : 5 === r2 ? e3.readVarint() : 6 === r2 ? e3.readSVarint() : 7 === r2 ? e3.readBoolean() : null;
          }
          return t3;
        }(i2));
      }
      Cl.prototype.feature = function(e2) {
        if (e2 < 0 || e2 >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[e2];
        var t2 = this._pbf.readVarint() + this._pbf.pos;
        return new Sl(this._pbf, t2, this.extent, this._keys, this._values);
      };
      var Ml = Al;
      function Dl(e2, t2, i2) {
        if (3 === e2) {
          var r2 = new Ml(i2, i2.readVarint() + i2.pos);
          r2.length && (t2[r2.name] = r2);
        }
      }
      var Pl = function(e2, t2) {
        this.layers = e2.readFields(Dl, {}, t2);
      }, zl = bl;
      function Ll(e2, t2, i2, r2) {
        const n2 = [], o2 = 0 === r2 ? (e3, t3, i3, r3, n3, o3) => {
          e3.push(new d(o3, i3 + (o3 - t3) / (r3 - t3) * (n3 - i3)));
        } : (e3, t3, i3, r3, n3, o3) => {
          e3.push(new d(t3 + (o3 - i3) / (n3 - i3) * (r3 - t3), o3));
        };
        for (const s2 of e2) {
          const e3 = [];
          for (const n3 of s2) {
            if (n3.length <= 2)
              continue;
            const s3 = [];
            for (let e4 = 0; e4 < n3.length - 1; e4++) {
              const a3 = n3[e4].x, l3 = n3[e4].y, c2 = n3[e4 + 1].x, u2 = n3[e4 + 1].y, h2 = 0 === r2 ? a3 : l3, p2 = 0 === r2 ? c2 : u2;
              h2 < t2 ? p2 > t2 && o2(s3, a3, l3, c2, u2, t2) : h2 > i2 ? p2 < i2 && o2(s3, a3, l3, c2, u2, i2) : s3.push(n3[e4]), p2 < t2 && h2 >= t2 && o2(s3, a3, l3, c2, u2, t2), p2 > i2 && h2 <= i2 && o2(s3, a3, l3, c2, u2, i2);
            }
            let a2 = n3[n3.length - 1];
            const l2 = 0 === r2 ? a2.x : a2.y;
            l2 >= t2 && l2 <= i2 && s3.push(a2), s3.length && (a2 = s3[s3.length - 1], s3[0].x === a2.x && s3[0].y === a2.y || s3.push(s3[0]), e3.push(s3));
          }
          e3.length && n2.push(e3);
        }
        return n2;
      }
      const kl = zl.types, Bl = Math.pow(2, 13);
      function Rl(e2, t2, i2, r2, n2, o2, s2, a2) {
        e2.emplaceBack((t2 << 1) + s2, (i2 << 1) + o2, (Math.floor(r2 * Bl) << 1) + n2, Math.round(a2));
      }
      function Fl(e2, t2, i2) {
        const r2 = 16384;
        e2.emplaceBack(t2.x, t2.y, t2.z, i2[0] * r2, i2[1] * r2, i2[2] * r2);
      }
      class PartMetadata {
        constructor() {
          this.acc = new d(0, 0), this.polyCount = [];
        }
        startRing(e2) {
          this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new d(e2.x, e2.y), this.max = new d(e2.x, e2.y));
        }
        append(e2, t2) {
          this.currentPolyCount.edges++, this.acc._add(e2);
          const i2 = this.min, r2 = this.max;
          e2.x < i2.x ? i2.x = e2.x : e2.x > r2.x && (r2.x = e2.x), e2.y < i2.y ? i2.y = e2.y : e2.y > r2.y && (r2.y = e2.y), ((0 === e2.x || e2.x === ko) && e2.x === t2.x) != ((0 === e2.y || e2.y === ko) && e2.y === t2.y) && this.processBorderOverlap(e2, t2), t2.x < 0 != e2.x < 0 && this.addBorderIntersection(0, Ii(t2.y, e2.y, (0 - t2.x) / (e2.x - t2.x))), t2.x > ko != e2.x > ko && this.addBorderIntersection(1, Ii(t2.y, e2.y, (ko - t2.x) / (e2.x - t2.x))), t2.y < 0 != e2.y < 0 && this.addBorderIntersection(2, Ii(t2.x, e2.x, (0 - t2.y) / (e2.y - t2.y))), t2.y > ko != e2.y > ko && this.addBorderIntersection(3, Ii(t2.x, e2.x, (ko - t2.y) / (e2.y - t2.y)));
        }
        addBorderIntersection(e2, t2) {
          this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
          const i2 = this.borders[e2];
          t2 < i2[0] && (i2[0] = t2), t2 > i2[1] && (i2[1] = t2);
        }
        processBorderOverlap(e2, t2) {
          if (e2.x === t2.x) {
            if (e2.y === t2.y)
              return;
            const i2 = 0 === e2.x ? 0 : 1;
            this.addBorderIntersection(i2, t2.y), this.addBorderIntersection(i2, e2.y);
          } else {
            const i2 = 0 === e2.y ? 2 : 3;
            this.addBorderIntersection(i2, t2.x), this.addBorderIntersection(i2, e2.x);
          }
        }
        centroid() {
          const e2 = this.polyCount.reduce((e3, t2) => e3 + t2.edges, 0);
          return 0 !== e2 ? this.acc.div(e2)._round() : new d(0, 0);
        }
        span() {
          return new d(this.max.x - this.min.x, this.max.y - this.min.y);
        }
        intersectsCount() {
          return this.borders.reduce((e2, t2) => e2 + +(t2[0] !== Number.MAX_VALUE), 0);
        }
      }
      class FillExtrusionBucket {
        constructor(e2) {
          this.zoom = e2.zoom, this.canonical = e2.canonical, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((e3) => e3.id), this.index = e2.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = e2.projection, this.layoutVertexArray = new StructArrayLayout4i8(), this.centroidVertexArray = new FillExtrusionCentroidArray(), this.indexArray = new StructArrayLayout3ui6(), this.programConfigurations = new ProgramConfigurationSet(e2.layers, e2.zoom), this.segments = new SegmentVector(), this.stateDependentLayerIds = this.layers.filter((e3) => e3.isStateDependent()).map((e3) => e3.id), this.enableTerrain = e2.enableTerrain;
        }
        populate(e2, t2, i2, r2) {
          this.features = [], this.hasPattern = pl("fill-extrusion", this.layers, t2), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function(e3) {
            const t3 = Math.exp(Math.PI * (1 - e3.y / (1 << e3.z) * 2));
            return 80150034 * t3 / (t3 * t3 + 1) / ko / (1 << e3.z);
          }(i2), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
          for (const { feature: n2, id: o2, index: s2, sourceLayerIndex: a2 } of e2) {
            const e3 = this.layers[0]._featureFilter.needGeometry, l2 = es(n2, e3);
            if (!this.layers[0]._featureFilter.filter(new EvaluationParameters(this.zoom), l2, i2))
              continue;
            const c2 = { id: o2, sourceLayerIndex: a2, index: s2, geometry: e3 ? l2.geometry : Qo(n2, i2, r2), properties: n2.properties, type: n2.type, patterns: {} }, u2 = this.layoutVertexArray.length;
            this.hasPattern ? this.features.push(dl("fill-extrusion", this.layers, c2, this.zoom, t2)) : this.addFeature(c2, c2.geometry, s2, i2, {}, t2.availableImages, r2), t2.featureIndex.insert(n2, c2.geometry, s2, a2, this.index, u2);
          }
          this.sortBorders();
        }
        addFeatures(e2, t2, i2, r2, n2) {
          for (const e3 of this.features) {
            const { geometry: o2 } = e3;
            this.addFeature(e3, o2, e3.index, t2, i2, r2, n2);
          }
          this.sortBorders();
        }
        update(e2, t2, i2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e2, t2, this.stateDependentLayers, i2, r2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e2) {
          this.uploaded || (this.layoutVertexBuffer = e2.createVertexBuffer(this.layoutVertexArray, xl), this.indexBuffer = e2.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = e2.createVertexBuffer(this.layoutVertexExtArray, yl.members, true))), this.programConfigurations.upload(e2), this.uploaded = true;
        }
        uploadCentroid(e2) {
          0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = e2.createVertexBuffer(this.centroidVertexArray, gl.members, true), this.needsCentroidUpdate = false);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(e2, t2, i2, r2, n2, o2, s2) {
          const a2 = [new d(0, 0), new d(ko, ko)], l2 = s2.projection, c2 = "globe" === l2.name, u2 = this.enableTerrain && !c2 ? new PartMetadata() : null, h2 = "Polygon" === kl[e2.type];
          c2 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new StructArrayLayout6i12());
          const p2 = ul(t2, 500);
          for (let e3 = p2.length - 1; e3 >= 0; e3--) {
            const t3 = p2[e3];
            (0 === t3.length || (f2 = t3[0]).every((e4) => e4.x <= 0) || f2.every((e4) => e4.x >= ko) || f2.every((e4) => e4.y <= 0) || f2.every((e4) => e4.y >= ko)) && p2.splice(e3, 1);
          }
          var f2;
          let m2;
          if (c2)
            m2 = Zl(p2, a2, r2);
          else {
            m2 = [];
            for (const e3 of p2)
              m2.push({ polygon: e3, bounds: a2 });
          }
          const _2 = h2 ? this.edgeRadius : 0;
          for (const { polygon: e3, bounds: t3 } of m2) {
            let i3 = 0, n3 = 0;
            for (const t4 of e3)
              h2 && !t4[0].equals(t4[t4.length - 1]) && t4.push(t4[0]), n3 += h2 ? t4.length - 1 : t4.length;
            const o3 = this.segments.prepareSegment((h2 ? 5 : 4) * n3, this.layoutVertexArray, this.indexArray);
            if (h2) {
              const t4 = [], n4 = [];
              i3 = o3.vertexLength;
              for (const i4 of e3) {
                let s4, a3;
                i4.length && i4 !== e3[0] && n4.push(t4.length / 2), s4 = i4[1].sub(i4[0])._perp()._unit();
                for (let e4 = 1; e4 < i4.length; e4++) {
                  const n5 = i4[e4], u3 = i4[e4 === i4.length - 1 ? 1 : e4 + 1];
                  let { x: h3, y: p3 } = n5;
                  if (_2) {
                    a3 = u3.sub(n5)._perp()._unit();
                    const e5 = s4.add(a3)._unit(), t5 = _2 * Math.min(4, 1 / (s4.x * e5.x + s4.y * e5.y));
                    h3 += t5 * e5.x, p3 += t5 * e5.y, s4 = a3;
                  }
                  Rl(this.layoutVertexArray, h3, p3, 0, 0, 1, 1, 0), o3.vertexLength++, t4.push(n5.x, n5.y), c2 && Fl(this.layoutVertexExtArray, l2.projectTilePoint(h3, p3, r2), l2.upVector(r2, h3, p3));
                }
              }
              const s3 = La.exports(t4, n4);
              for (let e4 = 0; e4 < s3.length; e4 += 3)
                this.indexArray.emplaceBack(i3 + s3[e4], i3 + s3[e4 + 2], i3 + s3[e4 + 1]), o3.primitiveLength++;
            }
            for (const n4 of e3) {
              u2 && n4.length && u2.startRing(n4[0]);
              let e4, s3, a3, p3 = n4.length > 4 && Nl(n4[n4.length - 2], n4[0], n4[1]), d2 = _2 ? Ul(n4[n4.length - 2], n4[0], n4[1], _2) : 0;
              s3 = n4[1].sub(n4[0])._perp()._unit();
              let f3 = true;
              for (let m3 = 1, g2 = 0; m3 < n4.length; m3++) {
                let y2 = n4[m3 - 1], x2 = n4[m3];
                const v2 = n4[m3 === n4.length - 1 ? 1 : m3 + 1];
                if (u2 && h2 && u2.currentPolyCount.top++, jl(x2, y2, t3)) {
                  _2 && (s3 = v2.sub(x2)._perp()._unit(), f3 = !f3);
                  continue;
                }
                u2 && u2.append(x2, y2);
                const b2 = x2.sub(y2)._perp(), w2 = b2.x / (Math.abs(b2.x) + Math.abs(b2.y)), T2 = b2.y > 0 ? 1 : 0, E2 = y2.dist(x2);
                if (g2 + E2 > 32768 && (g2 = 0), _2) {
                  a3 = v2.sub(x2)._perp()._unit();
                  let e5 = Vl(y2, x2, v2, Ol(s3, a3), _2);
                  isNaN(e5) && (e5 = 0);
                  const t4 = x2.sub(y2)._unit();
                  y2 = y2.add(t4.mult(d2))._round(), x2 = x2.add(t4.mult(-e5))._round(), d2 = e5, s3 = a3;
                }
                const S2 = o3.vertexLength, A2 = n4.length > 4 && Nl(y2, x2, v2);
                let C2 = Gl(g2, p3, f3);
                if (Rl(this.layoutVertexArray, y2.x, y2.y, w2, T2, 0, 0, C2), Rl(this.layoutVertexArray, y2.x, y2.y, w2, T2, 0, 1, C2), g2 += E2, C2 = Gl(g2, A2, !f3), p3 = A2, Rl(this.layoutVertexArray, x2.x, x2.y, w2, T2, 0, 0, C2), Rl(this.layoutVertexArray, x2.x, x2.y, w2, T2, 0, 1, C2), o3.vertexLength += 4, this.indexArray.emplaceBack(S2 + 0, S2 + 1, S2 + 2), this.indexArray.emplaceBack(S2 + 1, S2 + 3, S2 + 2), o3.primitiveLength += 2, _2) {
                  const r3 = i3 + (1 === m3 ? n4.length - 2 : m3 - 2), s4 = 1 === m3 ? i3 : r3 + 1;
                  if (this.indexArray.emplaceBack(S2 + 1, r3, S2 + 3), this.indexArray.emplaceBack(r3, s4, S2 + 3), o3.primitiveLength += 2, void 0 === e4 && (e4 = S2), !jl(v2, n4[m3], t3)) {
                    const t4 = m3 === n4.length - 1 ? e4 : o3.vertexLength;
                    this.indexArray.emplaceBack(S2 + 2, S2 + 3, t4), this.indexArray.emplaceBack(S2 + 3, t4 + 1, t4), this.indexArray.emplaceBack(S2 + 3, s4, t4 + 1), o3.primitiveLength += 3;
                  }
                  f3 = !f3;
                }
                if (c2) {
                  const e5 = this.layoutVertexExtArray, t4 = l2.projectTilePoint(y2.x, y2.y, r2), i4 = l2.projectTilePoint(x2.x, x2.y, r2), n5 = l2.upVector(r2, y2.x, y2.y), o4 = l2.upVector(r2, x2.x, x2.y);
                  Fl(e5, t4, n5), Fl(e5, t4, n5), Fl(e5, i4, o4), Fl(e5, i4, o4);
                }
              }
              h2 && (i3 += n4.length - 1);
            }
          }
          if (u2 && u2.polyCount.length > 0) {
            if (u2.borders) {
              u2.vertexArrayOffset = this.centroidVertexArray.length;
              const e3 = u2.borders, t3 = this.featuresOnBorder.push(u2) - 1;
              for (let i3 = 0; i3 < 4; i3++)
                e3[i3][0] !== Number.MAX_VALUE && this.borders[i3].push(t3);
            }
            this.encodeCentroid(u2.borders ? void 0 : u2.centroid(), u2);
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e2, i2, n2, o2, r2);
        }
        sortBorders() {
          for (let e2 = 0; e2 < 4; e2++)
            this.borders[e2].sort((t2, i2) => this.featuresOnBorder[t2].borders[e2][0] - this.featuresOnBorder[i2].borders[e2][0]);
        }
        encodeCentroid(e2, t2, i2 = true) {
          let r2, n2;
          if (e2)
            if (0 !== e2.y) {
              const i3 = t2.span()._mult(this.tileToMeter);
              r2 = (Math.max(e2.x, 1) << 3) + Math.min(7, Math.round(i3.x / 10)), n2 = (Math.max(e2.y, 1) << 3) + Math.min(7, Math.round(i3.y / 10));
            } else
              r2 = Math.ceil(7 * (e2.x + 450)), n2 = 0;
          else
            r2 = 0, n2 = +i2;
          let o2 = i2 ? this.centroidVertexArray.length : t2.vertexArrayOffset;
          for (const e3 of t2.polyCount) {
            i2 && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * e3.edges + e3.top);
            for (let t3 = 0; t3 < e3.top; t3++)
              this.centroidVertexArray.emplace(o2++, r2, n2);
            for (let t3 = 0; t3 < 2 * e3.edges; t3++)
              this.centroidVertexArray.emplace(o2++, 0, n2), this.centroidVertexArray.emplace(o2++, r2, n2);
          }
        }
      }
      function Ol(e2, t2) {
        const i2 = e2.add(t2)._unit();
        return e2.x * i2.x + e2.y * i2.y;
      }
      function Ul(e2, t2, i2, r2) {
        const n2 = t2.sub(e2)._perp()._unit(), o2 = i2.sub(t2)._perp()._unit();
        return Vl(e2, t2, i2, Ol(n2, o2), r2);
      }
      function Vl(e2, t2, i2, r2, n2) {
        const o2 = Math.sqrt(1 - r2 * r2);
        return Math.min(e2.dist(t2) / 3, t2.dist(i2) / 3, n2 * o2 / r2);
      }
      function jl(e2, t2, i2) {
        return e2.x < i2[0].x && t2.x < i2[0].x || e2.x > i2[1].x && t2.x > i2[1].x || e2.y < i2[0].y && t2.y < i2[0].y || e2.y > i2[1].y && t2.y > i2[1].y;
      }
      function Nl(e2, t2, i2) {
        if (e2.x < 0 || e2.x >= ko || t2.x < 0 || t2.x >= ko || i2.x < 0 || i2.x >= ko)
          return false;
        const r2 = i2.sub(t2), n2 = r2.perp(), o2 = e2.sub(t2);
        return (r2.x * o2.x + r2.y * o2.y) / Math.sqrt((r2.x * r2.x + r2.y * r2.y) * (o2.x * o2.x + o2.y * o2.y)) > -0.866 && n2.x * o2.x + n2.y * o2.y < 0;
      }
      function Gl(e2, t2, i2) {
        const r2 = t2 ? 2 | e2 : -3 & e2;
        return i2 ? 1 | r2 : -2 & r2;
      }
      function ql() {
        const e2 = Math.PI / 32, t2 = Math.tan(e2), i2 = Bo;
        return i2 * Math.sqrt(1 + 2 * t2 * t2) - i2;
      }
      function Zl(e2, t2, i2) {
        const r2 = 1 << i2.z, n2 = jo(i2.x / r2), o2 = jo((i2.x + 1) / r2), s2 = No(i2.y / r2), a2 = No((i2.y + 1) / r2);
        return function(e3, t3, i3, r3, n3 = 0, o3) {
          const s3 = [];
          if (!e3.length || !i3 || !r3)
            return s3;
          const a3 = (e4, t4) => {
            for (const i4 of e4)
              s3.push({ polygon: i4, bounds: t4 });
          }, l2 = Math.ceil(Math.log2(i3)), c2 = Math.ceil(Math.log2(r3)), u2 = l2 - c2, h2 = [];
          for (let e4 = 0; e4 < Math.abs(u2); e4++)
            h2.push(u2 > 0 ? 0 : 1);
          for (let e4 = 0; e4 < Math.min(l2, c2); e4++)
            h2.push(0), h2.push(1);
          let p2 = e3;
          if (p2 = Ll(p2, t3[0].y - n3, t3[1].y + n3, 1), p2 = Ll(p2, t3[0].x - n3, t3[1].x + n3, 0), !p2.length)
            return s3;
          const f2 = [];
          for (h2.length ? f2.push({ polygons: p2, bounds: t3, depth: 0 }) : a3(p2, t3); f2.length; ) {
            const e4 = f2.pop(), t4 = e4.depth, i4 = h2[t4], r4 = e4.bounds[0], s4 = e4.bounds[1], l3 = 0 === i4 ? r4.x : r4.y, c3 = 0 === i4 ? s4.x : s4.y, u3 = o3 ? o3(i4, l3, c3) : 0.5 * (l3 + c3), p3 = Ll(e4.polygons, l3 - n3, u3 + n3, i4), m2 = Ll(e4.polygons, u3 - n3, c3 + n3, i4);
            if (p3.length) {
              const e5 = [r4, new d(0 === i4 ? u3 : s4.x, 1 === i4 ? u3 : s4.y)];
              h2.length > t4 + 1 ? f2.push({ polygons: p3, bounds: e5, depth: t4 + 1 }) : a3(p3, e5);
            }
            if (m2.length) {
              const e5 = [new d(0 === i4 ? u3 : r4.x, 1 === i4 ? u3 : r4.y), s4];
              h2.length > t4 + 1 ? f2.push({ polygons: m2, bounds: e5, depth: t4 + 1 }) : a3(m2, e5);
            }
          }
          return s3;
        }(e2, t2, Math.ceil((o2 - n2) / 11.25), Math.ceil((s2 - a2) / 11.25), 1, (e3, t3, n3) => {
          if (0 === e3)
            return 0.5 * (t3 + n3);
          {
            const e4 = No((i2.y + t3 / ko) / r2);
            return (Uo(0.5 * (No((i2.y + n3 / ko) / r2) + e4)) * r2 - i2.y) * ko;
          }
        });
      }
      kn(FillExtrusionBucket, "FillExtrusionBucket", { omit: ["layers", "features"] }), kn(PartMetadata, "PartMetadata");
      const $l = new Properties({ "fill-extrusion-edge-radius": new DataConstantProperty(ft["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });
      var Wl = { paint: new Properties({ "fill-extrusion-opacity": new DataConstantProperty(ft["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new DataDrivenProperty(ft["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new DataConstantProperty(ft["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new DataConstantProperty(ft["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new DataDrivenProperty(ft["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new DataDrivenProperty(ft["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new DataDrivenProperty(ft["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new DataConstantProperty(ft["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new DataConstantProperty(ft["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new DataConstantProperty(ft["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]) }), layout: $l };
      function Hl(e2, t2, i2) {
        var r2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, i2);
        return [e2 * r2 - 2 * Math.PI * 6378137 / 2, t2 * r2 - 2 * Math.PI * 6378137 / 2];
      }
      class CanonicalTileID {
        constructor(e2, t2, i2) {
          this.z = e2, this.x = t2, this.y = i2, this.key = Xl(0, e2, e2, t2, i2);
        }
        equals(e2) {
          return this.z === e2.z && this.x === e2.x && this.y === e2.y;
        }
        url(e2, t2) {
          const i2 = function(e3, t3, i3) {
            var r3 = Hl(256 * e3, 256 * (t3 = Math.pow(2, i3) - t3 - 1), i3), n2 = Hl(256 * (e3 + 1), 256 * (t3 + 1), i3);
            return r3[0] + "," + r3[1] + "," + n2[0] + "," + n2[1];
          }(this.x, this.y, this.z), r2 = function(e3, t3, i3) {
            let r3, n2 = "";
            for (let o2 = e3; o2 > 0; o2--)
              r3 = 1 << o2 - 1, n2 += (t3 & r3 ? 1 : 0) + (i3 & r3 ? 2 : 0);
            return n2;
          }(this.z, this.x, this.y);
          return e2[(this.x + this.y) % e2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === t2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", r2).replace("{bbox-epsg-3857}", i2);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class UnwrappedTileID {
        constructor(e2, t2) {
          this.wrap = e2, this.canonical = t2, this.key = Xl(e2, t2.z, t2.z, t2.x, t2.y);
        }
      }
      class OverscaledTileID {
        constructor(e2, t2, i2, r2, n2) {
          this.overscaledZ = e2, this.wrap = t2, this.canonical = new CanonicalTileID(i2, +r2, +n2), this.key = 0 === t2 && e2 === i2 ? this.canonical.key : Xl(t2, e2, i2, r2, n2);
        }
        equals(e2) {
          return this.overscaledZ === e2.overscaledZ && this.wrap === e2.wrap && this.canonical.equals(e2.canonical);
        }
        scaledTo(e2) {
          const t2 = this.canonical.z - e2;
          return e2 > this.canonical.z ? new OverscaledTileID(e2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new OverscaledTileID(e2, this.wrap, e2, this.canonical.x >> t2, this.canonical.y >> t2);
        }
        calculateScaledKey(e2, t2 = true) {
          if (this.overscaledZ === e2 && t2)
            return this.key;
          if (e2 > this.canonical.z)
            return Xl(this.wrap * +t2, e2, this.canonical.z, this.canonical.x, this.canonical.y);
          {
            const i2 = this.canonical.z - e2;
            return Xl(this.wrap * +t2, e2, e2, this.canonical.x >> i2, this.canonical.y >> i2);
          }
        }
        isChildOf(e2) {
          if (e2.wrap !== this.wrap)
            return false;
          const t2 = this.canonical.z - e2.canonical.z;
          return 0 === e2.overscaledZ || e2.overscaledZ < this.overscaledZ && e2.canonical.x === this.canonical.x >> t2 && e2.canonical.y === this.canonical.y >> t2;
        }
        children(e2) {
          if (this.overscaledZ >= e2)
            return [new OverscaledTileID(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const t2 = this.canonical.z + 1, i2 = 2 * this.canonical.x, r2 = 2 * this.canonical.y;
          return [new OverscaledTileID(t2, this.wrap, t2, i2, r2), new OverscaledTileID(t2, this.wrap, t2, i2 + 1, r2), new OverscaledTileID(t2, this.wrap, t2, i2, r2 + 1), new OverscaledTileID(t2, this.wrap, t2, i2 + 1, r2 + 1)];
        }
        isLessThan(e2) {
          return this.wrap < e2.wrap || !(this.wrap > e2.wrap) && (this.overscaledZ < e2.overscaledZ || !(this.overscaledZ > e2.overscaledZ) && (this.canonical.x < e2.canonical.x || !(this.canonical.x > e2.canonical.x) && this.canonical.y < e2.canonical.y));
        }
        wrapped() {
          return new OverscaledTileID(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(e2) {
          return new OverscaledTileID(this.overscaledZ, e2, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new UnwrappedTileID(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
      }
      function Xl(e2, t2, i2, r2, n2) {
        const o2 = 1 << Math.min(i2, 22);
        let s2 = o2 * (n2 % o2) + r2 % o2;
        return e2 && i2 < 22 && (s2 += o2 * o2 * ((e2 < 0 ? -2 * e2 - 1 : 2 * e2) % (1 << 2 * (22 - i2)))), 16 * (32 * s2 + i2) + (t2 - i2);
      }
      kn(CanonicalTileID, "CanonicalTileID"), kn(OverscaledTileID, "OverscaledTileID", { omit: ["projMatrix"] });
      class Point3D extends d {
        constructor(e2, t2, i2) {
          super(e2, t2), this.z = i2;
        }
      }
      function Kl(e2, t2) {
        return e2.x * t2.x + e2.y * t2.y;
      }
      function Yl(e2, t2) {
        if (1 === e2.length) {
          let i2 = 0;
          const r2 = t2[i2++];
          let n2;
          for (; !n2 || r2.equals(n2); )
            if (n2 = t2[i2++], !n2)
              return 1 / 0;
          for (; i2 < t2.length; i2++) {
            const o2 = t2[i2], s2 = e2[0], a2 = n2.sub(r2), l2 = o2.sub(r2), c2 = s2.sub(r2), u2 = Kl(a2, a2), h2 = Kl(a2, l2), p2 = Kl(l2, l2), d2 = Kl(c2, a2), f2 = Kl(c2, l2), m2 = u2 * p2 - h2 * h2, _2 = (p2 * d2 - h2 * f2) / m2, g2 = (u2 * f2 - h2 * d2) / m2, y2 = r2.z * (1 - _2 - g2) + n2.z * _2 + o2.z * g2;
            if (isFinite(y2))
              return y2;
          }
          return 1 / 0;
        }
        {
          let e3 = 1 / 0;
          for (const i2 of t2)
            e3 = Math.min(e3, i2.z);
          return e3;
        }
      }
      function Jl(e2, t2, i2, r2, n2, o2, s2, a2) {
        const l2 = s2 * n2.getElevationAt(e2, t2, true, true), c2 = 0 !== o2[0], u2 = c2 ? 0 === o2[1] ? s2 * (o2[0] / 7 - 450) : s2 * function(e3, t3, i3) {
          const r3 = Math.floor(t3[0] / 8), n3 = Math.floor(t3[1] / 8), o3 = 10 * (t3[0] - 8 * r3), s3 = 10 * (t3[1] - 8 * n3), a3 = e3.getElevationAt(r3, n3, true, true), l3 = e3.getMeterToDEM(i3), c3 = Math.floor(0.5 * (o3 * l3 - 1)), u3 = Math.floor(0.5 * (s3 * l3 - 1)), h2 = e3.tileCoordToPixel(r3, n3), p2 = 2 * c3 + 1, d2 = 2 * u3 + 1, f2 = function(e4, t4, i4, r4, n4) {
            return [e4.getElevationAtPixel(t4, i4, true), e4.getElevationAtPixel(t4 + n4, i4, true), e4.getElevationAtPixel(t4, i4 + n4, true), e4.getElevationAtPixel(t4 + r4, i4 + n4, true)];
          }(e3, h2.x - c3, h2.y - u3, p2, d2), m2 = Math.abs(f2[0] - f2[1]), _2 = Math.abs(f2[2] - f2[3]), g2 = Math.abs(f2[0] - f2[2]) + Math.abs(f2[1] - f2[3]), y2 = Math.min(0.25, 0.5 * l3 * (m2 + _2) / p2), x2 = Math.min(0.25, 0.5 * l3 * g2 / d2);
          return a3 + Math.max(y2 * o3, x2 * s3);
        }(n2, o2, a2) : l2;
        return { base: l2 + (0 === i2) ? -1 : i2, top: c2 ? Math.max(u2 + r2, l2 + i2 + 2) : l2 + r2 };
      }
      const Ql = co([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: ec } = Ql, tc = co([{ name: "a_packed", components: 4, type: "Float32" }]), { members: ic } = tc, rc = zl.types, nc = Math.cos(Math.PI / 180 * 37.5);
      class LineBucket {
        constructor(e2) {
          this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((e3) => e3.id), this.index = e2.index, this.projection = e2.projection, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((e3) => {
            this.gradients[e3.id] = {};
          }), this.layoutVertexArray = new StructArrayLayout2i4ub1f12(), this.layoutVertexArray2 = new StructArrayLayout4f16(), this.indexArray = new StructArrayLayout3ui6(), this.programConfigurations = new ProgramConfigurationSet(e2.layers, e2.zoom), this.segments = new SegmentVector(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((e3) => e3.isStateDependent()).map((e3) => e3.id);
        }
        populate(e2, t2, i2, r2) {
          this.hasPattern = pl("line", this.layers, t2);
          const n2 = this.layers[0].layout.get("line-sort-key"), o2 = [];
          for (const { feature: t3, id: s3, index: a3, sourceLayerIndex: l3 } of e2) {
            const e3 = this.layers[0]._featureFilter.needGeometry, c2 = es(t3, e3);
            if (!this.layers[0]._featureFilter.filter(new EvaluationParameters(this.zoom), c2, i2))
              continue;
            const u2 = n2 ? n2.evaluate(c2, {}, i2) : void 0, h2 = { id: s3, properties: t3.properties, type: t3.type, sourceLayerIndex: l3, index: a3, geometry: e3 ? c2.geometry : Qo(t3, i2, r2), patterns: {}, sortKey: u2 };
            o2.push(h2);
          }
          n2 && o2.sort((e3, t3) => e3.sortKey - t3.sortKey);
          const { lineAtlas: s2, featureIndex: a2 } = t2, l2 = this.addConstantDashes(s2);
          for (const r3 of o2) {
            const { geometry: n3, index: o3, sourceLayerIndex: c2 } = r3;
            if (l2 && this.addFeatureDashes(r3, s2), this.hasPattern) {
              const e3 = dl("line", this.layers, r3, this.zoom, t2);
              this.patternFeatures.push(e3);
            } else
              this.addFeature(r3, n3, o3, i2, s2.positions, t2.availableImages);
            a2.insert(e2[o3].feature, n3, o3, c2, this.index);
          }
        }
        addConstantDashes(e2) {
          let t2 = false;
          for (const i2 of this.layers) {
            const r2 = i2.paint.get("line-dasharray").value, n2 = i2.layout.get("line-cap").value;
            if ("constant" !== r2.kind || "constant" !== n2.kind)
              t2 = true;
            else {
              const t3 = n2.value, i3 = r2.value;
              if (!i3)
                continue;
              e2.addDash(i3, t3);
            }
          }
          return t2;
        }
        addFeatureDashes(e2, t2) {
          const i2 = this.zoom;
          for (const r2 of this.layers) {
            const n2 = r2.paint.get("line-dasharray").value, o2 = r2.layout.get("line-cap").value;
            if ("constant" === n2.kind && "constant" === o2.kind)
              continue;
            let s2, a2;
            if ("constant" === n2.kind) {
              if (s2 = n2.value, !s2)
                continue;
            } else
              s2 = n2.evaluate({ zoom: i2 }, e2);
            a2 = "constant" === o2.kind ? o2.value : o2.evaluate({ zoom: i2 }, e2), t2.addDash(s2, a2), e2.patterns[r2.id] = t2.getKey(s2, a2);
          }
        }
        update(e2, t2, i2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e2, t2, this.stateDependentLayers, i2, r2);
        }
        addFeatures(e2, t2, i2, r2, n2) {
          for (const e3 of this.patternFeatures)
            this.addFeature(e3, e3.geometry, e3.index, t2, i2, r2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e2) {
          this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = e2.createVertexBuffer(this.layoutVertexArray2, ic)), this.layoutVertexBuffer = e2.createVertexBuffer(this.layoutVertexArray, ec), this.indexBuffer = e2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(e2) {
          if (e2.properties && e2.properties.hasOwnProperty("mapbox_clip_start") && e2.properties.hasOwnProperty("mapbox_clip_end"))
            return { start: +e2.properties.mapbox_clip_start, end: +e2.properties.mapbox_clip_end };
        }
        addFeature(e2, t2, i2, r2, n2, o2) {
          const s2 = this.layers[0].layout, a2 = s2.get("line-join").evaluate(e2, {}), l2 = s2.get("line-cap").evaluate(e2, {}), c2 = s2.get("line-miter-limit"), u2 = s2.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(e2);
          for (const i3 of t2)
            this.addLine(i3, e2, a2, l2, c2, u2);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e2, i2, n2, o2, r2);
        }
        addLine(e2, t2, i2, r2, n2, o2) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let t3 = 0; t3 < e2.length - 1; t3++)
              this.totalDistance += e2[t3].dist(e2[t3 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const s2 = "Polygon" === rc[t2.type];
          let a2 = e2.length;
          for (; a2 >= 2 && e2[a2 - 1].equals(e2[a2 - 2]); )
            a2--;
          let l2 = 0;
          for (; l2 < a2 - 1 && e2[l2].equals(e2[l2 + 1]); )
            l2++;
          if (a2 < (s2 ? 3 : 2))
            return;
          "bevel" === i2 && (n2 = 1.05);
          const c2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, u2 = this.segments.prepareSegment(10 * a2, this.layoutVertexArray, this.indexArray);
          let h2, p2, d2, f2, m2;
          this.e1 = this.e2 = -1, s2 && (h2 = e2[a2 - 2], m2 = e2[l2].sub(h2)._unit()._perp());
          for (let t3 = l2; t3 < a2; t3++) {
            if (d2 = t3 === a2 - 1 ? s2 ? e2[l2 + 1] : void 0 : e2[t3 + 1], d2 && e2[t3].equals(d2))
              continue;
            m2 && (f2 = m2), h2 && (p2 = h2), h2 = e2[t3], m2 = d2 ? d2.sub(h2)._unit()._perp() : f2, f2 = f2 || m2;
            let _2 = f2.add(m2);
            0 === _2.x && 0 === _2.y || _2._unit();
            const g2 = f2.x * m2.x + f2.y * m2.y, y2 = _2.x * m2.x + _2.y * m2.y, x2 = 0 !== y2 ? 1 / y2 : 1 / 0, v2 = 2 * Math.sqrt(2 - 2 * y2), b2 = y2 < nc && p2 && d2, w2 = f2.x * m2.y - f2.y * m2.x > 0;
            if (b2 && t3 > l2) {
              const e3 = h2.dist(p2);
              if (e3 > 2 * c2) {
                const t4 = h2.sub(h2.sub(p2)._mult(c2 / e3)._round());
                this.updateDistance(p2, t4), this.addCurrentVertex(t4, f2, 0, 0, u2), p2 = t4;
              }
            }
            const T2 = p2 && d2;
            let E2 = T2 ? i2 : s2 ? "butt" : r2;
            if (T2 && "round" === E2 && (x2 < o2 ? E2 = "miter" : x2 <= 2 && (E2 = "fakeround")), "miter" === E2 && x2 > n2 && (E2 = "bevel"), "bevel" === E2 && (x2 > 2 && (E2 = "flipbevel"), x2 < n2 && (E2 = "miter")), p2 && this.updateDistance(p2, h2), "miter" === E2)
              _2._mult(x2), this.addCurrentVertex(h2, _2, 0, 0, u2);
            else if ("flipbevel" === E2) {
              if (x2 > 100)
                _2 = m2.mult(-1);
              else {
                const e3 = x2 * f2.add(m2).mag() / f2.sub(m2).mag();
                _2._perp()._mult(e3 * (w2 ? -1 : 1));
              }
              this.addCurrentVertex(h2, _2, 0, 0, u2), this.addCurrentVertex(h2, _2.mult(-1), 0, 0, u2);
            } else if ("bevel" === E2 || "fakeround" === E2) {
              const e3 = -Math.sqrt(x2 * x2 - 1), t4 = w2 ? e3 : 0, i3 = w2 ? 0 : e3;
              if (p2 && this.addCurrentVertex(h2, f2, t4, i3, u2), "fakeround" === E2) {
                const e4 = Math.round(180 * v2 / Math.PI / 20);
                for (let t5 = 1; t5 < e4; t5++) {
                  let i4 = t5 / e4;
                  if (0.5 !== i4) {
                    const e5 = i4 - 0.5;
                    i4 += i4 * e5 * (i4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * e5 * e5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                  }
                  const r3 = m2.sub(f2)._mult(i4)._add(f2)._unit()._mult(w2 ? -1 : 1);
                  this.addHalfVertex(h2, r3.x, r3.y, false, w2, 0, u2);
                }
              }
              d2 && this.addCurrentVertex(h2, m2, -t4, -i3, u2);
            } else if ("butt" === E2)
              this.addCurrentVertex(h2, _2, 0, 0, u2);
            else if ("square" === E2) {
              const e3 = p2 ? 1 : -1;
              p2 || this.addCurrentVertex(h2, _2, e3, e3, u2), this.addCurrentVertex(h2, _2, 0, 0, u2), p2 && this.addCurrentVertex(h2, _2, e3, e3, u2);
            } else
              "round" === E2 && (p2 && (this.addCurrentVertex(h2, f2, 0, 0, u2), this.addCurrentVertex(h2, f2, 1, 1, u2, true)), d2 && (this.addCurrentVertex(h2, m2, -1, -1, u2, true), this.addCurrentVertex(h2, m2, 0, 0, u2)));
            if (b2 && t3 < a2 - 1) {
              const e3 = h2.dist(d2);
              if (e3 > 2 * c2) {
                const t4 = h2.add(d2.sub(h2)._mult(c2 / e3)._round());
                this.updateDistance(h2, t4), this.addCurrentVertex(t4, m2, 0, 0, u2), h2 = t4;
              }
            }
          }
        }
        addCurrentVertex(e2, t2, i2, r2, n2, o2 = false) {
          const s2 = t2.y * r2 - t2.x, a2 = -t2.y - t2.x * r2;
          this.addHalfVertex(e2, t2.x + t2.y * i2, t2.y - t2.x * i2, o2, false, i2, n2), this.addHalfVertex(e2, s2, a2, o2, true, -r2, n2);
        }
        addHalfVertex({ x: e2, y: t2 }, i2, r2, n2, o2, s2, a2) {
          this.layoutVertexArray.emplaceBack((e2 << 1) + (n2 ? 1 : 0), (t2 << 1) + (o2 ? 1 : 0), Math.round(63 * i2) + 128, Math.round(63 * r2) + 128, 1 + (0 === s2 ? 0 : s2 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
          const l2 = a2.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l2), a2.primitiveLength++), o2 ? this.e2 = l2 : this.e1 = l2;
        }
        updateScaledDistance() {
          if (this.lineClips) {
            const e2 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
            this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = e2 * this.lineClips.start + this.distance;
          } else
            this.lineSoFar = this.distance;
        }
        updateDistance(e2, t2) {
          this.distance += e2.dist(t2), this.updateScaledDistance();
        }
      }
      kn(LineBucket, "LineBucket", { omit: ["layers", "patternFeatures"] });
      const oc = new Properties({ "line-cap": new DataDrivenProperty(ft.layout_line["line-cap"]), "line-join": new DataDrivenProperty(ft.layout_line["line-join"]), "line-miter-limit": new DataConstantProperty(ft.layout_line["line-miter-limit"]), "line-round-limit": new DataConstantProperty(ft.layout_line["line-round-limit"]), "line-sort-key": new DataDrivenProperty(ft.layout_line["line-sort-key"]) });
      var sc = { paint: new Properties({ "line-opacity": new DataDrivenProperty(ft.paint_line["line-opacity"]), "line-color": new DataDrivenProperty(ft.paint_line["line-color"]), "line-translate": new DataConstantProperty(ft.paint_line["line-translate"]), "line-translate-anchor": new DataConstantProperty(ft.paint_line["line-translate-anchor"]), "line-width": new DataDrivenProperty(ft.paint_line["line-width"]), "line-gap-width": new DataDrivenProperty(ft.paint_line["line-gap-width"]), "line-offset": new DataDrivenProperty(ft.paint_line["line-offset"]), "line-blur": new DataDrivenProperty(ft.paint_line["line-blur"]), "line-dasharray": new DataDrivenProperty(ft.paint_line["line-dasharray"]), "line-pattern": new DataDrivenProperty(ft.paint_line["line-pattern"]), "line-gradient": new ColorRampProperty(ft.paint_line["line-gradient"]), "line-trim-offset": new DataConstantProperty(ft.paint_line["line-trim-offset"]) }), layout: oc };
      const ac = new class LineFloorwidthProperty extends DataDrivenProperty {
        possiblyEvaluate(e2, t2) {
          return t2 = new EvaluationParameters(Math.floor(t2.zoom), { now: t2.now, fadeDuration: t2.fadeDuration, transition: t2.transition }), super.possiblyEvaluate(e2, t2);
        }
        evaluate(e2, t2, i2, r2) {
          return t2 = P({}, t2, { zoom: Math.floor(t2.zoom) }), super.evaluate(e2, t2, i2, r2);
        }
      }(sc.paint.properties["line-width"].specification);
      function lc(e2, t2) {
        return t2 > 0 ? t2 + 2 * e2 : e2;
      }
      ac.useIntegerZoom = true;
      const cc = co([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), uc = co([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), hc = co([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
      co([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const pc = co([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), dc = co([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]);
      co([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const fc = co([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), mc = co([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      co([{ name: "triangle", components: 3, type: "Uint16" }]), co([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), co([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), co([{ type: "Float32", name: "offsetX" }]), co([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
      const _c = 128;
      function gc(e2, t2) {
        const { expression: i2 } = t2;
        if ("constant" === i2.kind)
          return { kind: "constant", layoutSize: i2.evaluate(new EvaluationParameters(e2 + 1)) };
        if ("source" === i2.kind)
          return { kind: "source" };
        {
          const { zoomStops: t3, interpolationType: r2 } = i2;
          let n2 = 0;
          for (; n2 < t3.length && t3[n2] <= e2; )
            n2++;
          n2 = Math.max(0, n2 - 1);
          let o2 = n2;
          for (; o2 < t3.length && t3[o2] < e2 + 1; )
            o2++;
          o2 = Math.min(t3.length - 1, o2);
          const s2 = t3[n2], a2 = t3[o2];
          return "composite" === i2.kind ? { kind: "composite", minZoom: s2, maxZoom: a2, interpolationType: r2 } : { kind: "camera", minZoom: s2, maxZoom: a2, minSize: i2.evaluate(new EvaluationParameters(s2)), maxSize: i2.evaluate(new EvaluationParameters(a2)), interpolationType: r2 };
        }
      }
      function yc(e2, { uSize: t2, uSizeT: i2 }, { lowerSize: r2, upperSize: n2 }) {
        return "source" === e2.kind ? r2 / _c : "composite" === e2.kind ? Ii(r2 / _c, n2 / _c, i2) : t2;
      }
      function xc(e2, t2) {
        let i2 = 0, r2 = 0;
        if ("constant" === e2.kind)
          r2 = e2.layoutSize;
        else if ("source" !== e2.kind) {
          const { interpolationType: n2, minZoom: o2, maxZoom: s2 } = e2, a2 = n2 ? A(Hi.interpolationFactor(n2, t2, o2, s2), 0, 1) : 0;
          "camera" === e2.kind ? r2 = Ii(e2.minSize, e2.maxSize, a2) : i2 = a2;
        }
        return { uSizeT: i2, uSize: r2 };
      }
      var vc = Object.freeze({ __proto__: null, getSizeData: gc, evaluateSizeForFeature: yc, evaluateSizeForZoom: xc, SIZE_PACK_FACTOR: _c });
      function bc(e2, t2, i2) {
        return e2.sections.forEach((e3) => {
          e3.text = function(e4, t3, i3) {
            const r2 = t3.layout.get("text-transform").evaluate(i3, {});
            return "uppercase" === r2 ? e4 = e4.toLocaleUpperCase() : "lowercase" === r2 && (e4 = e4.toLocaleLowerCase()), e4;
          }(e3.text, t2, i2);
        }), e2;
      }
      const wc = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
      var Tc = {
        read: function(e2, t2, i2, r2, n2) {
          var o2, s2, a2 = 8 * n2 - r2 - 1, l2 = (1 << a2) - 1, c2 = l2 >> 1, u2 = -7, h2 = i2 ? n2 - 1 : 0, p2 = i2 ? -1 : 1, d2 = e2[t2 + h2];
          for (h2 += p2, o2 = d2 & (1 << -u2) - 1, d2 >>= -u2, u2 += a2; u2 > 0; o2 = 256 * o2 + e2[t2 + h2], h2 += p2, u2 -= 8)
            ;
          for (s2 = o2 & (1 << -u2) - 1, o2 >>= -u2, u2 += r2; u2 > 0; s2 = 256 * s2 + e2[t2 + h2], h2 += p2, u2 -= 8)
            ;
          if (0 === o2)
            o2 = 1 - c2;
          else {
            if (o2 === l2)
              return s2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
            s2 += Math.pow(2, r2), o2 -= c2;
          }
          return (d2 ? -1 : 1) * s2 * Math.pow(2, o2 - r2);
        },
        write: function(e2, t2, i2, r2, n2, o2) {
          var s2, a2, l2, c2 = 8 * o2 - n2 - 1, u2 = (1 << c2) - 1, h2 = u2 >> 1, p2 = 23 === n2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = r2 ? 0 : o2 - 1, f2 = r2 ? 1 : -1, m2 = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
          for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (a2 = isNaN(t2) ? 1 : 0, s2 = u2) : (s2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (l2 = Math.pow(2, -s2)) < 1 && (s2--, l2 *= 2), (t2 += s2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (s2++, l2 /= 2), s2 + h2 >= u2 ? (a2 = 0, s2 = u2) : s2 + h2 >= 1 ? (a2 = (t2 * l2 - 1) * Math.pow(2, n2), s2 += h2) : (a2 = t2 * Math.pow(2, h2 - 1) * Math.pow(2, n2), s2 = 0)); n2 >= 8; e2[i2 + d2] = 255 & a2, d2 += f2, a2 /= 256, n2 -= 8)
            ;
          for (s2 = s2 << n2 | a2, c2 += n2; c2 > 0; e2[i2 + d2] = 255 & s2, d2 += f2, s2 /= 256, c2 -= 8)
            ;
          e2[i2 + d2 - f2] |= 128 * m2;
        }
      }, Ec = Ac, Sc = Tc;
      function Ac(e2) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(e2) ? e2 : new Uint8Array(e2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      Ac.Varint = 0, Ac.Fixed64 = 1, Ac.Bytes = 2, Ac.Fixed32 = 5;
      var Cc = 4294967296, Ic = 1 / Cc, Mc = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
      function Dc(e2) {
        return e2.type === Ac.Bytes ? e2.readVarint() + e2.pos : e2.pos + 1;
      }
      function Pc(e2, t2, i2) {
        return i2 ? 4294967296 * t2 + (e2 >>> 0) : 4294967296 * (t2 >>> 0) + (e2 >>> 0);
      }
      function zc(e2, t2, i2) {
        var r2 = t2 <= 16383 ? 1 : t2 <= 2097151 ? 2 : t2 <= 268435455 ? 3 : Math.floor(Math.log(t2) / (7 * Math.LN2));
        i2.realloc(r2);
        for (var n2 = i2.pos - 1; n2 >= e2; n2--)
          i2.buf[n2 + r2] = i2.buf[n2];
      }
      function Lc(e2, t2) {
        for (var i2 = 0; i2 < e2.length; i2++)
          t2.writeVarint(e2[i2]);
      }
      function kc(e2, t2) {
        for (var i2 = 0; i2 < e2.length; i2++)
          t2.writeSVarint(e2[i2]);
      }
      function Bc(e2, t2) {
        for (var i2 = 0; i2 < e2.length; i2++)
          t2.writeFloat(e2[i2]);
      }
      function Rc(e2, t2) {
        for (var i2 = 0; i2 < e2.length; i2++)
          t2.writeDouble(e2[i2]);
      }
      function Fc(e2, t2) {
        for (var i2 = 0; i2 < e2.length; i2++)
          t2.writeBoolean(e2[i2]);
      }
      function Oc(e2, t2) {
        for (var i2 = 0; i2 < e2.length; i2++)
          t2.writeFixed32(e2[i2]);
      }
      function Uc(e2, t2) {
        for (var i2 = 0; i2 < e2.length; i2++)
          t2.writeSFixed32(e2[i2]);
      }
      function Vc(e2, t2) {
        for (var i2 = 0; i2 < e2.length; i2++)
          t2.writeFixed64(e2[i2]);
      }
      function jc(e2, t2) {
        for (var i2 = 0; i2 < e2.length; i2++)
          t2.writeSFixed64(e2[i2]);
      }
      function Nc(e2, t2) {
        return (e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16) + 16777216 * e2[t2 + 3];
      }
      function Gc(e2, t2, i2) {
        e2[i2] = t2, e2[i2 + 1] = t2 >>> 8, e2[i2 + 2] = t2 >>> 16, e2[i2 + 3] = t2 >>> 24;
      }
      function qc(e2, t2) {
        return (e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16) + (e2[t2 + 3] << 24);
      }
      function Zc(e2, t2, i2) {
        t2.glyphs = [], 1 === e2 && i2.readMessage($c, t2);
      }
      function $c(e2, t2, i2) {
        if (3 === e2) {
          const { id: e3, bitmap: r2, width: n2, height: o2, left: s2, top: a2, advance: l2 } = i2.readMessage(Wc, {});
          t2.glyphs.push({ id: e3, bitmap: new AlphaImage({ width: n2 + 6, height: o2 + 6 }, r2), metrics: { width: n2, height: o2, left: s2, top: a2, advance: l2 } });
        } else
          4 === e2 ? t2.ascender = i2.readSVarint() : 5 === e2 && (t2.descender = i2.readSVarint());
      }
      function Wc(e2, t2, i2) {
        1 === e2 ? t2.id = i2.readVarint() : 2 === e2 ? t2.bitmap = i2.readBytes() : 3 === e2 ? t2.width = i2.readVarint() : 4 === e2 ? t2.height = i2.readVarint() : 5 === e2 ? t2.left = i2.readSVarint() : 6 === e2 ? t2.top = i2.readSVarint() : 7 === e2 && (t2.advance = i2.readVarint());
      }
      function Hc(e2) {
        let t2 = 0, i2 = 0;
        for (const r3 of e2)
          t2 += r3.w * r3.h, i2 = Math.max(i2, r3.w);
        e2.sort((e3, t3) => t3.h - e3.h);
        const r2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t2 / 0.95)), i2), h: 1 / 0 }];
        let n2 = 0, o2 = 0;
        for (const t3 of e2)
          for (let e3 = r2.length - 1; e3 >= 0; e3--) {
            const i3 = r2[e3];
            if (!(t3.w > i3.w || t3.h > i3.h)) {
              if (t3.x = i3.x, t3.y = i3.y, o2 = Math.max(o2, t3.y + t3.h), n2 = Math.max(n2, t3.x + t3.w), t3.w === i3.w && t3.h === i3.h) {
                const t4 = r2.pop();
                e3 < r2.length && (r2[e3] = t4);
              } else
                t3.h === i3.h ? (i3.x += t3.w, i3.w -= t3.w) : t3.w === i3.w ? (i3.y += t3.h, i3.h -= t3.h) : (r2.push({ x: i3.x + t3.w, y: i3.y, w: i3.w - t3.w, h: t3.h }), i3.y += t3.h, i3.h -= t3.h);
              break;
            }
          }
        return { w: n2, h: o2, fill: t2 / (n2 * o2) || 0 };
      }
      Ac.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(e2, t2, i2) {
        for (i2 = i2 || this.length; this.pos < i2; ) {
          var r2 = this.readVarint(), n2 = r2 >> 3, o2 = this.pos;
          this.type = 7 & r2, e2(n2, t2, this), this.pos === o2 && this.skip(r2);
        }
        return t2;
      }, readMessage: function(e2, t2) {
        return this.readFields(e2, t2, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var e2 = Nc(this.buf, this.pos);
        return this.pos += 4, e2;
      }, readSFixed32: function() {
        var e2 = qc(this.buf, this.pos);
        return this.pos += 4, e2;
      }, readFixed64: function() {
        var e2 = Nc(this.buf, this.pos) + Nc(this.buf, this.pos + 4) * Cc;
        return this.pos += 8, e2;
      }, readSFixed64: function() {
        var e2 = Nc(this.buf, this.pos) + qc(this.buf, this.pos + 4) * Cc;
        return this.pos += 8, e2;
      }, readFloat: function() {
        var e2 = Sc.read(this.buf, this.pos, true, 23, 4);
        return this.pos += 4, e2;
      }, readDouble: function() {
        var e2 = Sc.read(this.buf, this.pos, true, 52, 8);
        return this.pos += 8, e2;
      }, readVarint: function(e2) {
        var t2, i2, r2 = this.buf;
        return t2 = 127 & (i2 = r2[this.pos++]), i2 < 128 ? t2 : (t2 |= (127 & (i2 = r2[this.pos++])) << 7, i2 < 128 ? t2 : (t2 |= (127 & (i2 = r2[this.pos++])) << 14, i2 < 128 ? t2 : (t2 |= (127 & (i2 = r2[this.pos++])) << 21, i2 < 128 ? t2 : function(e3, t3, i3) {
          var r3, n2, o2 = i3.buf;
          if (r3 = (112 & (n2 = o2[i3.pos++])) >> 4, n2 < 128)
            return Pc(e3, r3, t3);
          if (r3 |= (127 & (n2 = o2[i3.pos++])) << 3, n2 < 128)
            return Pc(e3, r3, t3);
          if (r3 |= (127 & (n2 = o2[i3.pos++])) << 10, n2 < 128)
            return Pc(e3, r3, t3);
          if (r3 |= (127 & (n2 = o2[i3.pos++])) << 17, n2 < 128)
            return Pc(e3, r3, t3);
          if (r3 |= (127 & (n2 = o2[i3.pos++])) << 24, n2 < 128)
            return Pc(e3, r3, t3);
          if (r3 |= (1 & (n2 = o2[i3.pos++])) << 31, n2 < 128)
            return Pc(e3, r3, t3);
          throw new Error("Expected varint not more than 10 bytes");
        }(t2 |= (15 & (i2 = r2[this.pos])) << 28, e2, this))));
      }, readVarint64: function() {
        return this.readVarint(true);
      }, readSVarint: function() {
        var e2 = this.readVarint();
        return e2 % 2 == 1 ? (e2 + 1) / -2 : e2 / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var e2 = this.readVarint() + this.pos, t2 = this.pos;
        return this.pos = e2, e2 - t2 >= 12 && Mc ? function(e3, t3, i2) {
          return Mc.decode(e3.subarray(t3, i2));
        }(this.buf, t2, e2) : function(e3, t3, i2) {
          for (var r2 = "", n2 = t3; n2 < i2; ) {
            var o2, s2, a2, l2 = e3[n2], c2 = null, u2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
            if (n2 + u2 > i2)
              break;
            1 === u2 ? l2 < 128 && (c2 = l2) : 2 === u2 ? 128 == (192 & (o2 = e3[n2 + 1])) && (c2 = (31 & l2) << 6 | 63 & o2) <= 127 && (c2 = null) : 3 === u2 ? (s2 = e3[n2 + 2], 128 == (192 & (o2 = e3[n2 + 1])) && 128 == (192 & s2) && ((c2 = (15 & l2) << 12 | (63 & o2) << 6 | 63 & s2) <= 2047 || c2 >= 55296 && c2 <= 57343) && (c2 = null)) : 4 === u2 && (s2 = e3[n2 + 2], a2 = e3[n2 + 3], 128 == (192 & (o2 = e3[n2 + 1])) && 128 == (192 & s2) && 128 == (192 & a2) && ((c2 = (15 & l2) << 18 | (63 & o2) << 12 | (63 & s2) << 6 | 63 & a2) <= 65535 || c2 >= 1114112) && (c2 = null)), null === c2 ? (c2 = 65533, u2 = 1) : c2 > 65535 && (c2 -= 65536, r2 += String.fromCharCode(c2 >>> 10 & 1023 | 55296), c2 = 56320 | 1023 & c2), r2 += String.fromCharCode(c2), n2 += u2;
          }
          return r2;
        }(this.buf, t2, e2);
      }, readBytes: function() {
        var e2 = this.readVarint() + this.pos, t2 = this.buf.subarray(this.pos, e2);
        return this.pos = e2, t2;
      }, readPackedVarint: function(e2, t2) {
        if (this.type !== Ac.Bytes)
          return e2.push(this.readVarint(t2));
        var i2 = Dc(this);
        for (e2 = e2 || []; this.pos < i2; )
          e2.push(this.readVarint(t2));
        return e2;
      }, readPackedSVarint: function(e2) {
        if (this.type !== Ac.Bytes)
          return e2.push(this.readSVarint());
        var t2 = Dc(this);
        for (e2 = e2 || []; this.pos < t2; )
          e2.push(this.readSVarint());
        return e2;
      }, readPackedBoolean: function(e2) {
        if (this.type !== Ac.Bytes)
          return e2.push(this.readBoolean());
        var t2 = Dc(this);
        for (e2 = e2 || []; this.pos < t2; )
          e2.push(this.readBoolean());
        return e2;
      }, readPackedFloat: function(e2) {
        if (this.type !== Ac.Bytes)
          return e2.push(this.readFloat());
        var t2 = Dc(this);
        for (e2 = e2 || []; this.pos < t2; )
          e2.push(this.readFloat());
        return e2;
      }, readPackedDouble: function(e2) {
        if (this.type !== Ac.Bytes)
          return e2.push(this.readDouble());
        var t2 = Dc(this);
        for (e2 = e2 || []; this.pos < t2; )
          e2.push(this.readDouble());
        return e2;
      }, readPackedFixed32: function(e2) {
        if (this.type !== Ac.Bytes)
          return e2.push(this.readFixed32());
        var t2 = Dc(this);
        for (e2 = e2 || []; this.pos < t2; )
          e2.push(this.readFixed32());
        return e2;
      }, readPackedSFixed32: function(e2) {
        if (this.type !== Ac.Bytes)
          return e2.push(this.readSFixed32());
        var t2 = Dc(this);
        for (e2 = e2 || []; this.pos < t2; )
          e2.push(this.readSFixed32());
        return e2;
      }, readPackedFixed64: function(e2) {
        if (this.type !== Ac.Bytes)
          return e2.push(this.readFixed64());
        var t2 = Dc(this);
        for (e2 = e2 || []; this.pos < t2; )
          e2.push(this.readFixed64());
        return e2;
      }, readPackedSFixed64: function(e2) {
        if (this.type !== Ac.Bytes)
          return e2.push(this.readSFixed64());
        var t2 = Dc(this);
        for (e2 = e2 || []; this.pos < t2; )
          e2.push(this.readSFixed64());
        return e2;
      }, skip: function(e2) {
        var t2 = 7 & e2;
        if (t2 === Ac.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (t2 === Ac.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (t2 === Ac.Fixed32)
          this.pos += 4;
        else {
          if (t2 !== Ac.Fixed64)
            throw new Error("Unimplemented type: " + t2);
          this.pos += 8;
        }
      }, writeTag: function(e2, t2) {
        this.writeVarint(e2 << 3 | t2);
      }, realloc: function(e2) {
        for (var t2 = this.length || 16; t2 < this.pos + e2; )
          t2 *= 2;
        if (t2 !== this.length) {
          var i2 = new Uint8Array(t2);
          i2.set(this.buf), this.buf = i2, this.length = t2;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(e2) {
        this.realloc(4), Gc(this.buf, e2, this.pos), this.pos += 4;
      }, writeSFixed32: function(e2) {
        this.realloc(4), Gc(this.buf, e2, this.pos), this.pos += 4;
      }, writeFixed64: function(e2) {
        this.realloc(8), Gc(this.buf, -1 & e2, this.pos), Gc(this.buf, Math.floor(e2 * Ic), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(e2) {
        this.realloc(8), Gc(this.buf, -1 & e2, this.pos), Gc(this.buf, Math.floor(e2 * Ic), this.pos + 4), this.pos += 8;
      }, writeVarint: function(e2) {
        (e2 = +e2 || 0) > 268435455 || e2 < 0 ? function(e3, t2) {
          var i2, r2;
          if (e3 >= 0 ? (i2 = e3 % 4294967296 | 0, r2 = e3 / 4294967296 | 0) : (r2 = ~(-e3 / 4294967296), 4294967295 ^ (i2 = ~(-e3 % 4294967296)) ? i2 = i2 + 1 | 0 : (i2 = 0, r2 = r2 + 1 | 0)), e3 >= 18446744073709552e3 || e3 < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          t2.realloc(10), function(e4, t3, i3) {
            i3.buf[i3.pos++] = 127 & e4 | 128, e4 >>>= 7, i3.buf[i3.pos++] = 127 & e4 | 128, e4 >>>= 7, i3.buf[i3.pos++] = 127 & e4 | 128, e4 >>>= 7, i3.buf[i3.pos++] = 127 & e4 | 128, i3.buf[i3.pos] = 127 & (e4 >>>= 7);
          }(i2, 0, t2), function(e4, t3) {
            var i3 = (7 & e4) << 4;
            t3.buf[t3.pos++] |= i3 | ((e4 >>>= 3) ? 128 : 0), e4 && (t3.buf[t3.pos++] = 127 & e4 | ((e4 >>>= 7) ? 128 : 0), e4 && (t3.buf[t3.pos++] = 127 & e4 | ((e4 >>>= 7) ? 128 : 0), e4 && (t3.buf[t3.pos++] = 127 & e4 | ((e4 >>>= 7) ? 128 : 0), e4 && (t3.buf[t3.pos++] = 127 & e4 | ((e4 >>>= 7) ? 128 : 0), e4 && (t3.buf[t3.pos++] = 127 & e4)))));
          }(r2, t2);
        }(e2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e2 | (e2 > 127 ? 128 : 0), e2 <= 127 || (this.buf[this.pos++] = 127 & (e2 >>>= 7) | (e2 > 127 ? 128 : 0), e2 <= 127 || (this.buf[this.pos++] = 127 & (e2 >>>= 7) | (e2 > 127 ? 128 : 0), e2 <= 127 || (this.buf[this.pos++] = e2 >>> 7 & 127))));
      }, writeSVarint: function(e2) {
        this.writeVarint(e2 < 0 ? 2 * -e2 - 1 : 2 * e2);
      }, writeBoolean: function(e2) {
        this.writeVarint(Boolean(e2));
      }, writeString: function(e2) {
        e2 = String(e2), this.realloc(4 * e2.length), this.pos++;
        var t2 = this.pos;
        this.pos = function(e3, t3, i3) {
          for (var r2, n2, o2 = 0; o2 < t3.length; o2++) {
            if ((r2 = t3.charCodeAt(o2)) > 55295 && r2 < 57344) {
              if (!n2) {
                r2 > 56319 || o2 + 1 === t3.length ? (e3[i3++] = 239, e3[i3++] = 191, e3[i3++] = 189) : n2 = r2;
                continue;
              }
              if (r2 < 56320) {
                e3[i3++] = 239, e3[i3++] = 191, e3[i3++] = 189, n2 = r2;
                continue;
              }
              r2 = n2 - 55296 << 10 | r2 - 56320 | 65536, n2 = null;
            } else
              n2 && (e3[i3++] = 239, e3[i3++] = 191, e3[i3++] = 189, n2 = null);
            r2 < 128 ? e3[i3++] = r2 : (r2 < 2048 ? e3[i3++] = r2 >> 6 | 192 : (r2 < 65536 ? e3[i3++] = r2 >> 12 | 224 : (e3[i3++] = r2 >> 18 | 240, e3[i3++] = r2 >> 12 & 63 | 128), e3[i3++] = r2 >> 6 & 63 | 128), e3[i3++] = 63 & r2 | 128);
          }
          return i3;
        }(this.buf, e2, this.pos);
        var i2 = this.pos - t2;
        i2 >= 128 && zc(t2, i2, this), this.pos = t2 - 1, this.writeVarint(i2), this.pos += i2;
      }, writeFloat: function(e2) {
        this.realloc(4), Sc.write(this.buf, e2, this.pos, true, 23, 4), this.pos += 4;
      }, writeDouble: function(e2) {
        this.realloc(8), Sc.write(this.buf, e2, this.pos, true, 52, 8), this.pos += 8;
      }, writeBytes: function(e2) {
        var t2 = e2.length;
        this.writeVarint(t2), this.realloc(t2);
        for (var i2 = 0; i2 < t2; i2++)
          this.buf[this.pos++] = e2[i2];
      }, writeRawMessage: function(e2, t2) {
        this.pos++;
        var i2 = this.pos;
        e2(t2, this);
        var r2 = this.pos - i2;
        r2 >= 128 && zc(i2, r2, this), this.pos = i2 - 1, this.writeVarint(r2), this.pos += r2;
      }, writeMessage: function(e2, t2, i2) {
        this.writeTag(e2, Ac.Bytes), this.writeRawMessage(t2, i2);
      }, writePackedVarint: function(e2, t2) {
        t2.length && this.writeMessage(e2, Lc, t2);
      }, writePackedSVarint: function(e2, t2) {
        t2.length && this.writeMessage(e2, kc, t2);
      }, writePackedBoolean: function(e2, t2) {
        t2.length && this.writeMessage(e2, Fc, t2);
      }, writePackedFloat: function(e2, t2) {
        t2.length && this.writeMessage(e2, Bc, t2);
      }, writePackedDouble: function(e2, t2) {
        t2.length && this.writeMessage(e2, Rc, t2);
      }, writePackedFixed32: function(e2, t2) {
        t2.length && this.writeMessage(e2, Oc, t2);
      }, writePackedSFixed32: function(e2, t2) {
        t2.length && this.writeMessage(e2, Uc, t2);
      }, writePackedFixed64: function(e2, t2) {
        t2.length && this.writeMessage(e2, Vc, t2);
      }, writePackedSFixed64: function(e2, t2) {
        t2.length && this.writeMessage(e2, jc, t2);
      }, writeBytesField: function(e2, t2) {
        this.writeTag(e2, Ac.Bytes), this.writeBytes(t2);
      }, writeFixed32Field: function(e2, t2) {
        this.writeTag(e2, Ac.Fixed32), this.writeFixed32(t2);
      }, writeSFixed32Field: function(e2, t2) {
        this.writeTag(e2, Ac.Fixed32), this.writeSFixed32(t2);
      }, writeFixed64Field: function(e2, t2) {
        this.writeTag(e2, Ac.Fixed64), this.writeFixed64(t2);
      }, writeSFixed64Field: function(e2, t2) {
        this.writeTag(e2, Ac.Fixed64), this.writeSFixed64(t2);
      }, writeVarintField: function(e2, t2) {
        this.writeTag(e2, Ac.Varint), this.writeVarint(t2);
      }, writeSVarintField: function(e2, t2) {
        this.writeTag(e2, Ac.Varint), this.writeSVarint(t2);
      }, writeStringField: function(e2, t2) {
        this.writeTag(e2, Ac.Bytes), this.writeString(t2);
      }, writeFloatField: function(e2, t2) {
        this.writeTag(e2, Ac.Fixed32), this.writeFloat(t2);
      }, writeDoubleField: function(e2, t2) {
        this.writeTag(e2, Ac.Fixed64), this.writeDouble(t2);
      }, writeBooleanField: function(e2, t2) {
        this.writeVarintField(e2, Boolean(t2));
      } };
      class ImagePosition {
        constructor(e2, { pixelRatio: t2, version: i2, stretchX: r2, stretchY: n2, content: o2 }) {
          this.paddedRect = e2, this.pixelRatio = t2, this.stretchX = r2, this.stretchY = n2, this.content = o2, this.version = i2;
        }
        get tl() {
          return [this.paddedRect.x + 1, this.paddedRect.y + 1];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
        }
        get displaySize() {
          return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
        }
      }
      kn(ImagePosition, "ImagePosition"), kn(class ImageAtlas {
        constructor(e2, t2) {
          const i2 = {}, r2 = {};
          this.haveRenderCallbacks = [];
          const n2 = [];
          this.addImages(e2, i2, n2), this.addImages(t2, r2, n2);
          const { w: o2, h: s2 } = Hc(n2), a2 = new RGBAImage({ width: o2 || 1, height: s2 || 1 });
          for (const t3 in e2) {
            const r3 = e2[t3], n3 = i2[t3].paddedRect;
            RGBAImage.copy(r3.data, a2, { x: 0, y: 0 }, { x: n3.x + 1, y: n3.y + 1 }, r3.data);
          }
          for (const e3 in t2) {
            const i3 = t2[e3], n3 = r2[e3].paddedRect, o3 = n3.x + 1, s3 = n3.y + 1, l2 = i3.data.width, c2 = i3.data.height;
            RGBAImage.copy(i3.data, a2, { x: 0, y: 0 }, { x: o3, y: s3 }, i3.data), RGBAImage.copy(i3.data, a2, { x: 0, y: c2 - 1 }, { x: o3, y: s3 - 1 }, { width: l2, height: 1 }), RGBAImage.copy(i3.data, a2, { x: 0, y: 0 }, { x: o3, y: s3 + c2 }, { width: l2, height: 1 }), RGBAImage.copy(i3.data, a2, { x: l2 - 1, y: 0 }, { x: o3 - 1, y: s3 }, { width: 1, height: c2 }), RGBAImage.copy(i3.data, a2, { x: 0, y: 0 }, { x: o3 + l2, y: s3 }, { width: 1, height: c2 });
          }
          this.image = a2, this.iconPositions = i2, this.patternPositions = r2;
        }
        addImages(e2, t2, i2) {
          for (const r2 in e2) {
            const n2 = e2[r2], o2 = { x: 0, y: 0, w: n2.data.width + 2, h: n2.data.height + 2 };
            i2.push(o2), t2[r2] = new ImagePosition(o2, n2), n2.hasRenderCallback && this.haveRenderCallbacks.push(r2);
          }
        }
        patchUpdatedImages(e2, t2) {
          this.haveRenderCallbacks = this.haveRenderCallbacks.filter((t3) => e2.hasImage(t3)), e2.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const i2 in e2.updatedImages)
            this.patchUpdatedImage(this.iconPositions[i2], e2.getImage(i2), t2), this.patchUpdatedImage(this.patternPositions[i2], e2.getImage(i2), t2);
        }
        patchUpdatedImage(e2, t2, i2) {
          if (!e2 || !t2)
            return;
          if (e2.version === t2.version)
            return;
          e2.version = t2.version;
          const [r2, n2] = e2.tl;
          i2.update(t2.data, void 0, { x: r2, y: n2 });
        }
      }, "ImageAtlas");
      const Xc = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
      function Kc(e2) {
        let t2 = 0.5, i2 = 0.5;
        switch (e2) {
          case "right":
          case "top-right":
          case "bottom-right":
            t2 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            t2 = 0;
        }
        switch (e2) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            i2 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            i2 = 0;
        }
        return { horizontalAlign: t2, verticalAlign: i2 };
      }
      class Anchor extends d {
        constructor(e2, t2, i2, r2, n2) {
          super(e2, t2), this.angle = r2, this.z = i2, void 0 !== n2 && (this.segment = n2);
        }
        clone() {
          return new Anchor(this.x, this.y, this.z, this.angle, this.segment);
        }
      }
      kn(Anchor, "Anchor");
      const Yc = 1e20;
      function Jc(e2, t2, i2, r2, n2, o2, s2, a2, l2) {
        for (let c2 = t2; c2 < t2 + r2; c2++)
          Qc(e2, i2 * o2 + c2, o2, n2, s2, a2, l2);
        for (let c2 = i2; c2 < i2 + n2; c2++)
          Qc(e2, c2 * o2 + t2, 1, r2, s2, a2, l2);
      }
      function Qc(e2, t2, i2, r2, n2, o2, s2) {
        o2[0] = 0, s2[0] = -Yc, s2[1] = Yc, n2[0] = e2[t2];
        for (let a2 = 1, l2 = 0, c2 = 0; a2 < r2; a2++) {
          n2[a2] = e2[t2 + a2 * i2];
          const r3 = a2 * a2;
          do {
            const e3 = o2[l2];
            c2 = (n2[a2] - n2[e3] + r3 - e3 * e3) / (a2 - e3) / 2;
          } while (c2 <= s2[l2] && --l2 > -1);
          l2++, o2[l2] = a2, s2[l2] = c2, s2[l2 + 1] = Yc;
        }
        for (let a2 = 0, l2 = 0; a2 < r2; a2++) {
          for (; s2[l2 + 1] < a2; )
            l2++;
          const r3 = o2[l2], c2 = a2 - r3;
          e2[t2 + a2 * i2] = n2[r3] + c2 * c2;
        }
      }
      class GlyphManager {
        constructor(e2, t2, i2) {
          this.requestManager = e2, this.localGlyphMode = t2, this.localFontFamily = i2, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
        }
        setURL(e2) {
          this.url = e2;
        }
        getGlyphs(e2, t2) {
          const i2 = [];
          for (const t3 in e2)
            for (const r2 of e2[t3])
              i2.push({ stack: t3, id: r2 });
          M(i2, ({ stack: e3, id: t3 }, i3) => {
            let r2 = this.entries[e3];
            r2 || (r2 = this.entries[e3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
            let n2 = r2.glyphs[t3];
            if (void 0 !== n2)
              return void i3(null, { stack: e3, id: t3, glyph: n2 });
            if (n2 = this._tinySDF(r2, e3, t3), n2)
              return r2.glyphs[t3] = n2, void i3(null, { stack: e3, id: t3, glyph: n2 });
            const o2 = Math.floor(t3 / 256);
            if (256 * o2 > 65535)
              return void i3(new Error("glyphs > 65535 not supported"));
            if (r2.ranges[o2])
              return void i3(null, { stack: e3, id: t3, glyph: n2 });
            let s2 = r2.requests[o2];
            s2 || (s2 = r2.requests[o2] = [], GlyphManager.loadGlyphRange(e3, o2, this.url, this.requestManager, (e4, t4) => {
              if (t4) {
                r2.ascender = t4.ascender, r2.descender = t4.descender;
                for (const e5 in t4.glyphs)
                  this._doesCharSupportLocalGlyph(+e5) || (r2.glyphs[+e5] = t4.glyphs[+e5]);
                r2.ranges[o2] = true;
              }
              for (const i4 of s2)
                i4(e4, t4);
              delete r2.requests[o2];
            })), s2.push((r3, n3) => {
              r3 ? i3(r3) : n3 && i3(null, { stack: e3, id: t3, glyph: n3.glyphs[t3] || null });
            });
          }, (e3, i3) => {
            if (e3)
              t2(e3);
            else if (i3) {
              const e4 = {};
              for (const { stack: t3, id: r2, glyph: n2 } of i3)
                void 0 === e4[t3] && (e4[t3] = {}), void 0 === e4[t3].glyphs && (e4[t3].glyphs = {}), e4[t3].glyphs[r2] = n2 && { id: n2.id, bitmap: n2.bitmap.clone(), metrics: n2.metrics }, e4[t3].ascender = this.entries[t3].ascender, e4[t3].descender = this.entries[t3].descender;
              t2(null, e4);
            }
          });
        }
        _doesCharSupportLocalGlyph(e2) {
          return 0 !== this.localGlyphMode && (2 === this.localGlyphMode ? !!this.localFontFamily : !!this.localFontFamily && (Nn(e2) || Gn(e2) || Vn(e2) || jn(e2) || Un(e2)));
        }
        _tinySDF(e2, t2, i2) {
          const r2 = this.localFontFamily;
          if (!r2 || !this._doesCharSupportLocalGlyph(i2))
            return;
          let n2 = e2.tinySDF;
          if (!n2) {
            let i3 = "400";
            /bold/i.test(t2) ? i3 = "900" : /medium/i.test(t2) ? i3 = "500" : /light/i.test(t2) && (i3 = "200"), n2 = e2.tinySDF = new GlyphManager.TinySDF({ fontFamily: r2, fontWeight: i3, fontSize: 48, buffer: 6, radius: 16 }), n2.fontWeight = i3;
          }
          if (this.localGlyphs[n2.fontWeight][i2])
            return this.localGlyphs[n2.fontWeight][i2];
          const o2 = String.fromCharCode(i2), { data: s2, width: a2, height: l2, glyphWidth: c2, glyphHeight: u2, glyphLeft: h2, glyphTop: p2, glyphAdvance: d2 } = n2.draw(o2);
          return this.localGlyphs[n2.fontWeight][i2] = { id: i2, bitmap: new AlphaImage({ width: a2, height: l2 }, s2), metrics: { width: c2 / 2, height: u2 / 2, left: h2 / 2, top: p2 / 2 - 27, advance: d2 / 2, localGlyph: true } };
        }
      }
      GlyphManager.loadGlyphRange = function(e2, t2, i2, r2, n2) {
        const o2 = 256 * t2, s2 = o2 + 255, a2 = r2.transformRequest(r2.normalizeGlyphsURL(i2).replace("{fontstack}", e2).replace("{range}", `${o2}-${s2}`), pe.Glyphs);
        _e(a2, (e3, t3) => {
          if (e3)
            n2(e3);
          else if (t3) {
            const e4 = {}, i3 = function(e5) {
              return new Ec(e5).readFields(Zc, {});
            }(t3);
            for (const t4 of i3.glyphs)
              e4[t4.id] = t4;
            n2(null, { glyphs: e4, ascender: i3.ascender, descender: i3.descender });
          }
        });
      }, GlyphManager.TinySDF = class TinySDF {
        constructor({ fontSize: e2 = 24, buffer: t2 = 3, radius: i2 = 8, cutoff: r2 = 0.25, fontFamily: n2 = "sans-serif", fontWeight: o2 = "normal", fontStyle: s2 = "normal" } = {}) {
          this.buffer = t2, this.cutoff = r2, this.radius = i2;
          const a2 = this.size = e2 + 4 * t2, l2 = this._createCanvas(a2), c2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
          c2.font = `${s2} ${o2} ${e2}px ${n2}`, c2.textBaseline = "alphabetic", c2.textAlign = "left", c2.fillStyle = "black", this.gridOuter = new Float64Array(a2 * a2), this.gridInner = new Float64Array(a2 * a2), this.f = new Float64Array(a2), this.z = new Float64Array(a2 + 1), this.v = new Uint16Array(a2);
        }
        _createCanvas(e2) {
          const t2 = document.createElement("canvas");
          return t2.width = t2.height = e2, t2;
        }
        draw(e2) {
          const { width: t2, actualBoundingBoxAscent: i2, actualBoundingBoxDescent: r2, actualBoundingBoxLeft: n2, actualBoundingBoxRight: o2 } = this.ctx.measureText(e2), s2 = Math.ceil(i2), a2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o2 - n2))), l2 = Math.min(this.size - this.buffer, s2 + Math.ceil(r2)), c2 = a2 + 2 * this.buffer, u2 = l2 + 2 * this.buffer, h2 = Math.max(c2 * u2, 0), p2 = new Uint8ClampedArray(h2), d2 = { data: p2, width: c2, height: u2, glyphWidth: a2, glyphHeight: l2, glyphTop: s2, glyphLeft: 0, glyphAdvance: t2 };
          if (0 === a2 || 0 === l2)
            return d2;
          const { ctx: f2, buffer: m2, gridInner: _2, gridOuter: g2 } = this;
          f2.clearRect(m2, m2, a2, l2), f2.fillText(e2, m2, m2 + s2);
          const y2 = f2.getImageData(m2, m2, a2, l2);
          g2.fill(Yc, 0, h2), _2.fill(0, 0, h2);
          for (let e3 = 0; e3 < l2; e3++)
            for (let t3 = 0; t3 < a2; t3++) {
              const i3 = y2.data[4 * (e3 * a2 + t3) + 3] / 255;
              if (0 === i3)
                continue;
              const r3 = (e3 + m2) * c2 + t3 + m2;
              if (1 === i3)
                g2[r3] = 0, _2[r3] = Yc;
              else {
                const e4 = 0.5 - i3;
                g2[r3] = e4 > 0 ? e4 * e4 : 0, _2[r3] = e4 < 0 ? e4 * e4 : 0;
              }
            }
          Jc(g2, 0, 0, c2, u2, c2, this.f, this.v, this.z), Jc(_2, m2, m2, a2, l2, c2, this.f, this.v, this.z);
          for (let e3 = 0; e3 < h2; e3++) {
            const t3 = Math.sqrt(g2[e3]) - Math.sqrt(_2[e3]);
            p2[e3] = Math.round(255 - 255 * (t3 / this.radius + this.cutoff));
          }
          return d2;
        }
      };
      const eu = Number.POSITIVE_INFINITY, tu = Math.sqrt(2);
      function iu(e2, [t2, i2]) {
        let r2 = 0, n2 = 0;
        if (i2 === eu) {
          t2 < 0 && (t2 = 0);
          const i3 = t2 / tu;
          switch (e2) {
            case "top-right":
            case "top-left":
              n2 = i3 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              n2 = 7 - i3;
              break;
            case "bottom":
              n2 = 7 - t2;
              break;
            case "top":
              n2 = t2 - 7;
          }
          switch (e2) {
            case "top-right":
            case "bottom-right":
              r2 = -i3;
              break;
            case "top-left":
            case "bottom-left":
              r2 = i3;
              break;
            case "left":
              r2 = t2;
              break;
            case "right":
              r2 = -t2;
          }
        } else {
          switch (t2 = Math.abs(t2), i2 = Math.abs(i2), e2) {
            case "top-right":
            case "top-left":
            case "top":
              n2 = i2 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              n2 = 7 - i2;
          }
          switch (e2) {
            case "top-right":
            case "bottom-right":
            case "right":
              r2 = -t2;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              r2 = t2;
          }
        }
        return [r2, n2];
      }
      const ru = co([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: nu } = ru, ou = co([{ name: "a_pos_3", components: 3, type: "Int16" }]);
      var su = co([{ name: "a_pos", type: "Int16", components: 2 }]);
      const au = ko / Math.PI / 2, lu = 2 * Vo(1, 0) * au * Math.PI, cu = 64, uu = [cu, 32, 16], hu = -au, pu = au, du = [new Aabb([hu, hu, hu], [pu, pu, pu]), new Aabb([hu, hu, hu], [0, 0, pu]), new Aabb([0, hu, hu], [pu, 0, pu]), new Aabb([hu, 0, hu], [0, pu, pu]), new Aabb([0, 0, hu], [pu, pu, pu])];
      function fu(e2, t2, i2, r2 = true) {
        const n2 = Ys([], e2._camera.position, e2.worldSize), o2 = [t2, i2, 1, 1];
        da(o2, o2, e2.pixelMatrixInverse), ha(o2, o2, 1 / o2[3]);
        const s2 = ea([], aa([], o2, n2)), a2 = e2.globeMatrix, l2 = [a2[12], a2[13], a2[14]], c2 = aa([], l2, n2), u2 = qs(c2), h2 = ea([], c2), p2 = e2.worldSize / (2 * Math.PI), d2 = ta(h2, s2), f2 = Math.asin(p2 / u2);
        if (f2 < Math.acos(d2)) {
          if (!r2)
            return null;
          const e3 = [], t3 = [];
          Ys(e3, s2, u2 / d2), ea(t3, aa(t3, e3, c2)), ea(s2, $s(s2, c2, Ys(s2, t3, Math.tan(f2) * u2)));
        }
        const m2 = [];
        new Ray(n2, s2).closestPointOnSphere(l2, p2, m2);
        const _2 = ea([], ee(a2, 0)), g2 = ea([], ee(a2, 1)), y2 = ea([], ee(a2, 2)), v2 = ta(_2, m2), b2 = ta(g2, m2), w2 = ta(y2, m2), T2 = x(Math.asin(-b2 / p2));
        let E2 = x(Math.atan2(v2, w2));
        E2 = e2.center.lng + function(e3, t3) {
          const i3 = (t3 - e3 + 180) % 360 - 180;
          return i3 < -180 ? i3 + 360 : i3;
        }(e2.center.lng, E2);
        const S2 = Oo(E2), C2 = A(Uo(T2), 0, 1);
        return new MercatorCoordinate(S2, C2);
      }
      class Arc {
        constructor(e2, t2, i2) {
          this.a = aa([], e2, i2), this.b = aa([], t2, i2), this.center = i2;
          const r2 = ea([], this.a), n2 = ea([], this.b);
          this.angle = Math.acos(ta(r2, n2));
        }
      }
      function mu(e2, t2) {
        if (0 === e2.angle)
          return null;
        let i2;
        return i2 = 0 === e2.a[t2] ? 1 / e2.angle * 0.5 * Math.PI : 1 / e2.angle * Math.atan(e2.b[t2] / e2.a[t2] / Math.sin(e2.angle) - 1 / Math.tan(e2.angle)), i2 < 0 || i2 > 1 ? null : function(e3, t3, i3, r2) {
          const n2 = Math.sin(i3);
          return e3 * (Math.sin((1 - r2) * i3) / n2) + t3 * (Math.sin(r2 * i3) / n2);
        }(e2.a[t2], e2.b[t2], e2.angle, A(i2, 0, 1)) + e2.center[t2];
      }
      function _u(e2) {
        if (e2.z <= 1)
          return du[e2.z + 2 * e2.y + e2.x];
        const t2 = wu(bu(e2));
        return Aabb.fromPoints(t2);
      }
      function gu(e2, t2, i2) {
        return Ys(e2, e2, 1 - i2), Js(e2, e2, t2, i2);
      }
      function yu(e2, t2) {
        const i2 = zu(t2.zoom);
        if (0 === i2)
          return _u(e2);
        const r2 = bu(e2), n2 = wu(r2), o2 = Oo(r2.getWest()) * t2.worldSize, s2 = Oo(r2.getEast()) * t2.worldSize, a2 = Uo(r2.getNorth()) * t2.worldSize, l2 = Uo(r2.getSouth()) * t2.worldSize, c2 = [o2, a2, 0], u2 = [s2, a2, 0], h2 = [o2, l2, 0], p2 = [s2, l2, 0], d2 = Ms([], t2.globeMatrix);
        return ra(c2, c2, d2), ra(u2, u2, d2), ra(h2, h2, d2), ra(p2, p2, d2), n2[0] = gu(n2[0], h2, i2), n2[1] = gu(n2[1], p2, i2), n2[2] = gu(n2[2], u2, i2), n2[3] = gu(n2[3], c2, i2), Aabb.fromPoints(n2);
      }
      function xu(e2, t2, i2) {
        for (const r2 of e2)
          ra(r2, r2, t2), Ys(r2, r2, i2);
      }
      function vu(e2, t2, i2) {
        const r2 = t2 / e2.worldSize, n2 = e2.globeMatrix;
        if (i2.z <= 1) {
          const e3 = _u(i2).getCorners();
          return xu(e3, n2, r2), Aabb.fromPoints(e3);
        }
        const o2 = bu(i2), s2 = wu(o2);
        xu(s2, n2, r2);
        const a2 = Number.MAX_VALUE, l2 = [-a2, -a2, -a2], c2 = [a2, a2, a2];
        if (o2.contains(e2.center)) {
          for (const e3 of s2)
            Xs(c2, c2, e3), Ks(l2, l2, e3);
          l2[2] = 0;
          const t3 = e2.point, i3 = [t3.x * r2, t3.y * r2, 0];
          return Xs(c2, c2, i3), Ks(l2, l2, i3), new Aabb(c2, l2);
        }
        const u2 = [n2[12] * r2, n2[13] * r2, n2[14] * r2], h2 = o2.getCenter(), p2 = A(e2.center.lat, -85.051129, qo), d2 = A(h2.lat, -85.051129, qo), f2 = Oo(e2.center.lng), m2 = Uo(p2);
        let _2 = f2 - Oo(h2.lng);
        const g2 = m2 - Uo(d2);
        _2 > 0.5 ? _2 -= 1 : _2 < -0.5 && (_2 += 1);
        let x2 = 0;
        Math.abs(_2) > Math.abs(g2) ? x2 = _2 >= 0 ? 1 : 3 : (x2 = g2 >= 0 ? 0 : 2, Js(u2, u2, [n2[4] * r2, n2[5] * r2, n2[6] * r2], -Math.sin(y(g2 >= 0 ? o2.getSouth() : o2.getNorth())) * au));
        const v2 = s2[x2], b2 = s2[(x2 + 1) % 4], w2 = new Arc(v2, b2, u2), T2 = [mu(w2, 0) || v2[0], mu(w2, 1) || v2[1], mu(w2, 2) || v2[2]], E2 = zu(e2.zoom);
        if (E2 > 0) {
          const r3 = function({ x: e3, y: t3, z: i3 }, r4, n4, o3, s3) {
            const a3 = 1 / (1 << i3);
            let l3 = e3 * a3, c3 = l3 + a3, u3 = t3 * a3, h3 = u3 + a3, p3 = 0;
            const d3 = (l3 + c3) / 2 - o3;
            return d3 > 0.5 ? p3 = -1 : d3 < -0.5 && (p3 = 1), l3 = ((l3 + p3) * r4 - (o3 *= r4)) * n4 + o3, c3 = ((c3 + p3) * r4 - o3) * n4 + o3, u3 = (u3 * r4 - (s3 *= r4)) * n4 + s3, h3 = (h3 * r4 - s3) * n4 + s3, [[l3, h3, 0], [c3, h3, 0], [c3, u3, 0], [l3, u3, 0]];
          }(i2, t2, e2._pixelsPerMercatorPixel, f2, m2);
          for (let e3 = 0; e3 < s2.length; e3++)
            gu(s2[e3], r3[e3], E2);
          const n3 = $s([], r3[x2], r3[(x2 + 1) % 4]);
          Ys(n3, n3, 0.5), gu(T2, n3, E2);
        }
        for (const e3 of s2)
          Xs(c2, c2, e3), Ks(l2, l2, e3);
        return c2[2] = Math.min(v2[2], b2[2]), Xs(c2, c2, T2), Ks(l2, l2, T2), new Aabb(c2, l2);
      }
      function bu({ x: e2, y: t2, z: i2 }) {
        const r2 = 1 / (1 << i2), n2 = new LngLat(jo(e2 * r2), No((t2 + 1) * r2)), o2 = new LngLat(jo((e2 + 1) * r2), No(t2 * r2));
        return new LngLatBounds(n2, o2);
      }
      function wu(e2) {
        const t2 = y(e2.getNorth()), i2 = y(e2.getSouth()), r2 = Math.cos(t2), n2 = Math.cos(i2), o2 = Math.sin(t2), s2 = Math.sin(i2), a2 = e2.getWest(), l2 = e2.getEast();
        return [Tu(n2, s2, a2), Tu(n2, s2, l2), Tu(r2, o2, l2), Tu(r2, o2, a2)];
      }
      function Tu(e2, t2, i2, r2 = au) {
        return i2 = y(i2), [e2 * Math.sin(i2) * r2, -t2 * r2, e2 * Math.cos(i2) * r2];
      }
      function Eu(e2, t2, i2) {
        return Tu(Math.cos(y(e2)), Math.sin(y(e2)), t2, i2);
      }
      function Su(e2, t2, i2, r2) {
        const n2 = 1 << i2.z, o2 = (e2 / ko + i2.x) / n2;
        return Eu(No((t2 / ko + i2.y) / n2), jo(o2), r2);
      }
      function Au({ min: e2, max: t2 }) {
        return 16383 / Math.max(t2[0] - e2[0], t2[1] - e2[1], t2[2] - e2[2]);
      }
      const Cu = new Float64Array(16);
      function Iu(e2) {
        const t2 = Au(e2), i2 = Rs(Cu, [t2, t2, t2]);
        return Ps(i2, i2, ((r2 = [])[0] = -(n2 = e2.min)[0], r2[1] = -n2[1], r2[2] = -n2[2], r2));
        var r2, n2;
      }
      function Mu(e2) {
        const t2 = (r2 = e2.min, (i2 = Cu)[0] = 1, i2[1] = 0, i2[2] = 0, i2[3] = 0, i2[4] = 0, i2[5] = 1, i2[6] = 0, i2[7] = 0, i2[8] = 0, i2[9] = 0, i2[10] = 1, i2[11] = 0, i2[12] = r2[0], i2[13] = r2[1], i2[14] = r2[2], i2[15] = 1, i2);
        var i2, r2;
        const n2 = 1 / Au(e2);
        return zs(t2, t2, [n2, n2, n2]);
      }
      function Du(e2, t2) {
        return ko / (512 * Math.pow(2, e2)) * Au(_u(t2));
      }
      function Pu(e2, t2, i2, r2, n2) {
        const o2 = function(e3) {
          const t3 = ko / (2 * Math.PI);
          return e3 / (2 * Math.PI) / t3;
        }(i2), s2 = [e2, t2, -i2 / (2 * Math.PI)], a2 = Is(new Float64Array(16));
        return Ps(a2, a2, s2), zs(a2, a2, [o2, o2, o2]), Ls(a2, a2, y(-n2)), ks(a2, a2, y(-r2)), a2;
      }
      function zu(e2) {
        return C(5, 6, e2);
      }
      function Lu(e2, t2, i2) {
        const r2 = Is(new Float64Array(16)), n2 = (t2 / (1 << e2) - 0.5) * Math.PI * 2;
        return ks(r2, i2.globeMatrix, n2), Float32Array.from(r2);
      }
      function ku(e2, t2, i2) {
        const r2 = zu(i2.zoom), n2 = e2.style.map._antialias, o2 = !!t2.extStandardDerivatives, s2 = t2.extStandardDerivativesForceOff || e2.terrain && e2.terrain.exaggeration() > 0;
        return 0 === r2 && !n2 && !s2 && o2;
      }
      function Bu(e2, t2, i2, r2) {
        const n2 = t2.getNorth(), o2 = t2.getSouth(), s2 = t2.getWest(), a2 = t2.getEast(), l2 = 1 << e2.z, c2 = a2 - s2, u2 = n2 - o2, h2 = c2 / cu, p2 = -u2 / uu[i2], d2 = [0, h2, 0, p2, 0, 0, n2, s2, 0];
        if (e2.z > 0) {
          const e3 = 180 / r2;
          As(d2, d2, [e3 / c2 + 1, 0, 0, 0, e3 / u2 + 1, 0, -0.5 * e3 / h2, 0.5 * e3 / p2, 1]);
        }
        return d2[2] = l2, d2[5] = e2.x, d2[8] = e2.y, d2;
      }
      function Ru(e2) {
        const t2 = 80.051129;
        e2 = A(e2, -80.051129, t2) / t2 * 90;
        const i2 = Math.pow(Math.abs(Math.sin(y(e2))), 3);
        return Math.round(i2 * (uu.length - 1));
      }
      function Fu(e2) {
        const t2 = [0, 0, 0], i2 = Is(new Float64Array(16));
        return Ds(i2, e2.pixelMatrix, e2.globeMatrix), ra(t2, t2, i2), new d(t2[0], t2[1]);
      }
      function Ou(e2, t2) {
        const i2 = Eu(t2.lat, t2.lng), r2 = function(e3) {
          const t3 = Eu(e3._center.lat, e3._center.lng);
          let i3 = ia([], Zs(0, 1, 0), t3);
          const r3 = Fs([], -e3.angle, t3);
          i3 = ra(i3, i3, r3), Fs(r3, -e3._pitch, i3);
          const n3 = ea([], t3);
          return Ys(n3, n3, e3.cameraToCenterDistance / e3.pixelsPerMeter * lu), ra(n3, n3, r3), $s([], t3, n3);
        }(e2);
        return s2 = (n2 = Ws([], r2, i2))[0], a2 = n2[1], l2 = n2[2], c2 = (o2 = i2)[0], u2 = o2[1], h2 = o2[2], d2 = (p2 = Math.sqrt(s2 * s2 + a2 * a2 + l2 * l2) * Math.sqrt(c2 * c2 + u2 * u2 + h2 * h2)) && ta(n2, o2) / p2, Math.acos(Math.min(Math.max(d2, -1), 1));
        var n2, o2, s2, a2, l2, c2, u2, h2, p2, d2;
      }
      function Uu(e2, t2) {
        return Ou(e2, t2) > Math.PI / 2 * 1.01;
      }
      const Vu = y(85), ju = Math.cos(Vu), Nu = Math.sin(Vu);
      class GlobeSharedBuffers {
        constructor(e2) {
          this._createGrid(e2), this._createPoles(e2);
        }
        destroy() {
          this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
          for (const e2 of this._poleSegments)
            e2.destroy();
          for (const e2 of this._gridSegments)
            e2.destroy();
          if (this._wireframeIndexBuffer) {
            this._wireframeIndexBuffer.destroy();
            for (const e2 of this._wireframeSegments)
              e2.destroy();
          }
        }
        _createGrid(e2) {
          const t2 = new StructArrayLayout2i4(), i2 = new StructArrayLayout3ui6(), r2 = 65;
          for (let e3 = 0; e3 < r2; e3++)
            for (let i3 = 0; i3 < r2; i3++)
              t2.emplaceBack(i3, e3);
          this._gridSegments = [];
          for (let e3 = 0, t3 = 0; e3 < uu.length; e3++) {
            const n2 = uu[e3];
            for (let e4 = 0; e4 < n2; e4++)
              for (let t4 = 0; t4 < 64; t4++) {
                const n3 = e4 * r2 + t4;
                i2.emplaceBack(n3 + 1, n3, n3 + r2), i2.emplaceBack(n3 + r2, n3 + r2 + 1, n3 + 1);
              }
            const o2 = 64 * n2 * 2;
            this._gridSegments.push(SegmentVector.simpleSegment(0, t3, (n2 + 1) * r2, o2)), t3 += o2;
          }
          this._gridBuffer = e2.createVertexBuffer(t2, su.members), this._gridIndexBuffer = e2.createIndexBuffer(i2, true);
        }
        _createPoles(e2) {
          const t2 = new StructArrayLayout3ui6();
          for (let e3 = 0; e3 <= cu; e3++)
            t2.emplaceBack(0, e3 + 1, e3 + 2);
          this._poleIndexBuffer = e2.createIndexBuffer(t2, true);
          const i2 = new StructArrayLayout5f20(), r2 = new StructArrayLayout5f20();
          this._poleSegments = [];
          for (let e3 = 0, t3 = 0; e3 < 5; e3++) {
            const n2 = 360 / (1 << e3);
            i2.emplaceBack(0, -au, 0, 0.5, 0), r2.emplaceBack(0, -au, 0, 0.5, 1);
            for (let e4 = 0; e4 <= cu; e4++) {
              const t4 = e4 / cu, o2 = Ii(0, n2, t4), [s2, a2, l2] = Tu(ju, Nu, o2, au);
              i2.emplaceBack(s2, a2, l2, t4, 0), r2.emplaceBack(s2, a2, l2, t4, 1);
            }
            this._poleSegments.push(SegmentVector.simpleSegment(t3, 0, 66, 64)), t3 += 66;
          }
          this._poleNorthVertexBuffer = e2.createVertexBuffer(i2, nu, false), this._poleSouthVertexBuffer = e2.createVertexBuffer(r2, nu, false);
        }
        getGridBuffers(e2) {
          return [this._gridBuffer, this._gridIndexBuffer, this._gridSegments[e2]];
        }
        getPoleBuffers(e2) {
          return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[e2]];
        }
        getWirefameBuffers(e2, t2) {
          if (!this._wireframeSegments) {
            const t3 = new StructArrayLayout2ui4(), i2 = cu, r2 = i2 + 1;
            this._wireframeSegments = [];
            for (let e3 = 0, n2 = 0; e3 < uu.length; e3++) {
              const o2 = uu[e3];
              for (let e4 = 0; e4 < o2; e4++)
                for (let n3 = 0; n3 < i2; n3++) {
                  const i3 = e4 * r2 + n3;
                  t3.emplaceBack(i3, i3 + 1), t3.emplaceBack(i3, i3 + r2), t3.emplaceBack(i3, i3 + r2 + 1);
                }
              const s2 = o2 * i2 * 3;
              this._wireframeSegments.push(SegmentVector.simpleSegment(0, n2, (o2 + 1) * r2, s2)), n2 += s2;
            }
            this._wireframeIndexBuffer = e2.createIndexBuffer(t3);
          }
          return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[t2]];
        }
      }
      function Gu(e2, t2) {
        const i2 = e2.fovAboveCenter, r2 = e2.elevation ? e2.elevation.getMinElevationBelowMSL() * t2 : 0, n2 = (e2._camera.position[2] * e2.worldSize - r2) / Math.cos(e2._pitch), o2 = Math.sin(i2) * n2 / Math.sin(Math.max(Math.PI / 2 - e2._pitch - i2, 0.01)), s2 = Math.sin(e2._pitch) * o2 + n2;
        return Math.min(1.01 * s2, n2 * (1 / e2._horizonShift));
      }
      function qu(e2, t2) {
        if (!t2.isReprojectedInTileSpace)
          return { scale: 1 << e2.z, x: e2.x, y: e2.y, x2: e2.x + 1, y2: e2.y + 1, projection: t2 };
        const i2 = Math.pow(2, -e2.z), r2 = e2.x * i2, n2 = (e2.x + 1) * i2, o2 = e2.y * i2, s2 = (e2.y + 1) * i2, a2 = jo(r2), l2 = jo(n2), c2 = No(o2), u2 = No(s2), h2 = t2.project(a2, c2), p2 = t2.project(l2, c2), d2 = t2.project(l2, u2), f2 = t2.project(a2, u2);
        let m2 = Math.min(h2.x, p2.x, d2.x, f2.x), _2 = Math.min(h2.y, p2.y, d2.y, f2.y), g2 = Math.max(h2.x, p2.x, d2.x, f2.x), y2 = Math.max(h2.y, p2.y, d2.y, f2.y);
        const x2 = i2 / 16;
        function v2(e3, i3, r3, n3, o3, s3) {
          const a3 = (r3 + o3) / 2, l3 = (n3 + s3) / 2, c3 = t2.project(jo(a3), No(l3)), u3 = Math.max(0, m2 - c3.x, _2 - c3.y, c3.x - g2, c3.y - y2);
          m2 = Math.min(m2, c3.x), g2 = Math.max(g2, c3.x), _2 = Math.min(_2, c3.y), y2 = Math.max(y2, c3.y), u3 > x2 && (v2(e3, c3, r3, n3, a3, l3), v2(c3, i3, a3, l3, o3, s3));
        }
        v2(h2, p2, r2, o2, n2, o2), v2(p2, d2, n2, o2, n2, s2), v2(d2, f2, n2, s2, r2, s2), v2(f2, h2, r2, s2, r2, o2), m2 -= x2, _2 -= x2, g2 += x2, y2 += x2;
        const b2 = 1 / Math.max(g2 - m2, y2 - _2);
        return { scale: b2, x: m2 * b2, y: _2 * b2, x2: g2 * b2, y2: y2 * b2, projection: t2 };
      }
      function Zu(e2, t2, i2, r2, n2, o2, s2, a2, l2) {
        if ("globe" === l2.name)
          return vu(e2, t2, new CanonicalTileID(i2, r2, n2));
        const c2 = qu({ z: i2, x: r2, y: n2 }, l2);
        return new Aabb([(o2 + c2.x / c2.scale) * t2, t2 * (c2.y / c2.scale), s2], [(o2 + c2.x2 / c2.scale) * t2, t2 * (c2.y2 / c2.scale), a2]);
      }
      function $u(e2, { x: t2, y: i2 }, r2 = 0) {
        return new d(((t2 - r2) * e2.scale - e2.x) * ko, (i2 * e2.scale - e2.y) * ko);
      }
      function Wu(e2, t2, i2 = 0) {
        return Zs(((t2.x - i2) * e2.scale - e2.x) * ko, (t2.y * e2.scale - e2.y) * ko, Go(t2.z, t2.y));
      }
      const Hu = Is(new Float32Array(16));
      class Projection {
        constructor(e2) {
          this.spec = e2, this.name = e2.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
        }
        project(e2, t2) {
          return { x: 0, y: 0, z: 0 };
        }
        unproject(e2, t2) {
          return new LngLat(0, 0);
        }
        projectTilePoint(e2, t2, i2) {
          return { x: e2, y: t2, z: 0 };
        }
        locationPoint(e2, t2, i2 = true) {
          return e2._coordinatePoint(e2.locationCoordinate(t2), i2);
        }
        pixelsPerMeter(e2, t2) {
          return Vo(1, e2) * t2;
        }
        pixelSpaceConversion(e2, t2, i2) {
          return 1;
        }
        farthestPixelDistance(e2) {
          return Gu(e2, e2.pixelsPerMeter);
        }
        pointCoordinate(e2, t2, i2, r2) {
          const n2 = e2.horizonLineFromTop(false), o2 = new d(t2, Math.max(n2, i2));
          return e2.rayIntersectionCoordinate(e2.pointRayIntersection(o2, r2));
        }
        pointCoordinate3D(e2, t2, i2) {
          const r2 = new d(t2, i2);
          if (e2.elevation)
            return e2.elevation.pointCoordinate(r2);
          {
            const t3 = this.pointCoordinate(e2, r2.x, r2.y, 0);
            return [t3.x, t3.y, t3.z];
          }
        }
        isPointAboveHorizon(e2, t2) {
          if (e2.elevation)
            return !this.pointCoordinate3D(e2, t2.x, t2.y);
          const i2 = e2.horizonLineFromTop();
          return t2.y < i2;
        }
        createInversionMatrix(e2, t2) {
          return Hu;
        }
        createTileMatrix(e2, t2, i2) {
          let r2, n2, o2;
          const s2 = i2.canonical, a2 = Is(new Float64Array(16));
          if (this.isReprojectedInTileSpace) {
            const l2 = qu(s2, this);
            r2 = 1, n2 = l2.x + i2.wrap * l2.scale, o2 = l2.y, zs(a2, a2, [r2 / l2.scale, r2 / l2.scale, e2.pixelsPerMeter / t2]);
          } else
            r2 = t2 / e2.zoomScale(s2.z), n2 = (s2.x + Math.pow(2, s2.z) * i2.wrap) * r2, o2 = s2.y * r2;
          return Ps(a2, a2, [n2, o2, 0]), zs(a2, a2, [r2 / ko, r2 / ko, 1]), a2;
        }
        upVector(e2, t2, i2) {
          return [0, 0, 1];
        }
        upVectorScale(e2, t2, i2) {
          return { metersToTile: 1 };
        }
      }
      class Albers extends Projection {
        constructor(e2) {
          super(e2), this.range = [4, 7], this.center = e2.center || [-96, 37.5];
          const [t2, i2] = this.parallels = e2.parallels || [29.5, 45.5], r2 = Math.sin(y(t2));
          this.n = (r2 + Math.sin(y(i2))) / 2, this.c = 1 + r2 * (2 * this.n - r2), this.r0 = Math.sqrt(this.c) / this.n;
        }
        project(e2, t2) {
          const { n: i2, c: r2, r0: n2 } = this, o2 = y(e2 - this.center[0]), s2 = y(t2), a2 = Math.sqrt(r2 - 2 * i2 * Math.sin(s2)) / i2;
          return { x: a2 * Math.sin(o2 * i2), y: a2 * Math.cos(o2 * i2) - n2, z: 0 };
        }
        unproject(e2, t2) {
          const { n: i2, c: r2, r0: n2 } = this, o2 = n2 + t2;
          let s2 = Math.atan2(e2, Math.abs(o2)) * Math.sign(o2);
          o2 * i2 < 0 && (s2 -= Math.PI * Math.sign(e2) * Math.sign(o2));
          const a2 = y(this.center[0]) * i2;
          s2 = I(s2, -Math.PI - a2, Math.PI - a2);
          const l2 = A(x(s2 / i2) + this.center[0], -180, 180), c2 = Math.asin(A((r2 - (e2 * e2 + o2 * o2) * i2 * i2) / (2 * i2), -1, 1)), u2 = A(x(c2), -85.051129, qo);
          return new LngLat(l2, u2);
        }
      }
      const Xu = 1.340264, Ku = -0.081106, Yu = 893e-6, Ju = 3796e-6, Qu = Math.sqrt(3) / 2;
      class EqualEarth extends Projection {
        project(e2, t2) {
          t2 = t2 / 180 * Math.PI, e2 = e2 / 180 * Math.PI;
          const i2 = Math.asin(Qu * Math.sin(t2)), r2 = i2 * i2, n2 = r2 * r2 * r2;
          return { x: 0.5 * (e2 * Math.cos(i2) / (Qu * (Xu + 3 * Ku * r2 + n2 * (7 * Yu + 9 * Ju * r2))) / Math.PI + 0.5), y: 1 - 0.5 * (i2 * (Xu + Ku * r2 + n2 * (Yu + Ju * r2)) / Math.PI + 1), z: 0 };
        }
        unproject(e2, t2) {
          e2 = (2 * e2 - 0.5) * Math.PI;
          let i2 = t2 = (2 * (1 - t2) - 1) * Math.PI, r2 = i2 * i2, n2 = r2 * r2 * r2;
          for (let e3, o3, s3, a3 = 0; a3 < 12 && (o3 = i2 * (Xu + Ku * r2 + n2 * (Yu + Ju * r2)) - t2, s3 = Xu + 3 * Ku * r2 + n2 * (7 * Yu + 9 * Ju * r2), e3 = o3 / s3, i2 = A(i2 - e3, -Math.PI / 3, Math.PI / 3), r2 = i2 * i2, n2 = r2 * r2 * r2, !(Math.abs(e3) < 1e-12)); ++a3)
            ;
          const o2 = Qu * e2 * (Xu + 3 * Ku * r2 + n2 * (7 * Yu + 9 * Ju * r2)) / Math.cos(i2), s2 = Math.asin(Math.sin(i2) / Qu), a2 = A(180 * o2 / Math.PI, -180, 180), l2 = A(180 * s2 / Math.PI, -85.051129, qo);
          return new LngLat(a2, l2);
        }
      }
      class Equirectangular extends Projection {
        constructor(e2) {
          super(e2), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(e2, t2) {
          return { x: 0.5 + e2 / 360, y: 0.5 - t2 / 360, z: 0 };
        }
        unproject(e2, t2) {
          const i2 = 360 * (e2 - 0.5), r2 = A(360 * (0.5 - t2), -85.051129, qo);
          return new LngLat(i2, r2);
        }
      }
      const eh = Math.PI / 2;
      function th(e2) {
        return Math.tan((eh + e2) / 2);
      }
      class LambertConformalConic extends Projection {
        constructor(e2) {
          super(e2), this.center = e2.center || [0, 30];
          const [t2, i2] = this.parallels = e2.parallels || [30, 30];
          let r2 = y(t2), n2 = y(i2);
          this.southernCenter = r2 + n2 < 0, this.southernCenter && (r2 = -r2, n2 = -n2);
          const o2 = Math.cos(r2), s2 = th(r2);
          this.n = r2 === n2 ? Math.sin(r2) : Math.log(o2 / Math.cos(n2)) / Math.log(th(n2) / s2), this.f = o2 * Math.pow(th(r2), this.n) / this.n;
        }
        project(e2, t2) {
          t2 = y(t2), this.southernCenter && (t2 = -t2), e2 = y(e2 - this.center[0]);
          const i2 = 1e-6, { n: r2, f: n2 } = this;
          n2 > 0 ? t2 < -eh + i2 && (t2 = -eh + i2) : t2 > eh - i2 && (t2 = eh - i2);
          const o2 = n2 / Math.pow(th(t2), r2);
          let s2 = o2 * Math.sin(r2 * e2), a2 = n2 - o2 * Math.cos(r2 * e2);
          return s2 = 0.5 * (s2 / Math.PI + 0.5), a2 = 0.5 * (a2 / Math.PI + 0.5), { x: s2, y: this.southernCenter ? a2 : 1 - a2, z: 0 };
        }
        unproject(e2, t2) {
          e2 = (2 * e2 - 0.5) * Math.PI, this.southernCenter && (t2 = 1 - t2), t2 = (2 * (1 - t2) - 0.5) * Math.PI;
          const { n: i2, f: r2 } = this, n2 = r2 - t2, o2 = Math.sign(n2), s2 = Math.sign(i2) * Math.sqrt(e2 * e2 + n2 * n2);
          let a2 = Math.atan2(e2, Math.abs(n2)) * o2;
          n2 * i2 < 0 && (a2 -= Math.PI * Math.sign(e2) * o2);
          const l2 = A(x(a2 / i2) + this.center[0], -180, 180), c2 = A(x(2 * Math.atan(Math.pow(r2 / s2, 1 / i2)) - eh), -85.051129, qo);
          return new LngLat(l2, this.southernCenter ? -c2 : c2);
        }
      }
      class Mercator extends Projection {
        constructor(e2) {
          super(e2), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
        }
        project(e2, t2) {
          return { x: Oo(e2), y: Uo(t2), z: 0 };
        }
        unproject(e2, t2) {
          const i2 = jo(e2), r2 = No(t2);
          return new LngLat(i2, r2);
        }
      }
      const ih = y(qo);
      class NaturalEarth extends Projection {
        project(e2, t2) {
          const i2 = (t2 = y(t2)) * t2, r2 = i2 * i2;
          return { x: 0.5 * ((e2 = y(e2)) * (0.8707 - 0.131979 * i2 + r2 * (r2 * (3971e-6 * i2 - 1529e-6 * r2) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (t2 * (1.007226 + i2 * (0.015085 + r2 * (0.028874 * i2 - 0.044475 - 5916e-6 * r2))) / Math.PI + 1), z: 0 };
        }
        unproject(e2, t2) {
          e2 = (2 * e2 - 0.5) * Math.PI;
          let i2 = t2 = (2 * (1 - t2) - 1) * Math.PI, r2 = 25, n2 = 0, o2 = i2 * i2;
          do {
            o2 = i2 * i2;
            const e3 = o2 * o2;
            n2 = (i2 * (1.007226 + o2 * (0.015085 + e3 * (0.028874 * o2 - 0.044475 - 5916e-6 * e3))) - t2) / (1.007226 + o2 * (0.045255 + e3 * (0.259866 * o2 - 0.311325 - 5916e-6 * 11 * e3))), i2 = A(i2 - n2, -ih, ih);
          } while (Math.abs(n2) > 1e-6 && --r2 > 0);
          o2 = i2 * i2;
          const s2 = A(x(e2 / (0.8707 + o2 * (o2 * (o2 * o2 * o2 * (3971e-6 - 1529e-6 * o2) - 0.013791) - 0.131979))), -180, 180), a2 = x(i2);
          return new LngLat(s2, a2);
        }
      }
      const rh = y(qo);
      class WinkelTripel extends Projection {
        project(e2, t2) {
          t2 = y(t2), e2 = y(e2);
          const i2 = Math.cos(t2), r2 = 2 / Math.PI, n2 = Math.acos(i2 * Math.cos(e2 / 2)), o2 = Math.sin(n2) / n2, s2 = 0.5 * (e2 * r2 + 2 * i2 * Math.sin(e2 / 2) / o2) || 0, a2 = 0.5 * (t2 + Math.sin(t2) / o2) || 0;
          return { x: 0.5 * (s2 / Math.PI + 0.5), y: 1 - 0.5 * (a2 / Math.PI + 1), z: 0 };
        }
        unproject(e2, t2) {
          let i2 = e2 = (2 * e2 - 0.5) * Math.PI, r2 = t2 = (2 * (1 - t2) - 1) * Math.PI, n2 = 25;
          const o2 = 1e-6;
          let s2 = 0, a2 = 0;
          do {
            const n3 = Math.cos(r2), o3 = Math.sin(r2), l2 = 2 * o3 * n3, c2 = o3 * o3, u2 = n3 * n3, h2 = Math.cos(i2 / 2), p2 = Math.sin(i2 / 2), d2 = 2 * h2 * p2, f2 = p2 * p2, m2 = 1 - u2 * h2 * h2, _2 = m2 ? 1 / m2 : 0, g2 = m2 ? Math.acos(n3 * h2) * Math.sqrt(1 / m2) : 0, y2 = 0.5 * (2 * g2 * n3 * p2 + 2 * i2 / Math.PI) - e2, x2 = 0.5 * (g2 * o3 + r2) - t2, v2 = 0.5 * _2 * (u2 * f2 + g2 * n3 * h2 * c2) + 1 / Math.PI, b2 = _2 * (d2 * l2 / 4 - g2 * o3 * p2), w2 = 0.125 * _2 * (l2 * p2 - g2 * o3 * u2 * d2), T2 = 0.5 * _2 * (c2 * h2 + g2 * f2 * n3) + 0.5, E2 = b2 * w2 - T2 * v2;
            s2 = (x2 * b2 - y2 * T2) / E2, a2 = (y2 * w2 - x2 * v2) / E2, i2 = A(i2 - s2, -Math.PI, Math.PI), r2 = A(r2 - a2, -rh, rh);
          } while ((Math.abs(s2) > o2 || Math.abs(a2) > o2) && --n2 > 0);
          return new LngLat(x(i2), x(r2));
        }
      }
      class CylindricalEqualArea extends Projection {
        constructor(e2) {
          super(e2), this.center = e2.center || [0, 0], this.parallels = e2.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(y(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(e2, t2) {
          const { scale: i2, cosPhi: r2 } = this;
          return { x: y(e2) * r2 * i2 + 0.5, y: -Math.sin(y(t2)) / r2 * i2 + 0.5, z: 0 };
        }
        unproject(e2, t2) {
          const { scale: i2, cosPhi: r2 } = this, n2 = -(t2 - 0.5) / i2, o2 = A(x((e2 - 0.5) / i2) / r2, -180, 180), s2 = Math.asin(A(n2 * r2, -1, 1)), a2 = A(x(s2), -85.051129, qo);
          return new LngLat(o2, a2);
        }
      }
      class Globe extends Mercator {
        constructor(e2) {
          super(e2), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug", "custom"], this.range = [3, 5];
        }
        projectTilePoint(e2, t2, i2) {
          const r2 = Su(e2, t2, i2);
          return ra(r2, r2, Iu(_u(i2))), { x: r2[0], y: r2[1], z: r2[2] };
        }
        locationPoint(e2, t2) {
          const i2 = Eu(t2.lat, t2.lng), r2 = ea([], i2), n2 = e2.elevation ? e2.elevation.getAtPointOrZero(e2.locationCoordinate(t2), e2._centerAltitude) : e2._centerAltitude;
          Js(i2, i2, r2, Vo(1, 0) * ko * n2);
          const o2 = Is(new Float64Array(16));
          return Ds(o2, e2.pixelMatrix, e2.globeMatrix), ra(i2, i2, o2), new d(i2[0], i2[1]);
        }
        pixelsPerMeter(e2, t2) {
          return Vo(1, 0) * t2;
        }
        pixelSpaceConversion(e2, t2, i2) {
          const r2 = Vo(1, e2) * t2, n2 = Ii(Vo(1, 45) * t2, r2, i2);
          return this.pixelsPerMeter(e2, t2) / n2;
        }
        createTileMatrix(e2, t2, i2) {
          const r2 = Mu(_u(i2.canonical));
          return Ds(new Float64Array(16), e2.globeMatrix, r2);
        }
        createInversionMatrix(e2, t2) {
          const { center: i2 } = e2, r2 = Iu(_u(t2));
          return ks(r2, r2, y(i2.lng)), Ls(r2, r2, y(i2.lat)), zs(r2, r2, [e2._pixelsPerMercatorPixel, e2._pixelsPerMercatorPixel, 1]), Float32Array.from(r2);
        }
        pointCoordinate(e2, t2, i2, r2) {
          return fu(e2, t2, i2, true) || new MercatorCoordinate(0, 0);
        }
        pointCoordinate3D(e2, t2, i2) {
          const r2 = this.pointCoordinate(e2, t2, i2, 0);
          return [r2.x, r2.y, r2.z];
        }
        isPointAboveHorizon(e2, t2) {
          return !fu(e2, t2.x, t2.y, false);
        }
        farthestPixelDistance(e2) {
          const t2 = function(e3, t3) {
            const i3 = e3.cameraToCenterDistance, r2 = e3._centerAltitude * t3, n2 = e3._camera, o2 = e3._camera.forward(), s2 = $s([], Ys([], o2, -i3), [0, 0, r2]), a2 = e3.worldSize / (2 * Math.PI), l2 = [0, 0, -a2], c2 = e3.width / e3.height, u2 = Math.tan(e3.fovAboveCenter), h2 = Ys([], n2.up(), u2), p2 = Ys([], n2.right(), u2 * c2), d2 = ea([], $s([], $s([], o2, h2), p2)), f2 = [];
            let m2;
            if (new Ray(s2, d2).closestPointOnSphere(l2, a2, f2)) {
              const t4 = $s([], f2, l2), i4 = aa([], t4, s2);
              m2 = Math.cos(e3.fovAboveCenter) * qs(i4);
            } else {
              const e4 = aa([], s2, l2), t4 = aa([], l2, s2);
              ea(t4, t4);
              const i4 = qs(e4) - a2;
              m2 = Math.sqrt(i4 * (i4 + 2 * a2));
              const r3 = Math.acos(m2 / (a2 + i4)) - Math.acos(ta(o2, t4));
              m2 *= Math.cos(r3);
            }
            return 1.01 * m2;
          }(e2, this.pixelsPerMeter(e2.center.lat, e2.worldSize)), i2 = zu(e2.zoom);
          if (i2 > 0) {
            const r2 = Gu(e2, Vo(1, e2.center.lat) * e2.worldSize), n2 = e2.worldSize / (2 * Math.PI), o2 = Math.max(e2.width, e2.height) / e2.worldSize * Math.PI;
            return Ii(t2, r2 + n2 * (1 - Math.cos(o2)), Math.pow(i2, 10));
          }
          return t2;
        }
        upVector(e2, t2, i2) {
          return Su(t2, i2, e2, 1);
        }
        upVectorScale(e2) {
          return { metersToTile: lu * Au(_u(e2)) };
        }
      }
      function nh(e2) {
        const t2 = e2.parallels, i2 = !!t2 && Math.abs(t2[0] + t2[1]) < 0.01;
        switch (e2.name) {
          case "mercator":
            return new Mercator(e2);
          case "equirectangular":
            return new Equirectangular(e2);
          case "naturalEarth":
            return new NaturalEarth(e2);
          case "equalEarth":
            return new EqualEarth(e2);
          case "winkelTripel":
            return new WinkelTripel(e2);
          case "albers":
            return i2 ? new CylindricalEqualArea(e2) : new Albers(e2);
          case "lambertConformalConic":
            return i2 ? new CylindricalEqualArea(e2) : new LambertConformalConic(e2);
          case "globe":
            return new Globe(e2);
        }
        throw new Error(`Invalid projection name: ${e2.name}`);
      }
      const oh = zl.types, sh = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function ah(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2) {
        const d2 = a2 ? Math.min(32640, Math.round(a2[0])) : 0, f2 = a2 ? Math.min(32640, Math.round(a2[1])) : 0;
        e2.emplaceBack(t2, i2, Math.round(32 * r2), Math.round(32 * n2), o2, s2, (d2 << 1) + (l2 ? 1 : 0), f2, 16 * c2, 16 * u2, 256 * h2, 256 * p2);
      }
      function lh(e2, t2, i2, r2, n2, o2, s2) {
        e2.emplaceBack(t2, i2, r2, n2, o2, s2);
      }
      function ch(e2, t2, i2, r2, n2) {
        const o2 = 5 * t2 + 2;
        e2.float32[o2 + 0] = i2, e2.float32[o2 + 1] = r2, e2.float32[o2 + 2] = n2;
      }
      function uh(e2, t2, i2, r2, n2) {
        e2.emplaceBack(t2, i2, r2, n2), e2.emplaceBack(t2, i2, r2, n2), e2.emplaceBack(t2, i2, r2, n2), e2.emplaceBack(t2, i2, r2, n2);
      }
      function hh(e2) {
        for (const t2 of e2.sections)
          if (Hn(t2.text))
            return true;
        return false;
      }
      class SymbolBuffers {
        constructor(e2) {
          this.layoutVertexArray = new StructArrayLayout4i4ui4i24(), this.indexArray = new StructArrayLayout3ui6(), this.programConfigurations = e2, this.segments = new SegmentVector(), this.dynamicLayoutVertexArray = new StructArrayLayout4f16(), this.opacityVertexArray = new StructArrayLayout1ul4(), this.placedSymbolArray = new PlacedSymbolArray(), this.globeExtVertexArray = new StructArrayLayout3i3f20();
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
        }
        upload(e2, t2, i2, r2) {
          this.isEmpty() || (i2 && (this.layoutVertexBuffer = e2.createVertexBuffer(this.layoutVertexArray, cc.members), this.indexBuffer = e2.createIndexBuffer(this.indexArray, t2), this.dynamicLayoutVertexBuffer = e2.createVertexBuffer(this.dynamicLayoutVertexArray, hc.members, true), this.opacityVertexBuffer = e2.createVertexBuffer(this.opacityVertexArray, sh, true), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = e2.createVertexBuffer(this.globeExtVertexArray, uc.members, true)), this.opacityVertexBuffer.itemSize = 1), (i2 || r2) && this.programConfigurations.upload(e2));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
      }
      kn(SymbolBuffers, "SymbolBuffers");
      class CollisionBuffers {
        constructor(e2, t2, i2) {
          this.layoutVertexArray = new e2(), this.layoutAttributes = t2, this.indexArray = new i2(), this.segments = new SegmentVector(), this.collisionVertexArray = new StructArrayLayout2ub2f12(), this.collisionVertexArrayExt = new StructArrayLayout3f12();
        }
        upload(e2) {
          this.layoutVertexBuffer = e2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e2.createVertexBuffer(this.collisionVertexArray, pc.members, true), this.collisionVertexBufferExt = e2.createVertexBuffer(this.collisionVertexArrayExt, dc.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
        }
      }
      kn(CollisionBuffers, "CollisionBuffers");
      class SymbolBucket {
        constructor(e2) {
          this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((e3) => e3.id), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Is([]), this.placementViewportMatrix = Is([]);
          const t2 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = gc(this.zoom, t2["text-size"]), this.iconSizeData = gc(this.zoom, t2["icon-size"]);
          const i2 = this.layers[0].layout, r2 = i2.get("symbol-sort-key"), n2 = i2.get("symbol-z-order");
          this.canOverlap = i2.get("text-allow-overlap") || i2.get("icon-allow-overlap") || i2.get("text-ignore-placement") || i2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== n2 && void 0 !== r2.constantOr(1), this.sortFeaturesByY = ("viewport-y" === n2 || "auto" === n2 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = i2.get("text-writing-mode").map((e3) => Xc[e3]), this.stateDependentLayerIds = this.layers.filter((e3) => e3.isStateDependent()).map((e3) => e3.id), this.sourceID = e2.sourceID, this.projection = e2.projection;
        }
        createArrays() {
          this.text = new SymbolBuffers(new ProgramConfigurationSet(this.layers, this.zoom, (e2) => /^text/.test(e2))), this.icon = new SymbolBuffers(new ProgramConfigurationSet(this.layers, this.zoom, (e2) => /^icon/.test(e2))), this.glyphOffsetArray = new GlyphOffsetArray(), this.lineVertexArray = new SymbolLineVertexArray(), this.symbolInstances = new SymbolInstanceArray();
        }
        calculateGlyphDependencies(e2, t2, i2, r2, n2) {
          for (let i3 = 0; i3 < e2.length; i3++)
            if (t2[e2.charCodeAt(i3)] = true, r2 && n2) {
              const r3 = wc[e2.charAt(i3)];
              r3 && (t2[r3.charCodeAt(0)] = true);
            }
        }
        populate(e2, t2, i2, r2) {
          const n2 = this.layers[0], o2 = n2.layout, s2 = "globe" === this.projection.name, a2 = o2.get("text-font"), l2 = o2.get("text-field"), c2 = o2.get("icon-image"), u2 = ("constant" !== l2.value.kind || l2.value.value instanceof Formatted && !l2.value.value.isEmpty() || l2.value.value.toString().length > 0) && ("constant" !== a2.value.kind || a2.value.value.length > 0), h2 = "constant" !== c2.value.kind || !!c2.value.value || Object.keys(c2.parameters).length > 0, p2 = o2.get("symbol-sort-key");
          if (this.features = [], !u2 && !h2)
            return;
          const d2 = t2.iconDependencies, f2 = t2.glyphDependencies, m2 = t2.availableImages, _2 = new EvaluationParameters(this.zoom);
          for (const { feature: t3, id: l3, index: c3, sourceLayerIndex: g2 } of e2) {
            const e3 = n2._featureFilter.needGeometry, y2 = es(t3, e3);
            if (!n2._featureFilter.filter(_2, y2, i2))
              continue;
            if (e3 || (y2.geometry = Qo(t3, i2, r2)), s2 && 1 !== t3.type && i2.z <= 5) {
              const e4 = y2.geometry, t4 = 0.98078528056, r3 = (e5, r4) => ta(Su(e5.x, e5.y, i2, 1), Su(r4.x, r4.y, i2, 1)) < t4;
              for (let t5 = 0; t5 < e4.length; t5++)
                e4[t5] = Xo(e4[t5], r3);
            }
            let x2, v2;
            if (u2) {
              const e4 = n2.getValueAndResolveTokens("text-field", y2, i2, m2), t4 = Formatted.factory(e4);
              hh(t4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === no() || this.hasRTLText && so.isParsed()) && (x2 = bc(t4, n2, y2));
            }
            if (h2) {
              const e4 = n2.getValueAndResolveTokens("icon-image", y2, i2, m2);
              v2 = e4 instanceof ResolvedImage ? e4 : ResolvedImage.fromString(e4);
            }
            if (!x2 && !v2)
              continue;
            const b2 = this.sortFeaturesByKey ? p2.evaluate(y2, {}, i2) : void 0;
            if (this.features.push({ id: l3, text: x2, icon: v2, index: c3, sourceLayerIndex: g2, geometry: y2.geometry, properties: t3.properties, type: oh[t3.type], sortKey: b2 }), v2 && (d2[v2.name] = true), x2) {
              const e4 = a2.evaluate(y2, {}, i2).join(","), t4 = "map" === o2.get("text-rotation-alignment") && "point" !== o2.get("symbol-placement");
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Xc.vertical) >= 0;
              for (const i3 of x2.sections)
                if (i3.image)
                  d2[i3.image.name] = true;
                else {
                  const r3 = qn(x2.toString()), n3 = i3.fontStack || e4, o3 = f2[n3] = f2[n3] || {};
                  this.calculateGlyphDependencies(i3.text, o3, t4, this.allowVerticalPlacement, r3);
                }
            }
          }
          "line" === o2.get("symbol-placement") && (this.features = function(e3) {
            const t3 = {}, i3 = {}, r3 = [];
            let n3 = 0;
            function o3(t4) {
              r3.push(e3[t4]), n3++;
            }
            function s3(e4, t4, n4) {
              const o4 = i3[e4];
              return delete i3[e4], i3[t4] = o4, r3[o4].geometry[0].pop(), r3[o4].geometry[0] = r3[o4].geometry[0].concat(n4[0]), o4;
            }
            function a3(e4, i4, n4) {
              const o4 = t3[i4];
              return delete t3[i4], t3[e4] = o4, r3[o4].geometry[0].shift(), r3[o4].geometry[0] = n4[0].concat(r3[o4].geometry[0]), o4;
            }
            function l3(e4, t4, i4) {
              const r4 = i4 ? t4[0][t4[0].length - 1] : t4[0][0];
              return `${e4}:${r4.x}:${r4.y}`;
            }
            for (let c3 = 0; c3 < e3.length; c3++) {
              const u3 = e3[c3], h3 = u3.geometry, p3 = u3.text ? u3.text.toString() : null;
              if (!p3) {
                o3(c3);
                continue;
              }
              const d3 = l3(p3, h3), f3 = l3(p3, h3, true);
              if (d3 in i3 && f3 in t3 && i3[d3] !== t3[f3]) {
                const e4 = a3(d3, f3, h3), n4 = s3(d3, f3, r3[e4].geometry);
                delete t3[d3], delete i3[f3], i3[l3(p3, r3[n4].geometry, true)] = n4, r3[e4].geometry = null;
              } else
                d3 in i3 ? s3(d3, f3, h3) : f3 in t3 ? a3(d3, f3, h3) : (o3(c3), t3[d3] = n3 - 1, i3[f3] = n3 - 1);
            }
            return r3.filter((e4) => e4.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((e3, t3) => e3.sortKey - t3.sortKey);
        }
        update(e2, t2, i2, r2) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e2, t2, this.layers, i2, r2), this.icon.programConfigurations.updatePaintArrays(e2, t2, this.layers, i2, r2));
        }
        isEmpty() {
          return 0 === this.symbolInstances.length && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(e2) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e2), this.iconCollisionBox.upload(e2)), this.text.upload(e2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        getProjection() {
          return this.projectionInstance || (this.projectionInstance = nh(this.projection)), this.projectionInstance;
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(e2, t2) {
          const i2 = this.lineVertexArray.length;
          if (void 0 !== e2.segment)
            for (const { x: e3, y: i3 } of t2)
              this.lineVertexArray.emplaceBack(e3, i3);
          return { lineStartIndex: i2, lineLength: this.lineVertexArray.length - i2 };
        }
        addSymbols(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2) {
          const f2 = e2.indexArray, m2 = e2.layoutVertexArray, _2 = e2.globeExtVertexArray, g2 = e2.segments.prepareSegment(4 * t2.length, m2, f2, this.canOverlap ? o2.sortKey : void 0), y2 = this.glyphOffsetArray.length, x2 = g2.vertexLength, v2 = this.allowVerticalPlacement && s2 === Xc.vertical ? Math.PI / 2 : 0, b2 = o2.text && o2.text.sections;
          for (let r3 = 0; r3 < t2.length; r3++) {
            const { tl: n3, tr: s3, bl: c3, br: u3, tex: h3, pixelOffsetTL: y3, pixelOffsetBR: x3, minFontScaleX: w3, minFontScaleY: T2, glyphOffset: E2, isSDF: S2, sectionIndex: A2 } = t2[r3], C2 = g2.vertexLength, I2 = E2[1];
            if (ah(m2, l2.x, l2.y, n3.x, I2 + n3.y, h3.x, h3.y, i2, S2, y3.x, y3.y, w3, T2), ah(m2, l2.x, l2.y, s3.x, I2 + s3.y, h3.x + h3.w, h3.y, i2, S2, x3.x, y3.y, w3, T2), ah(m2, l2.x, l2.y, c3.x, I2 + c3.y, h3.x, h3.y + h3.h, i2, S2, y3.x, x3.y, w3, T2), ah(m2, l2.x, l2.y, u3.x, I2 + u3.y, h3.x + h3.w, h3.y + h3.h, i2, S2, x3.x, x3.y, w3, T2), a2) {
              const { x: t3, y: i3, z: r4 } = a2.anchor, [n4, o3, s4] = a2.up;
              lh(_2, t3, i3, r4, n4, o3, s4), lh(_2, t3, i3, r4, n4, o3, s4), lh(_2, t3, i3, r4, n4, o3, s4), lh(_2, t3, i3, r4, n4, o3, s4), uh(e2.dynamicLayoutVertexArray, t3, i3, r4, v2);
            } else
              uh(e2.dynamicLayoutVertexArray, l2.x, l2.y, l2.z, v2);
            f2.emplaceBack(C2, C2 + 1, C2 + 2), f2.emplaceBack(C2 + 1, C2 + 2, C2 + 3), g2.vertexLength += 4, g2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(E2[0]), r3 !== t2.length - 1 && A2 === t2[r3 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(m2.length, o2, o2.index, {}, p2, d2, b2 && b2[A2]);
          }
          const w2 = a2 ? a2.anchor : l2;
          e2.placedSymbolArray.emplaceBack(w2.x, w2.y, w2.z, l2.x, l2.y, y2, this.glyphOffsetArray.length - y2, x2, c2, u2, l2.segment, i2 ? i2[0] : 0, i2 ? i2[1] : 0, r2[0], r2[1], s2, 0, false, 0, h2, 0);
        }
        _commitLayoutVertex(e2, t2, i2, r2, n2, o2, s2) {
          e2.emplaceBack(t2, i2, r2, n2, o2, Math.round(s2.x), Math.round(s2.y));
        }
        _addCollisionDebugVertices(e2, t2, i2, r2, n2, o2, s2) {
          const a2 = i2.segments.prepareSegment(4, i2.layoutVertexArray, i2.indexArray), l2 = a2.vertexLength, c2 = s2.tileAnchorX, u2 = s2.tileAnchorY;
          for (let e3 = 0; e3 < 4; e3++)
            i2.collisionVertexArray.emplaceBack(0, 0, 0, 0);
          i2.collisionVertexArrayExt.emplaceBack(t2, -e2.padding, -e2.padding), i2.collisionVertexArrayExt.emplaceBack(t2, e2.padding, -e2.padding), i2.collisionVertexArrayExt.emplaceBack(t2, e2.padding, e2.padding), i2.collisionVertexArrayExt.emplaceBack(t2, -e2.padding, e2.padding), this._commitLayoutVertex(i2.layoutVertexArray, r2, n2, o2, c2, u2, new d(e2.x1, e2.y1)), this._commitLayoutVertex(i2.layoutVertexArray, r2, n2, o2, c2, u2, new d(e2.x2, e2.y1)), this._commitLayoutVertex(i2.layoutVertexArray, r2, n2, o2, c2, u2, new d(e2.x2, e2.y2)), this._commitLayoutVertex(i2.layoutVertexArray, r2, n2, o2, c2, u2, new d(e2.x1, e2.y2)), a2.vertexLength += 4;
          const h2 = i2.indexArray;
          h2.emplaceBack(l2, l2 + 1), h2.emplaceBack(l2 + 1, l2 + 2), h2.emplaceBack(l2 + 2, l2 + 3), h2.emplaceBack(l2 + 3, l2), a2.primitiveLength += 4;
        }
        _addTextDebugCollisionBoxes(e2, t2, i2, r2, n2, o2) {
          for (let s2 = r2; s2 < n2; s2++) {
            const r3 = i2.get(s2), n3 = this.getSymbolInstanceTextSize(e2, o2, t2, s2);
            this._addCollisionDebugVertices(r3, n3, this.textCollisionBox, r3.projectedAnchorX, r3.projectedAnchorY, r3.projectedAnchorZ, o2);
          }
        }
        _addIconDebugCollisionBoxes(e2, t2, i2, r2, n2, o2) {
          for (let s2 = r2; s2 < n2; s2++) {
            const r3 = i2.get(s2), n3 = this.getSymbolInstanceIconSize(e2, t2, o2.placedIconSymbolIndex);
            this._addCollisionDebugVertices(r3, n3, this.iconCollisionBox, r3.projectedAnchorX, r3.projectedAnchorY, r3.projectedAnchorZ, o2);
          }
        }
        generateCollisionDebugBuffers(e2, t2) {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new CollisionBuffers(StructArrayLayout3i2i2i16, fc.members, StructArrayLayout2ui4), this.iconCollisionBox = new CollisionBuffers(StructArrayLayout3i2i2i16, fc.members, StructArrayLayout2ui4);
          const i2 = xc(this.iconSizeData, e2), r2 = xc(this.textSizeData, e2);
          for (let n2 = 0; n2 < this.symbolInstances.length; n2++) {
            const o2 = this.symbolInstances.get(n2);
            this._addTextDebugCollisionBoxes(r2, e2, t2, o2.textBoxStartIndex, o2.textBoxEndIndex, o2), this._addTextDebugCollisionBoxes(r2, e2, t2, o2.verticalTextBoxStartIndex, o2.verticalTextBoxEndIndex, o2), this._addIconDebugCollisionBoxes(i2, e2, t2, o2.iconBoxStartIndex, o2.iconBoxEndIndex, o2), this._addIconDebugCollisionBoxes(i2, e2, t2, o2.verticalIconBoxStartIndex, o2.verticalIconBoxEndIndex, o2);
          }
        }
        getSymbolInstanceTextSize(e2, t2, i2, r2) {
          const n2 = this.text.placedSymbolArray.get(t2.rightJustifiedTextSymbolIndex >= 0 ? t2.rightJustifiedTextSymbolIndex : t2.centerJustifiedTextSymbolIndex >= 0 ? t2.centerJustifiedTextSymbolIndex : t2.leftJustifiedTextSymbolIndex >= 0 ? t2.leftJustifiedTextSymbolIndex : t2.verticalPlacedTextSymbolIndex >= 0 ? t2.verticalPlacedTextSymbolIndex : r2), o2 = yc(this.textSizeData, e2, n2) / 24;
          return this.tilePixelRatio * o2;
        }
        getSymbolInstanceIconSize(e2, t2, i2) {
          const r2 = this.icon.placedSymbolArray.get(i2), n2 = yc(this.iconSizeData, e2, r2);
          return this.tilePixelRatio * n2;
        }
        _commitDebugCollisionVertexUpdate(e2, t2, i2) {
          e2.emplaceBack(t2, -i2, -i2), e2.emplaceBack(t2, i2, -i2), e2.emplaceBack(t2, i2, i2), e2.emplaceBack(t2, -i2, i2);
        }
        _updateTextDebugCollisionBoxes(e2, t2, i2, r2, n2, o2) {
          for (let s2 = r2; s2 < n2; s2++) {
            const r3 = i2.get(s2), n3 = this.getSymbolInstanceTextSize(e2, o2, t2, s2);
            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, n3, r3.padding);
          }
        }
        _updateIconDebugCollisionBoxes(e2, t2, i2, r2, n2, o2) {
          for (let s2 = r2; s2 < n2; s2++) {
            const r3 = i2.get(s2), n3 = this.getSymbolInstanceIconSize(e2, t2, o2);
            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, n3, r3.padding);
          }
        }
        updateCollisionDebugBuffers(e2, t2) {
          if (!this.hasDebugData())
            return;
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
          const i2 = xc(this.iconSizeData, e2), r2 = xc(this.textSizeData, e2);
          for (let n2 = 0; n2 < this.symbolInstances.length; n2++) {
            const o2 = this.symbolInstances.get(n2);
            this._updateTextDebugCollisionBoxes(r2, e2, t2, o2.textBoxStartIndex, o2.textBoxEndIndex, o2), this._updateTextDebugCollisionBoxes(r2, e2, t2, o2.verticalTextBoxStartIndex, o2.verticalTextBoxEndIndex, o2), this._updateIconDebugCollisionBoxes(i2, e2, t2, o2.iconBoxStartIndex, o2.iconBoxEndIndex, o2.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(i2, e2, t2, o2.verticalIconBoxStartIndex, o2.verticalIconBoxEndIndex, o2.placedIconSymbolIndex);
          }
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
        }
        _deserializeCollisionBoxesForSymbol(e2, t2, i2, r2, n2, o2, s2, a2, l2) {
          const c2 = {};
          if (t2 < i2) {
            const { x1: i3, y1: r3, x2: n3, y2: o3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: u2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: d2 } = e2.get(t2);
            c2.textBox = { x1: i3, y1: r3, x2: n3, y2: o3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: u2, tileAnchorX: h2, tileAnchorY: p2 }, c2.textFeatureIndex = d2;
          }
          if (r2 < n2) {
            const { x1: t3, y1: i3, x2: n3, y2: o3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: u2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: d2 } = e2.get(r2);
            c2.verticalTextBox = { x1: t3, y1: i3, x2: n3, y2: o3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: u2, tileAnchorX: h2, tileAnchorY: p2 }, c2.verticalTextFeatureIndex = d2;
          }
          if (o2 < s2) {
            const { x1: t3, y1: i3, x2: r3, y2: n3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: u2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: d2 } = e2.get(o2);
            c2.iconBox = { x1: t3, y1: i3, x2: r3, y2: n3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: u2, tileAnchorX: h2, tileAnchorY: p2 }, c2.iconFeatureIndex = d2;
          }
          if (a2 < l2) {
            const { x1: t3, y1: i3, x2: r3, y2: n3, padding: o3, projectedAnchorX: s3, projectedAnchorY: l3, projectedAnchorZ: u2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: d2 } = e2.get(a2);
            c2.verticalIconBox = { x1: t3, y1: i3, x2: r3, y2: n3, padding: o3, projectedAnchorX: s3, projectedAnchorY: l3, projectedAnchorZ: u2, tileAnchorX: h2, tileAnchorY: p2 }, c2.verticalIconFeatureIndex = d2;
          }
          return c2;
        }
        deserializeCollisionBoxes(e2) {
          this.collisionArrays = [];
          for (let t2 = 0; t2 < this.symbolInstances.length; t2++) {
            const i2 = this.symbolInstances.get(t2);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e2, i2.textBoxStartIndex, i2.textBoxEndIndex, i2.verticalTextBoxStartIndex, i2.verticalTextBoxEndIndex, i2.iconBoxStartIndex, i2.iconBoxEndIndex, i2.verticalIconBoxStartIndex, i2.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(e2, t2) {
          const i2 = e2.placedSymbolArray.get(t2), r2 = i2.vertexStartIndex + 4 * i2.numGlyphs;
          for (let t3 = i2.vertexStartIndex; t3 < r2; t3 += 4)
            e2.indexArray.emplaceBack(t3, t3 + 1, t3 + 2), e2.indexArray.emplaceBack(t3 + 1, t3 + 2, t3 + 3);
        }
        getSortedSymbolIndexes(e2) {
          if (this.sortedAngle === e2 && void 0 !== this.symbolInstanceIndexes)
            return this.symbolInstanceIndexes;
          const t2 = Math.sin(e2), i2 = Math.cos(e2), r2 = [], n2 = [], o2 = [];
          for (let e3 = 0; e3 < this.symbolInstances.length; ++e3) {
            o2.push(e3);
            const s2 = this.symbolInstances.get(e3);
            r2.push(0 | Math.round(t2 * s2.tileAnchorX + i2 * s2.tileAnchorY)), n2.push(s2.featureIndex);
          }
          return o2.sort((e3, t3) => r2[e3] - r2[t3] || n2[t3] - n2[e3]), o2;
        }
        addToSortKeyRanges(e2, t2) {
          const i2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          i2 && i2.sortKey === t2 ? i2.symbolInstanceEnd = e2 + 1 : this.sortKeyRanges.push({ sortKey: t2, symbolInstanceStart: e2, symbolInstanceEnd: e2 + 1 });
        }
        sortFeatures(e2) {
          if (this.sortFeaturesByY && this.sortedAngle !== e2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e2), this.sortedAngle = e2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const e3 of this.symbolInstanceIndexes) {
              const t2 = this.symbolInstances.get(e3);
              this.featureSortOrder.push(t2.featureIndex);
              const { rightJustifiedTextSymbolIndex: i2, centerJustifiedTextSymbolIndex: r2, leftJustifiedTextSymbolIndex: n2, verticalPlacedTextSymbolIndex: o2, placedIconSymbolIndex: s2, verticalPlacedIconSymbolIndex: a2 } = t2;
              i2 >= 0 && this.addIndicesForPlacedSymbol(this.text, i2), r2 >= 0 && r2 !== i2 && this.addIndicesForPlacedSymbol(this.text, r2), n2 >= 0 && n2 !== r2 && n2 !== i2 && this.addIndicesForPlacedSymbol(this.text, n2), o2 >= 0 && this.addIndicesForPlacedSymbol(this.text, o2), s2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, s2), a2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a2);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      kn(SymbolBucket, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), SymbolBucket.MAX_GLYPHS = 65535, SymbolBucket.addDynamicAttributes = uh;
      const ph = new Properties({ "symbol-placement": new DataConstantProperty(ft.layout_symbol["symbol-placement"]), "symbol-spacing": new DataConstantProperty(ft.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new DataConstantProperty(ft.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new DataDrivenProperty(ft.layout_symbol["symbol-sort-key"]), "symbol-z-order": new DataConstantProperty(ft.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new DataConstantProperty(ft.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new DataConstantProperty(ft.layout_symbol["icon-ignore-placement"]), "icon-optional": new DataConstantProperty(ft.layout_symbol["icon-optional"]), "icon-rotation-alignment": new DataConstantProperty(ft.layout_symbol["icon-rotation-alignment"]), "icon-size": new DataDrivenProperty(ft.layout_symbol["icon-size"]), "icon-text-fit": new DataConstantProperty(ft.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new DataConstantProperty(ft.layout_symbol["icon-text-fit-padding"]), "icon-image": new DataDrivenProperty(ft.layout_symbol["icon-image"]), "icon-rotate": new DataDrivenProperty(ft.layout_symbol["icon-rotate"]), "icon-padding": new DataConstantProperty(ft.layout_symbol["icon-padding"]), "icon-keep-upright": new DataConstantProperty(ft.layout_symbol["icon-keep-upright"]), "icon-offset": new DataDrivenProperty(ft.layout_symbol["icon-offset"]), "icon-anchor": new DataDrivenProperty(ft.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new DataConstantProperty(ft.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new DataConstantProperty(ft.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new DataConstantProperty(ft.layout_symbol["text-rotation-alignment"]), "text-field": new DataDrivenProperty(ft.layout_symbol["text-field"]), "text-font": new DataDrivenProperty(ft.layout_symbol["text-font"]), "text-size": new DataDrivenProperty(ft.layout_symbol["text-size"]), "text-max-width": new DataDrivenProperty(ft.layout_symbol["text-max-width"]), "text-line-height": new DataDrivenProperty(ft.layout_symbol["text-line-height"]), "text-letter-spacing": new DataDrivenProperty(ft.layout_symbol["text-letter-spacing"]), "text-justify": new DataDrivenProperty(ft.layout_symbol["text-justify"]), "text-radial-offset": new DataDrivenProperty(ft.layout_symbol["text-radial-offset"]), "text-variable-anchor": new DataConstantProperty(ft.layout_symbol["text-variable-anchor"]), "text-anchor": new DataDrivenProperty(ft.layout_symbol["text-anchor"]), "text-max-angle": new DataConstantProperty(ft.layout_symbol["text-max-angle"]), "text-writing-mode": new DataConstantProperty(ft.layout_symbol["text-writing-mode"]), "text-rotate": new DataDrivenProperty(ft.layout_symbol["text-rotate"]), "text-padding": new DataConstantProperty(ft.layout_symbol["text-padding"]), "text-keep-upright": new DataConstantProperty(ft.layout_symbol["text-keep-upright"]), "text-transform": new DataDrivenProperty(ft.layout_symbol["text-transform"]), "text-offset": new DataDrivenProperty(ft.layout_symbol["text-offset"]), "text-allow-overlap": new DataConstantProperty(ft.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new DataConstantProperty(ft.layout_symbol["text-ignore-placement"]), "text-optional": new DataConstantProperty(ft.layout_symbol["text-optional"]) });
      var dh = { paint: new Properties({ "icon-opacity": new DataDrivenProperty(ft.paint_symbol["icon-opacity"]), "icon-color": new DataDrivenProperty(ft.paint_symbol["icon-color"]), "icon-halo-color": new DataDrivenProperty(ft.paint_symbol["icon-halo-color"]), "icon-halo-width": new DataDrivenProperty(ft.paint_symbol["icon-halo-width"]), "icon-halo-blur": new DataDrivenProperty(ft.paint_symbol["icon-halo-blur"]), "icon-translate": new DataConstantProperty(ft.paint_symbol["icon-translate"]), "icon-translate-anchor": new DataConstantProperty(ft.paint_symbol["icon-translate-anchor"]), "text-opacity": new DataDrivenProperty(ft.paint_symbol["text-opacity"]), "text-color": new DataDrivenProperty(ft.paint_symbol["text-color"], { runtimeType: Et, getOverride: (e2) => e2.textColor, hasOverride: (e2) => !!e2.textColor }), "text-halo-color": new DataDrivenProperty(ft.paint_symbol["text-halo-color"]), "text-halo-width": new DataDrivenProperty(ft.paint_symbol["text-halo-width"]), "text-halo-blur": new DataDrivenProperty(ft.paint_symbol["text-halo-blur"]), "text-translate": new DataConstantProperty(ft.paint_symbol["text-translate"]), "text-translate-anchor": new DataConstantProperty(ft.paint_symbol["text-translate-anchor"]) }), layout: ph };
      class FormatSectionOverride {
        constructor(e2) {
          this.type = e2.property.overrides ? e2.property.overrides.runtimeType : vt, this.defaultValue = e2;
        }
        evaluate(e2) {
          if (e2.formattedSection) {
            const t2 = this.defaultValue.property.overrides;
            if (t2 && t2.hasOverride(e2.formattedSection))
              return t2.getOverride(e2.formattedSection);
          }
          return e2.feature && e2.featureState ? this.defaultValue.evaluate(e2.feature, e2.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(e2) {
          this.defaultValue.isConstant() || e2(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      kn(FormatSectionOverride, "FormatSectionOverride", { omit: ["defaultValue"] });
      class SymbolStyleLayer extends StyleLayer {
        constructor(e2) {
          super(e2, dh);
        }
        recalculate(e2, t2) {
          super.recalculate(e2, t2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
          const i2 = this.layout.get("text-writing-mode");
          if (i2) {
            const e3 = [];
            for (const t3 of i2)
              e3.indexOf(t3) < 0 && e3.push(t3);
            this.layout._values["text-writing-mode"] = e3;
          } else
            this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(e2, t2, i2, r2) {
          const n2 = this.layout.get(e2).evaluate(t2, {}, i2, r2), o2 = this._unevaluatedLayout._values[e2];
          return o2.isDataDriven() || zr(o2.value) || !n2 ? n2 : function(e3, t3) {
            return t3.replace(/{([^{}]+)}/g, (t4, i3) => i3 in e3 ? String(e3[i3]) : "");
          }(t2.properties, n2);
        }
        createBucket(e2) {
          return new SymbolBucket(e2);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        _setPaintOverrides() {
          for (const e2 of dh.paint.overridableProperties) {
            if (!SymbolStyleLayer.hasPaintOverride(this.layout, e2))
              continue;
            const t2 = this.paint.get(e2), i2 = new FormatSectionOverride(t2), r2 = new StyleExpression(i2, t2.property.specification);
            let n2 = null;
            n2 = "constant" === t2.value.kind || "source" === t2.value.kind ? new ZoomConstantExpression("source", r2) : new ZoomDependentExpression("composite", r2, t2.value.zoomStops, t2.value._interpolationType), this.paint._values[e2] = new PossiblyEvaluatedPropertyValue(t2.property, n2, t2.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(e2, t2, i2) {
          return !(!this.layout || t2.isDataDriven() || i2.isDataDriven()) && SymbolStyleLayer.hasPaintOverride(this.layout, e2);
        }
        static hasPaintOverride(e2, t2) {
          const i2 = e2.get("text-field"), r2 = dh.paint.properties[t2];
          let n2 = false;
          const o2 = (e3) => {
            for (const t3 of e3)
              if (r2.overrides && r2.overrides.hasOverride(t3))
                return void (n2 = true);
          };
          if ("constant" === i2.value.kind && i2.value.value instanceof Formatted)
            o2(i2.value.value.sections);
          else if ("source" === i2.value.kind) {
            const e3 = (t4) => {
              n2 || (t4 instanceof Ht && $t(t4.value) === Mt ? o2(t4.value.sections) : t4 instanceof FormatExpression ? o2(t4.sections) : t4.eachChild(e3));
            }, t3 = i2.value;
            t3._styleExpression && e3(t3._styleExpression.expression);
          }
          return n2;
        }
        getProgramConfiguration(e2) {
          return new ProgramConfiguration(this, e2);
        }
      }
      var fh = { paint: new Properties({ "background-color": new DataConstantProperty(ft.paint_background["background-color"]), "background-pattern": new DataConstantProperty(ft.paint_background["background-pattern"]), "background-opacity": new DataConstantProperty(ft.paint_background["background-opacity"]) }) }, mh = { paint: new Properties({ "raster-opacity": new DataConstantProperty(ft.paint_raster["raster-opacity"]), "raster-hue-rotate": new DataConstantProperty(ft.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new DataConstantProperty(ft.paint_raster["raster-brightness-min"]), "raster-brightness-max": new DataConstantProperty(ft.paint_raster["raster-brightness-max"]), "raster-saturation": new DataConstantProperty(ft.paint_raster["raster-saturation"]), "raster-contrast": new DataConstantProperty(ft.paint_raster["raster-contrast"]), "raster-resampling": new DataConstantProperty(ft.paint_raster["raster-resampling"]), "raster-fade-duration": new DataConstantProperty(ft.paint_raster["raster-fade-duration"]) }) };
      class CustomStyleLayer extends StyleLayer {
        constructor(e2) {
          super(e2, {}), this.implementation = e2;
        }
        is3D() {
          return "3d" === this.implementation.renderingMode;
        }
        hasOffscreenPass() {
          return void 0 !== this.implementation.prerender;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return false;
        }
        serialize() {
        }
        onAdd(e2) {
          this.implementation.onAdd && this.implementation.onAdd(e2, e2.painter.context.gl);
        }
        onRemove(e2) {
          this.implementation.onRemove && this.implementation.onRemove(e2, e2.painter.context.gl);
        }
      }
      var _h = { paint: new Properties({ "sky-type": new DataConstantProperty(ft.paint_sky["sky-type"]), "sky-atmosphere-sun": new DataConstantProperty(ft.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new DataConstantProperty(ft.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new DataConstantProperty(ft.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new DataConstantProperty(ft.paint_sky["sky-gradient-radius"]), "sky-gradient": new ColorRampProperty(ft.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new DataConstantProperty(ft.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new DataConstantProperty(ft.paint_sky["sky-atmosphere-color"]), "sky-opacity": new DataConstantProperty(ft.paint_sky["sky-opacity"]) }) };
      function gh(e2, t2, i2) {
        const r2 = [0, 0, 1], n2 = ma([]);
        return ga(n2, n2, i2 ? -y(e2) + Math.PI : y(e2)), _a(n2, n2, -y(t2)), oa(r2, r2, n2), ea(r2, r2);
      }
      const yh = { circle: class CircleStyleLayer extends StyleLayer {
        constructor(e2) {
          super(e2, vs);
        }
        createBucket(e2) {
          return new CircleBucket(e2);
        }
        queryRadius(e2) {
          const t2 = e2;
          return ms("circle-radius", this, t2) + ms("circle-stroke-width", this, t2) + _s(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(e2, t2, i2, r2, n2, o2, s2, a2) {
          const l2 = ys(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), o2.angle, e2.pixelToTileUnitsFactor), c2 = this.paint.get("circle-radius").evaluate(t2, i2) + this.paint.get("circle-stroke-width").evaluate(t2, i2);
          return va(e2, r2, o2, s2, a2, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l2, c2);
        }
        getProgramIds() {
          return ["circle"];
        }
        getProgramConfiguration(e2) {
          return new ProgramConfiguration(this, e2);
        }
      }, heatmap: class HeatmapStyleLayer extends StyleLayer {
        createBucket(e2) {
          return new HeatmapBucket(e2);
        }
        constructor(e2) {
          super(e2, Ia), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(e2) {
          "heatmap-color" === e2 && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = Ma({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius(e2) {
          return ms("heatmap-radius", this, e2);
        }
        queryIntersectsFeature(e2, t2, i2, r2, n2, o2, s2, a2) {
          const l2 = this.paint.get("heatmap-radius").evaluate(t2, i2);
          return va(e2, r2, o2, s2, a2, true, true, new d(0, 0), l2);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }
        getProgramConfiguration(e2) {
          return new ProgramConfiguration(this, e2);
        }
      }, hillshade: class HillshadeStyleLayer extends StyleLayer {
        constructor(e2) {
          super(e2, Da);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }
      }, fill: class FillStyleLayer extends StyleLayer {
        constructor(e2) {
          super(e2, ml);
        }
        getProgramIds() {
          const e2 = this.paint.get("fill-pattern"), t2 = e2 && e2.constantOr(1), i2 = [t2 ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && i2.push(t2 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), i2;
        }
        getProgramConfiguration(e2) {
          return new ProgramConfiguration(this, e2);
        }
        recalculate(e2, t2) {
          super.recalculate(e2, t2);
          const i2 = this.paint._values["fill-outline-color"];
          "constant" === i2.value.kind && void 0 === i2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(e2) {
          return new FillBucket(e2);
        }
        queryRadius() {
          return _s(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(e2, t2, i2, r2, n2, o2) {
          return !e2.queryGeometry.isAboveHorizon && os(gs(e2.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), o2.angle, e2.pixelToTileUnitsFactor), r2);
        }
        isTileClipped() {
          return true;
        }
      }, "fill-extrusion": class FillExtrusionStyleLayer extends StyleLayer {
        constructor(e2) {
          super(e2, Wl);
        }
        createBucket(e2) {
          return new FillExtrusionBucket(e2);
        }
        queryRadius() {
          return _s(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return true;
        }
        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }
        getProgramConfiguration(e2) {
          return new ProgramConfiguration(this, e2);
        }
        queryIntersectsFeature(e2, t2, i2, r2, n2, o2, s2, a2, l2) {
          const c2 = ys(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o2.angle, e2.pixelToTileUnitsFactor), u2 = this.paint.get("fill-extrusion-height").evaluate(t2, i2), h2 = this.paint.get("fill-extrusion-base").evaluate(t2, i2), p2 = [0, 0], f2 = a2 && o2.elevation, m2 = o2.elevation ? o2.elevation.exaggeration() : 1, _2 = e2.tile.getBucket(this);
          if (f2 && _2 instanceof FillExtrusionBucket) {
            const e3 = _2.centroidVertexArray, t3 = l2 + 1;
            t3 < e3.length && (p2[0] = e3.geta_centroid_pos0(t3), p2[1] = e3.geta_centroid_pos1(t3));
          }
          if (0 === p2[0] && 1 === p2[1])
            return false;
          "globe" === o2.projection.name && (r2 = Zl([r2], [new d(0, 0), new d(ko, ko)], e2.tileID.canonical).map((e3) => e3.polygon).flat());
          const g2 = f2 ? a2 : null, [y2, x2] = function(e3, t3, i3, r3, n3, o3, s3, a3, l3, c3, u3) {
            return "globe" === e3.projection.name ? function(e4, t4, i4, r4, n4, o4, s4, a4, l4, c4, u4) {
              const h3 = [], p3 = [], d2 = e4.projection.upVectorScale(u4, e4.center.lat, e4.worldSize).metersToTile, f3 = [0, 0, 0, 1], m3 = [0, 0, 0, 1], _3 = (e5, t5, i5, r5) => {
                e5[0] = t5, e5[1] = i5, e5[2] = r5, e5[3] = 1;
              }, g3 = ql();
              i4 > 0 && (i4 += g3), r4 += g3;
              for (const g4 of t4) {
                const t5 = [], y3 = [];
                for (const h4 of g4) {
                  const p4 = h4.x + n4.x, g5 = h4.y + n4.y, x3 = e4.projection.projectTilePoint(p4, g5, u4), v3 = e4.projection.upVector(u4, h4.x, h4.y);
                  let b2 = i4, w2 = r4;
                  if (s4) {
                    const e5 = Jl(p4, g5, i4, r4, s4, a4, l4, c4);
                    b2 += e5.base, w2 += e5.top;
                  }
                  0 !== i4 ? _3(f3, x3.x + v3[0] * d2 * b2, x3.y + v3[1] * d2 * b2, x3.z + v3[2] * d2 * b2) : _3(f3, x3.x, x3.y, x3.z), _3(m3, x3.x + v3[0] * d2 * w2, x3.y + v3[1] * d2 * w2, x3.z + v3[2] * d2 * w2), ra(f3, f3, o4), ra(m3, m3, o4), t5.push(new Point3D(f3[0], f3[1], f3[2])), y3.push(new Point3D(m3[0], m3[1], m3[2]));
                }
                h3.push(t5), p3.push(y3);
              }
              return [h3, p3];
            }(e3, t3, i3, r3, n3, o3, s3, a3, l3, c3, u3) : s3 ? function(e4, t4, i4, r4, n4, o4, s4, a4, l4) {
              const c4 = [], u4 = [], h3 = [0, 0, 0, 1];
              for (const p3 of e4) {
                const e5 = [], d2 = [];
                for (const c5 of p3) {
                  const u5 = c5.x + r4.x, p4 = c5.y + r4.y, f3 = Jl(u5, p4, t4, i4, o4, s4, a4, l4);
                  h3[0] = u5, h3[1] = p4, h3[2] = f3.base, h3[3] = 1, da(h3, h3, n4), h3[3] = Math.max(h3[3], 1e-5);
                  const m3 = new Point3D(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                  h3[0] = u5, h3[1] = p4, h3[2] = f3.top, h3[3] = 1, da(h3, h3, n4), h3[3] = Math.max(h3[3], 1e-5);
                  const _3 = new Point3D(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                  e5.push(m3), d2.push(_3);
                }
                c4.push(e5), u4.push(d2);
              }
              return [c4, u4];
            }(t3, i3, r3, n3, o3, s3, a3, l3, c3) : function(e4, t4, i4, r4, n4) {
              const o4 = [], s4 = [], a4 = n4[8] * t4, l4 = n4[9] * t4, c4 = n4[10] * t4, u4 = n4[11] * t4, h3 = n4[8] * i4, p3 = n4[9] * i4, d2 = n4[10] * i4, f3 = n4[11] * i4;
              for (const t5 of e4) {
                const e5 = [], i5 = [];
                for (const o5 of t5) {
                  const t6 = o5.x + r4.x, s5 = o5.y + r4.y, m3 = n4[0] * t6 + n4[4] * s5 + n4[12], _3 = n4[1] * t6 + n4[5] * s5 + n4[13], g3 = n4[2] * t6 + n4[6] * s5 + n4[14], y3 = n4[3] * t6 + n4[7] * s5 + n4[15], x3 = m3 + a4, v3 = _3 + l4, b2 = g3 + c4, w2 = Math.max(y3 + u4, 1e-5), T2 = m3 + h3, E2 = _3 + p3, S2 = g3 + d2, A2 = Math.max(y3 + f3, 1e-5);
                  e5.push(new Point3D(x3 / w2, v3 / w2, b2 / w2)), i5.push(new Point3D(T2 / A2, E2 / A2, S2 / A2));
                }
                o4.push(e5), s4.push(i5);
              }
              return [o4, s4];
            }(t3, i3, r3, n3, o3);
          }(o2, r2, h2, u2, c2, s2, g2, p2, m2, o2.center.lat, e2.tileID.canonical), v2 = e2.queryGeometry;
          return function(e3, t3, i3) {
            let r3 = 1 / 0;
            os(i3, t3) && (r3 = Yl(i3, t3[0]));
            for (let n3 = 0; n3 < t3.length; n3++) {
              const o3 = t3[n3], s3 = e3[n3];
              for (let e4 = 0; e4 < o3.length - 1; e4++) {
                const t4 = o3[e4], n4 = [t4, o3[e4 + 1], s3[e4 + 1], s3[e4], t4];
                rs(i3, n4) && (r3 = Math.min(r3, Yl(i3, n4)));
              }
            }
            return r3 !== 1 / 0 && r3;
          }(y2, x2, v2.isPointQuery() ? v2.screenBounds : v2.screenGeometry);
        }
      }, line: class LineStyleLayer extends StyleLayer {
        constructor(e2) {
          super(e2, sc), this.gradientVersion = 0;
        }
        _handleSpecialPaintPropertyUpdate(e2) {
          if ("line-gradient" === e2) {
            const e3 = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = e3._styleExpression && e3._styleExpression.expression instanceof Ci, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(e2, t2) {
          super.recalculate(e2, t2), this.paint._values["line-floorwidth"] = ac.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e2);
        }
        createBucket(e2) {
          return new LineBucket(e2);
        }
        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }
        getProgramConfiguration(e2) {
          return new ProgramConfiguration(this, e2);
        }
        queryRadius(e2) {
          const t2 = e2, i2 = lc(ms("line-width", this, t2), ms("line-gap-width", this, t2)), r2 = ms("line-offset", this, t2);
          return i2 / 2 + Math.abs(r2) + _s(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(e2, t2, i2, r2, n2, o2) {
          if (e2.queryGeometry.isAboveHorizon)
            return false;
          const s2 = gs(e2.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o2.angle, e2.pixelToTileUnitsFactor), a2 = e2.pixelToTileUnitsFactor / 2 * lc(this.paint.get("line-width").evaluate(t2, i2), this.paint.get("line-gap-width").evaluate(t2, i2)), l2 = this.paint.get("line-offset").evaluate(t2, i2);
          return l2 && (r2 = function(e3, t3) {
            const i3 = [], r3 = new d(0, 0);
            for (let n3 = 0; n3 < e3.length; n3++) {
              const o3 = e3[n3], s3 = [];
              for (let e4 = 0; e4 < o3.length; e4++) {
                const i4 = o3[e4 - 1], n4 = o3[e4], a3 = o3[e4 + 1], l3 = 0 === e4 ? r3 : n4.sub(i4)._unit()._perp(), c2 = e4 === o3.length - 1 ? r3 : a3.sub(n4)._unit()._perp(), u2 = l3._add(c2)._unit();
                u2._mult(1 / (u2.x * c2.x + u2.y * c2.y)), s3.push(u2._mult(t3)._add(n4));
              }
              i3.push(s3);
            }
            return i3;
          }(r2, l2 * e2.pixelToTileUnitsFactor)), function(e3, t3, i3) {
            for (let r3 = 0; r3 < t3.length; r3++) {
              const n3 = t3[r3];
              if (e3.length >= 3) {
                for (let t4 = 0; t4 < n3.length; t4++)
                  if (ps(e3, n3[t4]))
                    return true;
              }
              if (ss(e3, n3, i3))
                return true;
            }
            return false;
          }(s2, r2, a2);
        }
        isTileClipped() {
          return true;
        }
      }, symbol: SymbolStyleLayer, background: class BackgroundStyleLayer extends StyleLayer {
        constructor(e2) {
          super(e2, fh);
        }
        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }
      }, raster: class RasterStyleLayer extends StyleLayer {
        constructor(e2) {
          super(e2, mh);
        }
        getProgramIds() {
          return ["raster"];
        }
      }, sky: class SkyLayer extends StyleLayer {
        constructor(e2) {
          super(e2, _h), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(e2) {
          "sky-gradient" === e2 ? this._updateColorRamp() : "sky-atmosphere-sun" !== e2 && "sky-atmosphere-halo-color" !== e2 && "sky-atmosphere-color" !== e2 && "sky-atmosphere-sun-intensity" !== e2 || (this._skyboxInvalidated = true);
        }
        _updateColorRamp() {
          this.colorRamp = Ma({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }
        needsSkyboxCapture(e2) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
            return true;
          if (!this.paint.get("sky-atmosphere-sun")) {
            const t2 = e2.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== t2.azimuthal || this._lightPosition.polar !== t2.polar;
          }
          return false;
        }
        getCenter(e2, t2) {
          if ("atmosphere" === this.paint.get("sky-type")) {
            const i3 = this.paint.get("sky-atmosphere-sun"), r2 = !i3, n2 = e2.style.light, o2 = n2.properties.get("position");
            return r2 && "viewport" === n2.properties.get("anchor") && Z("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), r2 ? gh(o2.azimuthal, 90 - o2.polar, t2) : gh(i3[0], 90 - i3[1], t2);
          }
          const i2 = this.paint.get("sky-gradient-center");
          return gh(i2[0], 90 - i2[1], t2);
        }
        is3D() {
          return false;
        }
        isSky() {
          return true;
        }
        markSkyboxValid(e2) {
          this._skyboxInvalidated = false, this._lightPosition = e2.style.light.properties.get("position");
        }
        hasOffscreenPass() {
          return true;
        }
        getProgramIds() {
          const e2 = this.paint.get("sky-type");
          return "atmosphere" === e2 ? ["skyboxCapture", "skybox"] : "gradient" === e2 ? ["skyboxGradient"] : null;
        }
      } };
      function xh(e2) {
        return "custom" === e2.type ? new CustomStyleLayer(e2) : new yh[e2.type](e2);
      }
      class Texture {
        constructor(e2, t2, i2, r2) {
          this.context = e2, this.format = i2, this.texture = e2.gl.createTexture(), this.update(t2, r2);
        }
        update(t2, i2, r2) {
          const { width: n2, height: o2 } = t2, { context: s2 } = this, { gl: a2 } = s2, { HTMLImageElement: l2, HTMLCanvasElement: c2, HTMLVideoElement: u2, ImageData: h2, ImageBitmap: p2 } = e;
          if (a2.bindTexture(a2.TEXTURE_2D, this.texture), s2.pixelStoreUnpackFlipY.set(false), s2.pixelStoreUnpack.set(1), s2.pixelStoreUnpackPremultiplyAlpha.set(this.format === a2.RGBA && (!i2 || false !== i2.premultiply)), r2 || this.size && this.size[0] === n2 && this.size[1] === o2) {
            const { x: e2, y: i3 } = r2 || { x: 0, y: 0 };
            t2 instanceof l2 || t2 instanceof c2 || t2 instanceof u2 || t2 instanceof h2 || p2 && t2 instanceof p2 ? a2.texSubImage2D(a2.TEXTURE_2D, 0, e2, i3, a2.RGBA, a2.UNSIGNED_BYTE, t2) : a2.texSubImage2D(a2.TEXTURE_2D, 0, e2, i3, n2, o2, a2.RGBA, a2.UNSIGNED_BYTE, t2.data);
          } else
            this.size = [n2, o2], t2 instanceof l2 || t2 instanceof c2 || t2 instanceof u2 || t2 instanceof h2 || p2 && t2 instanceof p2 ? a2.texImage2D(a2.TEXTURE_2D, 0, this.format, this.format, a2.UNSIGNED_BYTE, t2) : a2.texImage2D(a2.TEXTURE_2D, 0, this.format, n2, o2, 0, this.format, a2.UNSIGNED_BYTE, t2.data);
          this.useMipmap = Boolean(i2 && i2.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && a2.generateMipmap(a2.TEXTURE_2D);
        }
        bind(e2, t2) {
          const { context: i2 } = this, { gl: r2 } = i2;
          r2.bindTexture(r2.TEXTURE_2D, this.texture), e2 !== this.filter && (r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, e2), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, this.useMipmap ? e2 === r2.NEAREST ? r2.NEAREST_MIPMAP_NEAREST : r2.LINEAR_MIPMAP_NEAREST : e2), this.filter = e2), t2 !== this.wrap && (r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, t2), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, t2), this.wrap = t2);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: e2 } = this.context;
          e2.deleteTexture(this.texture), this.texture = null;
        }
      }
      function vh(e2) {
        const { userImage: t2 } = e2;
        return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
      }
      class ImageManager extends Evented {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new RGBAImage({ width: 1, height: 1 }), this.dirty = true;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(e2) {
          if (this.loaded !== e2 && (this.loaded = e2, e2)) {
            for (const { ids: e3, callback: t2 } of this.requestors)
              this._notify(e3, t2);
            this.requestors = [];
          }
        }
        hasImage(e2) {
          return !!this.getImage(e2);
        }
        getImage(e2) {
          return this.images[e2];
        }
        addImage(e2, t2) {
          this._validate(e2, t2) && (this.images[e2] = t2);
        }
        _validate(e2, t2) {
          let i2 = true;
          return this._validateStretch(t2.stretchX, t2.data && t2.data.width) || (this.fire(new ErrorEvent(new Error(`Image "${e2}" has invalid "stretchX" value`))), i2 = false), this._validateStretch(t2.stretchY, t2.data && t2.data.height) || (this.fire(new ErrorEvent(new Error(`Image "${e2}" has invalid "stretchY" value`))), i2 = false), this._validateContent(t2.content, t2) || (this.fire(new ErrorEvent(new Error(`Image "${e2}" has invalid "content" value`))), i2 = false), i2;
        }
        _validateStretch(e2, t2) {
          if (!e2)
            return true;
          let i2 = 0;
          for (const r2 of e2) {
            if (r2[0] < i2 || r2[1] < r2[0] || t2 < r2[1])
              return false;
            i2 = r2[1];
          }
          return true;
        }
        _validateContent(e2, t2) {
          return !(e2 && (4 !== e2.length || e2[0] < 0 || t2.data.width < e2[0] || e2[1] < 0 || t2.data.height < e2[1] || e2[2] < 0 || t2.data.width < e2[2] || e2[3] < 0 || t2.data.height < e2[3] || e2[2] < e2[0] || e2[3] < e2[1]));
        }
        updateImage(e2, t2) {
          t2.version = this.images[e2].version + 1, this.images[e2] = t2, this.updatedImages[e2] = true;
        }
        removeImage(e2) {
          const t2 = this.images[e2];
          delete this.images[e2], delete this.patterns[e2], t2.userImage && t2.userImage.onRemove && t2.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(e2, t2) {
          let i2 = true;
          if (!this.isLoaded())
            for (const t3 of e2)
              this.images[t3] || (i2 = false);
          this.isLoaded() || i2 ? this._notify(e2, t2) : this.requestors.push({ ids: e2, callback: t2 });
        }
        _notify(e2, t2) {
          const i2 = {};
          for (const t3 of e2) {
            this.images[t3] || this.fire(new Event("styleimagemissing", { id: t3 }));
            const e3 = this.images[t3];
            e3 ? i2[t3] = { data: e3.data.clone(), pixelRatio: e3.pixelRatio, sdf: e3.sdf, version: e3.version, stretchX: e3.stretchX, stretchY: e3.stretchY, content: e3.content, hasRenderCallback: Boolean(e3.userImage && e3.userImage.render) } : Z(`Image "${t3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          t2(null, i2);
        }
        getPixelSize() {
          const { width: e2, height: t2 } = this.atlasImage;
          return { width: e2, height: t2 };
        }
        getPattern(e2) {
          const t2 = this.patterns[e2], i2 = this.getImage(e2);
          if (!i2)
            return null;
          if (t2 && t2.position.version === i2.version)
            return t2.position;
          if (t2)
            t2.position.version = i2.version;
          else {
            const t3 = { w: i2.data.width + 2, h: i2.data.height + 2, x: 0, y: 0 }, r2 = new ImagePosition(t3, i2);
            this.patterns[e2] = { bin: t3, position: r2 };
          }
          return this._updatePatternAtlas(), this.patterns[e2].position;
        }
        bind(e2) {
          const t2 = e2.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new Texture(e2, this.atlasImage, t2.RGBA), this.atlasTexture.bind(t2.LINEAR, t2.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const e2 = [];
          for (const t3 in this.patterns)
            e2.push(this.patterns[t3].bin);
          const { w: t2, h: i2 } = Hc(e2), r2 = this.atlasImage;
          r2.resize({ width: t2 || 1, height: i2 || 1 });
          for (const e3 in this.patterns) {
            const { bin: t3 } = this.patterns[e3], i3 = t3.x + 1, n2 = t3.y + 1, o2 = this.images[e3].data, s2 = o2.width, a2 = o2.height;
            RGBAImage.copy(o2, r2, { x: 0, y: 0 }, { x: i3, y: n2 }, { width: s2, height: a2 }), RGBAImage.copy(o2, r2, { x: 0, y: a2 - 1 }, { x: i3, y: n2 - 1 }, { width: s2, height: 1 }), RGBAImage.copy(o2, r2, { x: 0, y: 0 }, { x: i3, y: n2 + a2 }, { width: s2, height: 1 }), RGBAImage.copy(o2, r2, { x: s2 - 1, y: 0 }, { x: i3 - 1, y: n2 }, { width: 1, height: a2 }), RGBAImage.copy(o2, r2, { x: 0, y: 0 }, { x: i3 + s2, y: n2 }, { width: 1, height: a2 });
          }
          this.dirty = true;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(e2) {
          for (const t2 of e2) {
            if (this.callbackDispatchedThisFrame[t2])
              continue;
            this.callbackDispatchedThisFrame[t2] = true;
            const e3 = this.images[t2];
            vh(e3) && this.updateImage(t2, e3);
          }
        }
      }
      const bh = new Properties({ anchor: new DataConstantProperty(ft.light.anchor), position: new class LightPositionProperty {
        constructor() {
          this.specification = ft.light.position;
        }
        possiblyEvaluate(e2, t2) {
          return function([e3, t3, i2]) {
            const r2 = y(t3 + 90), n2 = y(i2);
            return { x: e3 * Math.cos(r2) * Math.sin(n2), y: e3 * Math.sin(r2) * Math.sin(n2), z: e3 * Math.cos(n2), azimuthal: t3, polar: i2 };
          }(e2.expression.evaluate(t2));
        }
        interpolate(e2, t2, i2) {
          return { x: Ii(e2.x, t2.x, i2), y: Ii(e2.y, t2.y, i2), z: Ii(e2.z, t2.z, i2), azimuthal: Ii(e2.azimuthal, t2.azimuthal, i2), polar: Ii(e2.polar, t2.polar, i2) };
        }
      }(), color: new DataConstantProperty(ft.light.color), intensity: new DataConstantProperty(ft.light.intensity) }), wh = "-transition";
      class Light extends Evented {
        constructor(e2) {
          super(), this._transitionable = new Transitionable(bh), this.setLight(e2), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(e2, t2 = {}) {
          if (!this._validate(bn, e2, t2))
            for (const t3 in e2) {
              const i2 = e2[t3];
              U(t3, wh) ? this._transitionable.setTransition(t3.slice(0, -wh.length), i2) : this._transitionable.setValue(t3, i2);
            }
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
        _validate(e2, t2, i2) {
          return (!i2 || false !== i2.validate) && Dn(this, e2.call(xn, P({ value: t2, style: { glyphs: true, sprite: true }, styleSpec: ft })));
        }
      }
      const Th = new Properties({ source: new DataConstantProperty(ft.terrain.source), exaggeration: new DataConstantProperty(ft.terrain.exaggeration) }), Eh = "-transition";
      class Terrain$1 extends Evented {
        constructor(e2, t2) {
          super(), this._transitionable = new Transitionable(Th), this.set(e2), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = t2;
        }
        get() {
          return this._transitionable.serialize();
        }
        set(e2) {
          for (const t2 in e2) {
            const i2 = e2[t2];
            U(t2, Eh) ? this._transitionable.setTransition(t2.slice(0, -Eh.length), i2) : this._transitionable.setValue(t2, i2);
          }
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
      }
      function Sh(e2, t2, i2, r2) {
        const n2 = C(45, 65, i2), [o2, s2] = Ah(e2, r2), a2 = qs(t2);
        let l2 = 1 - Math.min(1, Math.exp((a2 - o2) / (s2 - o2) * -6));
        return l2 *= l2 * l2, l2 = Math.min(1, 1.00747 * l2), l2 * n2 * e2.alpha;
      }
      function Ah(e2, t2) {
        const i2 = 0.5 / Math.tan(0.5 * t2);
        return [e2.range[0] + i2, e2.range[1] + i2];
      }
      const Ch = new Properties({ range: new DataConstantProperty(ft.fog.range), color: new DataConstantProperty(ft.fog.color), "high-color": new DataConstantProperty(ft.fog["high-color"]), "space-color": new DataConstantProperty(ft.fog["space-color"]), "horizon-blend": new DataConstantProperty(ft.fog["horizon-blend"]), "star-intensity": new DataConstantProperty(ft.fog["star-intensity"]) }), Ih = "-transition";
      class Fog extends Evented {
        constructor(e2, t2) {
          super(), this._transitionable = new Transitionable(Ch), this.set(e2), this._transitioning = this._transitionable.untransitioned(), this._transform = t2;
        }
        get state() {
          const e2 = this._transform, t2 = "globe" === e2.projection.name, i2 = zu(e2.zoom), r2 = this.properties.get("range"), n2 = [0.5, 3];
          return { range: t2 ? [Ii(n2[0], r2[0], i2), Ii(n2[1], r2[1], i2)] : r2, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(e2, t2 = {}) {
          if (!this._validate(Tn, e2, t2)) {
            for (const t3 of Object.keys(ft.fog))
              e2 && void 0 === e2[t3] && (e2[t3] = ft.fog[t3].default);
            for (const t3 in e2) {
              const i2 = e2[t3];
              U(t3, Ih) ? this._transitionable.setTransition(t3.slice(0, -Ih.length), i2) : this._transitionable.setValue(t3, i2);
            }
          }
        }
        getOpacity(e2) {
          if (!this._transform.projection.supportsFog)
            return 0;
          const t2 = this.properties && this.properties.get("color") || 1;
          return ("globe" === this._transform.projection.name ? 1 : C(45, 65, e2)) * t2.a;
        }
        getOpacityAtLatLng(e2, t2) {
          return this._transform.projection.supportsFog ? function(e3, t3, i2) {
            const r2 = MercatorCoordinate.fromLngLat(t3), n2 = i2.elevation ? i2.elevation.getAtPointOrZero(r2) : 0, o2 = [r2.x, r2.y, n2];
            return ra(o2, o2, i2.mercatorFogMatrix), Sh(e3, o2, i2.pitch, i2._fov);
          }(this.state, e2, t2) : 0;
        }
        getFovAdjustedRange(e2) {
          return this._transform.projection.supportsFog ? Ah(this.state, e2) : [0, 1];
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
        _validate(e2, t2, i2) {
          return (!i2 || false !== i2.validate) && Dn(this, e2.call(xn, P({ value: t2, style: { glyphs: true, sprite: true }, styleSpec: ft })));
        }
      }
      class ThrottledInvoker {
        constructor(e2) {
          this._callback = e2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = false, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
            this._triggered = false, this._callback();
          }, 0));
        }
        remove() {
          this._channel = void 0, this._callback = () => {
          };
        }
      }
      class Scheduler {
        constructor() {
          this.tasks = {}, this.taskQueue = [], O(["process"], this), this.invoker = new ThrottledInvoker(this.process), this.nextId = 0;
        }
        add(e2, t2) {
          const i2 = this.nextId++, r2 = function({ type: e3, isSymbolTile: t3, zoom: i3 }) {
            return i3 = i3 || 0, "message" === e3 ? 0 : "maybePrepare" !== e3 || t3 ? "parseTile" !== e3 || t3 ? "parseTile" === e3 && t3 ? 300 - i3 : "maybePrepare" === e3 && t3 ? 400 - i3 : 500 : 200 - i3 : 100 - i3;
          }(t2);
          if (0 === r2) {
            H();
            try {
              e2();
            } finally {
            }
            return { cancel: () => {
            } };
          }
          return this.tasks[i2] = { fn: e2, metadata: t2, priority: r2, id: i2 }, this.taskQueue.push(i2), this.invoker.trigger(), { cancel: () => {
            delete this.tasks[i2];
          } };
        }
        process() {
          H();
          try {
            if (this.taskQueue = this.taskQueue.filter((e3) => !!this.tasks[e3]), !this.taskQueue.length)
              return;
            const e2 = this.pick();
            if (null === e2)
              return;
            const t2 = this.tasks[e2];
            if (delete this.tasks[e2], this.taskQueue.length && this.invoker.trigger(), !t2)
              return;
            t2.fn();
          } finally {
          }
        }
        pick() {
          let e2 = null, t2 = 1 / 0;
          for (let i3 = 0; i3 < this.taskQueue.length; i3++) {
            const r2 = this.tasks[this.taskQueue[i3]];
            r2.priority < t2 && (t2 = r2.priority, e2 = i3);
          }
          if (null === e2)
            return null;
          const i2 = this.taskQueue[e2];
          return this.taskQueue.splice(e2, 1), i2;
        }
        remove() {
          this.invoker.remove();
        }
      }
      class Dispatcher {
        constructor(e2, t2) {
          this.workerPool = e2, this.actors = [], this.currentActor = 0, this.id = k();
          const i2 = this.workerPool.acquire(this.id);
          for (let e3 = 0; e3 < i2.length; e3++) {
            const r2 = new Dispatcher.Actor(i2[e3], t2, this.id);
            r2.name = `Worker ${e3}`, this.actors.push(r2);
          }
          this.ready = false, this.broadcast("checkIfReady", null, () => {
            this.ready = true;
          });
        }
        broadcast(e2, t2, i2) {
          M(this.actors, (i3, r2) => {
            i3.send(e2, t2, r2);
          }, i2 = i2 || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((e2) => {
            e2.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }
      }
      function Mh(e2, t2, i2) {
        return t2 * (ko / (e2.tileSize * Math.pow(2, i2 - e2.tileID.overscaledZ)));
      }
      Dispatcher.Actor = class Actor {
        constructor(t2, i2, r2) {
          this.target = t2, this.parent = i2, this.mapId = r2, this.callbacks = {}, this.cancelCallbacks = {}, O(["receive"], this), this.target.addEventListener("message", this.receive, false), this.globalScope = H() ? t2 : e, this.scheduler = new Scheduler();
        }
        send(e2, t2, i2, r2, n2 = false, o2) {
          const s2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          i2 && (i2.metadata = o2, this.callbacks[s2] = i2);
          const a2 = Y(this.globalScope) ? void 0 : [];
          return this.target.postMessage({ id: s2, type: e2, hasCallback: !!i2, targetMapId: r2, mustQueue: n2, sourceMapId: this.mapId, data: Fn(t2, a2) }, a2), { cancel: () => {
            i2 && delete this.callbacks[s2], this.target.postMessage({ id: s2, type: "<cancel>", targetMapId: r2, sourceMapId: this.mapId });
          } };
        }
        receive(e2) {
          const t2 = e2.data, i2 = t2.id;
          if (i2 && (!t2.targetMapId || this.mapId === t2.targetMapId))
            if ("<cancel>" === t2.type) {
              const e3 = this.cancelCallbacks[i2];
              delete this.cancelCallbacks[i2], e3 && e3.cancel();
            } else if (t2.mustQueue || H()) {
              const e3 = this.callbacks[i2];
              this.cancelCallbacks[i2] = this.scheduler.add(() => this.processTask(i2, t2), e3 && e3.metadata || { type: "message" });
            } else
              this.processTask(i2, t2);
        }
        processTask(e2, t2) {
          if ("<response>" === t2.type) {
            const i2 = this.callbacks[e2];
            delete this.callbacks[e2], i2 && (t2.error ? i2(On(t2.error)) : i2(null, On(t2.data)));
          } else {
            const i2 = Y(this.globalScope) ? void 0 : [], r2 = t2.hasCallback ? (t3, r3) => {
              delete this.cancelCallbacks[e2], this.target.postMessage({ id: e2, type: "<response>", sourceMapId: this.mapId, error: t3 ? Fn(t3) : null, data: Fn(r3, i2) }, i2);
            } : (e3) => {
            }, n2 = On(t2.data);
            if (this.parent[t2.type])
              this.parent[t2.type](t2.sourceMapId, n2, r2);
            else if (this.parent.getWorkerSource) {
              const e3 = t2.type.split(".");
              this.parent.getWorkerSource(t2.sourceMapId, e3[0], n2.source)[e3[1]](n2, r2);
            } else
              r2(new Error(`Could not find function ${t2.type}`));
          }
        }
        remove() {
          this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
        }
      };
      class QueryGeometry {
        constructor(e2, t2, i2, r2) {
          this.screenBounds = e2, this.cameraPoint = t2, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, r2);
        }
        static createFromScreenPoints(e2, t2) {
          let i2, r2;
          if (e2 instanceof d || "number" == typeof e2[0]) {
            const n2 = d.convert(e2);
            i2 = [n2], r2 = t2.isPointAboveHorizon(n2);
          } else {
            const n2 = d.convert(e2[0]), o2 = d.convert(e2[1]);
            i2 = [n2, o2], r2 = T(n2, o2).every((e3) => t2.isPointAboveHorizon(e3));
          }
          return new QueryGeometry(i2, t2.getCameraPoint(), r2, t2);
        }
        isPointQuery() {
          return 1 === this.screenBounds.length;
        }
        bufferedScreenGeometry(e2) {
          return T(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], e2);
        }
        bufferedCameraGeometry(e2) {
          const t2 = this.screenBounds[0], i2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new d(1, 1)) : this.screenBounds[1], r2 = T(t2, i2, 0, false);
          return this.cameraPoint.y > i2.y && (this.cameraPoint.x > t2.x && this.cameraPoint.x < i2.x ? r2.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= i2.x ? r2[2] = this.cameraPoint : this.cameraPoint.x <= t2.x && (r2[3] = this.cameraPoint)), function(e3, t3) {
            const i3 = [];
            for (let r3 = 0; r3 < e3.length; r3++) {
              const n2 = I(r3 - 1, -1, e3.length - 1), o2 = I(r3 + 1, -1, e3.length - 1), s2 = e3[r3], a2 = e3[o2], l2 = e3[n2].sub(s2).unit(), c2 = a2.sub(s2).unit(), u2 = c2.angleWithSep(l2.x, l2.y), h2 = l2.add(c2).unit().mult(-1 * t3 / Math.sin(u2 / 2));
              i3.push(s2.add(h2));
            }
            return i3;
          }(r2, e2);
        }
        bufferedCameraGeometryGlobe(e2) {
          const t2 = this.screenBounds[0], i2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new d(1, 1)) : this.screenBounds[1], r2 = T(t2, i2, e2), n2 = this.cameraPoint.clone();
          switch (3 * ((n2.y > t2.y) + (n2.y > i2.y)) + ((n2.x > t2.x) + (n2.x > i2.x))) {
            case 0:
              r2[0] = n2, r2[4] = n2.clone();
              break;
            case 1:
              r2.splice(1, 0, n2);
              break;
            case 2:
              r2[1] = n2;
              break;
            case 3:
              r2.splice(4, 0, n2);
              break;
            case 5:
              r2.splice(2, 0, n2);
              break;
            case 6:
              r2[3] = n2;
              break;
            case 7:
              r2.splice(3, 0, n2);
              break;
            case 8:
              r2[2] = n2;
          }
          return r2;
        }
        containsTile(e2, t2, i2, r2 = 0) {
          const n2 = e2.queryPadding / t2._pixelsPerMercatorPixel + 1, o2 = i2 ? this._bufferedCameraMercator(n2, t2) : this._bufferedScreenMercator(n2, t2);
          let s2 = e2.tileID.wrap + (o2.unwrapped ? r2 : 0);
          const a2 = o2.polygon.map((t3) => $u(e2.tileTransform, t3, s2));
          if (!ds(a2, 0, 0, ko, ko))
            return;
          s2 = e2.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r2 : 0);
          const l2 = this.screenGeometryMercator.polygon.map((t3) => Wu(e2.tileTransform, t3, s2)), c2 = l2.map((e3) => new d(e3[0], e3[1])), u2 = t2.getFreeCameraOptions().position || new MercatorCoordinate(0, 0, 0), h2 = Wu(e2.tileTransform, u2, s2), p2 = l2.map((e3) => {
            const t3 = aa(e3, e3, h2);
            return ea(t3, t3), new Ray(h2, t3);
          }), f2 = Mh(e2, 1, t2.zoom) * t2._pixelsPerMercatorPixel;
          return { queryGeometry: this, tilespaceGeometry: c2, tilespaceRays: p2, bufferedTilespaceGeometry: a2, bufferedTilespaceBounds: (m2 = w(a2), m2.min.x = A(m2.min.x, 0, ko), m2.min.y = A(m2.min.y, 0, ko), m2.max.x = A(m2.max.x, 0, ko), m2.max.y = A(m2.max.y, 0, ko), m2), tile: e2, tileID: e2.tileID, pixelToTileUnitsFactor: f2 };
          var m2;
        }
        _bufferedScreenMercator(e2, t2) {
          const i2 = zh(e2);
          if (this._screenRaycastCache[i2])
            return this._screenRaycastCache[i2];
          {
            let r2;
            return r2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e2), t2) : { polygon: this.bufferedScreenGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._screenRaycastCache[i2] = r2, r2;
          }
        }
        _bufferedCameraMercator(e2, t2) {
          const i2 = zh(e2);
          if (this._cameraRaycastCache[i2])
            return this._cameraRaycastCache[i2];
          {
            let r2;
            return r2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e2), t2) : { polygon: this.bufferedCameraGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._cameraRaycastCache[i2] = r2, r2;
          }
        }
        _projectAndResample(e2, t2) {
          const i2 = function(e3, t3) {
            const i3 = Ds([], t3.pixelMatrix, t3.globeMatrix), r3 = [0, -au, 0, 1], n2 = [0, au, 0, 1], o2 = [0, 0, 0, 1];
            da(r3, r3, i3), da(n2, n2, i3), da(o2, o2, i3);
            const s2 = new d(r3[0] / r3[3], r3[1] / r3[3]), a2 = new d(n2[0] / n2[3], n2[1] / n2[3]), l2 = ps(e3, s2) && r3[3] < o2[3], c2 = ps(e3, a2) && n2[3] < o2[3];
            if (!l2 && !c2)
              return null;
            const u2 = function(e4, t4, i4) {
              for (let r4 = 1; r4 < e4.length; r4++) {
                const n3 = Ph(t4.pointCoordinate3D(e4[r4 - 1]).x), o3 = Ph(t4.pointCoordinate3D(e4[r4]).x);
                if (i4 < 0) {
                  if (n3 < o3)
                    return { idx: r4, t: -n3 / (o3 - 1 - n3) };
                } else if (o3 < n3)
                  return { idx: r4, t: (1 - n3) / (o3 + 1 - n3) };
              }
              return null;
            }(e3, t3, l2 ? -1 : 1);
            if (!u2)
              return null;
            const { idx: h2, t: p2 } = u2;
            let f2 = h2 > 1 ? Dh(e3.slice(0, h2), t3) : [], m2 = h2 < e3.length ? Dh(e3.slice(h2), t3) : [];
            f2 = f2.map((e4) => new d(Ph(e4.x), e4.y)), m2 = m2.map((e4) => new d(Ph(e4.x), e4.y));
            const _2 = [...f2];
            0 === _2.length && _2.push(m2[m2.length - 1]);
            const g2 = Ii(_2[_2.length - 1].y, (0 === m2.length ? f2[0] : m2[0]).y, p2);
            let y2;
            return y2 = l2 ? [new d(0, g2), new d(0, 0), new d(1, 0), new d(1, g2)] : [new d(1, g2), new d(1, 1), new d(0, 1), new d(0, g2)], _2.push(...y2), 0 === m2.length ? _2.push(f2[0]) : _2.push(...m2), { polygon: _2.map((e4) => new MercatorCoordinate(e4.x, e4.y)), unwrapped: false };
          }(e2, t2);
          if (i2)
            return i2;
          const r2 = function(e3, t3) {
            let i3 = false, r3 = -1 / 0, n2 = 0;
            for (let t4 = 0; t4 < e3.length - 1; t4++)
              e3[t4].x > r3 && (r3 = e3[t4].x, n2 = t4);
            for (let t4 = 0; t4 < e3.length - 1; t4++) {
              const r4 = (n2 + t4) % (e3.length - 1), o3 = e3[r4], s2 = e3[r4 + 1];
              Math.abs(o3.x - s2.x) > 0.5 && (o3.x < s2.x ? (o3.x += 1, 0 === r4 && (e3[e3.length - 1].x += 1)) : (s2.x += 1, r4 + 1 === e3.length - 1 && (e3[0].x += 1)), i3 = true);
            }
            const o2 = Oo(t3.center.lng);
            return i3 && o2 < Math.abs(o2 - 1) && e3.forEach((e4) => {
              e4.x -= 1;
            }), { polygon: e3, unwrapped: i3 };
          }(Dh(e2, t2).map((e3) => new d(Ph(e3.x), e3.y)), t2);
          return { polygon: r2.polygon.map((e3) => new MercatorCoordinate(e3.x, e3.y)), unwrapped: r2.unwrapped };
        }
      }
      function Dh(e2, t2) {
        return Wo(e2, (e3) => {
          const i2 = t2.pointCoordinate3D(e3);
          e3.x = i2.x, e3.y = i2.y;
        }, 1 / 256);
      }
      function Ph(e2) {
        return e2 < 0 ? 1 + e2 % 1 : e2 % 1;
      }
      function zh(e2) {
        return 100 * e2 | 0;
      }
      function Lh(e2, t2, i2, r2, n2) {
        const o2 = function(i3, r3) {
          if (i3)
            return n2(i3);
          if (r3) {
            e2.url && r3.tiles && e2.tiles && delete e2.tiles;
            const i4 = z(P(r3, e2), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            r3.vector_layers && (i4.vectorLayers = r3.vector_layers, i4.vectorLayerIds = i4.vectorLayers.map((e3) => e3.id)), i4.tiles = t2.canonicalizeTileset(i4, e2.url), n2(null, i4);
          }
        };
        return e2.url ? me(t2.transformRequest(t2.normalizeSourceURL(e2.url, null, i2, r2), pe.Source), o2) : Je.frame(() => o2(null, e2));
      }
      class TileBounds {
        constructor(e2, t2, i2) {
          this.bounds = LngLatBounds.convert(this.validateBounds(e2)), this.minzoom = t2 || 0, this.maxzoom = i2 || 24;
        }
        validateBounds(e2) {
          return Array.isArray(e2) && 4 === e2.length ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
        }
        contains(e2) {
          const t2 = Math.pow(2, e2.z), i2 = Math.floor(Oo(this.bounds.getWest()) * t2), r2 = Math.floor(Uo(this.bounds.getNorth()) * t2), n2 = Math.ceil(Oo(this.bounds.getEast()) * t2), o2 = Math.ceil(Uo(this.bounds.getSouth()) * t2);
          return e2.x >= i2 && e2.x < n2 && e2.y >= r2 && e2.y < o2;
        }
      }
      class DictionaryCoder {
        constructor(e2) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let t2 = 0; t2 < e2.length; t2++) {
            const i2 = e2[t2];
            this._stringToNumber[i2] = t2, this._numberToString[t2] = i2;
          }
        }
        encode(e2) {
          return this._stringToNumber[e2];
        }
        decode(e2) {
          return this._numberToString[e2];
        }
      }
      const kh = ["tile", "layer", "source", "sourceLayer", "state"];
      class Feature {
        constructor(e2, t2, i2, r2, n2) {
          this.type = "Feature", this._vectorTileFeature = e2, this._z = t2, this._x = i2, this._y = r2, this.properties = e2.properties, this.id = n2;
        }
        get geometry() {
          return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
        }
        set geometry(e2) {
          this._geometry = e2;
        }
        toJSON() {
          const e2 = { type: "Feature", geometry: this.geometry, properties: this.properties };
          void 0 !== this.id && (e2.id = this.id);
          for (const t2 of kh)
            void 0 !== this[t2] && (e2[t2] = this[t2]);
          return e2;
        }
      }
      const Bh = 32, Rh = 33, Fh = new Uint16Array(8184);
      for (let e2 = 0; e2 < 2046; e2++) {
        let t2 = e2 + 2, i2 = 0, r2 = 0, n2 = 0, o2 = 0, s2 = 0, a2 = 0;
        for (1 & t2 ? n2 = o2 = s2 = Bh : i2 = r2 = a2 = Bh; (t2 >>= 1) > 1; ) {
          const e3 = i2 + n2 >> 1, l3 = r2 + o2 >> 1;
          1 & t2 ? (n2 = i2, o2 = r2, i2 = s2, r2 = a2) : (i2 = n2, r2 = o2, n2 = s2, o2 = a2), s2 = e3, a2 = l3;
        }
        const l2 = 4 * e2;
        Fh[l2 + 0] = i2, Fh[l2 + 1] = r2, Fh[l2 + 2] = n2, Fh[l2 + 3] = o2;
      }
      const Oh = new Uint16Array(2178), Uh = new Uint8Array(1089), Vh = new Uint16Array(1089);
      function jh(e2) {
        return 0 === e2 ? -0.03125 : 32 === e2 ? 0.03125 : 0;
      }
      var Nh = co([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      const Gh = { type: 2, extent: ko, loadGeometry: () => [[new d(0, 0), new d(8193, 0), new d(8193, 8193), new d(0, 8193), new d(0, 0)]] };
      class Tile {
        constructor(e2, t2, i2, r2, n2) {
          this.tileID = e2, this.uid = k(), this.uses = 0, this.tileSize = t2, this.tileZoom = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = n2, this.expiredRequestCount = 0, this.state = "loading", r2 && r2.transform && (this.projection = r2.transform.projection);
        }
        registerFadeDuration(e2) {
          const t2 = e2 + this.timeAdded;
          t2 < Je.now() || this.fadeEndTime && t2 < this.fadeEndTime || (this.fadeEndTime = t2);
        }
        wasRequested() {
          return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
        }
        get tileTransform() {
          return this._tileTransform || (this._tileTransform = qu(this.tileID.canonical, this.projection)), this._tileTransform;
        }
        loadVectorData(e2, t2, i2) {
          if (this.unloadVectorData(), this.state = "loaded", e2) {
            e2.featureIndex && (this.latestFeatureIndex = e2.featureIndex, e2.rawTileData ? (this.latestRawTileData = e2.rawTileData, this.latestFeatureIndex.rawTileData = e2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e2.collisionBoxArray, this.buckets = function(e3, t3) {
              const i3 = {};
              if (!t3)
                return i3;
              for (const r2 of e3) {
                const e4 = r2.layerIds.map((e5) => t3.getLayer(e5)).filter(Boolean);
                if (0 !== e4.length) {
                  r2.layers = e4, r2.stateDependentLayerIds && (r2.stateDependentLayers = r2.stateDependentLayerIds.map((t4) => e4.filter((e5) => e5.id === t4)[0]));
                  for (const t4 of e4)
                    i3[t4.id] = r2;
                }
              }
              return i3;
            }(e2.buckets, t2.style), this.hasSymbolBuckets = false;
            for (const e3 in this.buckets) {
              const t3 = this.buckets[e3];
              if (t3 instanceof SymbolBucket) {
                if (this.hasSymbolBuckets = true, !i2)
                  break;
                t3.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets)
              for (const e3 in this.buckets) {
                const t3 = this.buckets[e3];
                if (t3 instanceof SymbolBucket && t3.hasRTLText) {
                  this.hasRTLText = true, so.isLoading() || so.isLoaded() || "deferred" !== no() || oo();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const e3 in this.buckets) {
              const i3 = this.buckets[e3];
              this.queryPadding = Math.max(this.queryPadding, t2.style.getLayer(e3).queryRadius(i3));
            }
            e2.imageAtlas && (this.imageAtlas = e2.imageAtlas), e2.glyphAtlasImage && (this.glyphAtlasImage = e2.glyphAtlasImage), e2.lineAtlas && (this.lineAtlas = e2.lineAtlas);
          } else
            this.collisionBoxArray = new CollisionBoxArray();
        }
        unloadVectorData() {
          if (this.hasData()) {
            for (const e2 in this.buckets)
              this.buckets[e2].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        getBucket(e2) {
          return this.buckets[e2.id];
        }
        upload(e2) {
          for (const t3 in this.buckets) {
            const i2 = this.buckets[t3];
            i2.uploadPending() && i2.upload(e2);
          }
          const t2 = e2.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Texture(e2, this.imageAtlas.image, t2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new Texture(e2, this.glyphAtlasImage, t2.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new Texture(e2, this.lineAtlas.image, t2.ALPHA), this.lineAtlas.uploaded = true);
        }
        prepare(e2) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(e2, this.imageAtlasTexture);
        }
        queryRenderedFeatures(e2, t2, i2, r2, n2, o2, s2, a2) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: r2, pixelPosMatrix: s2, transform: o2, params: n2, tileTransform: this.tileTransform }, e2, t2, i2) : {};
        }
        querySourceFeatures(e2, t2) {
          const i2 = this.latestFeatureIndex;
          if (!i2 || !i2.rawTileData)
            return;
          const r2 = i2.loadVTLayers(), n2 = t2 ? t2.sourceLayer : "", o2 = r2._geojsonTileLayer || r2[n2];
          if (!o2)
            return;
          const s2 = qr(t2 && t2.filter), { z: a2, x: l2, y: c2 } = this.tileID.canonical, u2 = { z: a2, x: l2, y: c2 };
          for (let t3 = 0; t3 < o2.length; t3++) {
            const r3 = o2.feature(t3);
            if (s2.needGeometry) {
              const e3 = es(r3, true);
              if (!s2.filter(new EvaluationParameters(this.tileID.overscaledZ), e3, this.tileID.canonical))
                continue;
            } else if (!s2.filter(new EvaluationParameters(this.tileID.overscaledZ), r3))
              continue;
            const h2 = i2.getId(r3, n2), p2 = new Feature(r3, a2, l2, c2, h2);
            p2.tile = u2, e2.push(p2);
          }
        }
        hasData() {
          return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
        }
        patternsLoaded() {
          return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(e2) {
          const t2 = this.expirationTime;
          if (e2.cacheControl) {
            const t3 = X(e2.cacheControl);
            t3["max-age"] && (this.expirationTime = Date.now() + 1e3 * t3["max-age"]);
          } else
            e2.expires && (this.expirationTime = new Date(e2.expires).getTime());
          if (this.expirationTime) {
            const e3 = Date.now();
            let i2 = false;
            if (this.expirationTime > e3)
              i2 = false;
            else if (t2)
              if (this.expirationTime < t2)
                i2 = true;
              else {
                const r2 = this.expirationTime - t2;
                r2 ? this.expirationTime = e3 + Math.max(r2, 3e4) : i2 = true;
              }
            else
              i2 = true;
            i2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(e2, t2) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e2).length || !t2)
            return;
          const i2 = this.latestFeatureIndex.loadVTLayers(), r2 = t2.style.listImages();
          for (const n2 in this.buckets) {
            if (!t2.style.hasLayer(n2))
              continue;
            const o2 = this.buckets[n2], s2 = o2.layers[0].sourceLayer || "_geojsonTileLayer", a2 = i2[s2], l2 = e2[s2];
            if (!a2 || !l2 || 0 === Object.keys(l2).length)
              continue;
            if (o2.update(l2, a2, r2, this.imageAtlas && this.imageAtlas.patternPositions || {}), o2 instanceof LineBucket || o2 instanceof FillBucket) {
              const e3 = t2.style._getSourceCache(o2.layers[0].source);
              t2._terrain && t2._terrain.enabled && e3 && o2.programConfigurations.needsUpload && t2._terrain._clearRenderCacheForTile(e3.id, this.tileID);
            }
            const c2 = t2 && t2.style && t2.style.getLayer(n2);
            c2 && (this.queryPadding = Math.max(this.queryPadding, c2.queryRadius(o2)));
          }
        }
        holdingForFade() {
          return void 0 !== this.symbolFadeHoldUntil;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Je.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(e2) {
          this.symbolFadeHoldUntil = Je.now() + e2;
        }
        setTexture(e2, t2) {
          const i2 = t2.context, r2 = i2.gl;
          this.texture = this.texture || t2.getTileTexture(e2.width), this.texture ? this.texture.update(e2, { useMipmap: true }) : (this.texture = new Texture(i2, e2, r2.RGBA, { useMipmap: true }), this.texture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE), i2.extTextureFilterAnisotropic && r2.texParameterf(r2.TEXTURE_2D, i2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, i2.extTextureFilterAnisotropicMax));
        }
        setDependencies(e2, t2) {
          const i2 = {};
          for (const e3 of t2)
            i2[e3] = true;
          this.dependencies[e2] = i2;
        }
        hasDependency(e2, t2) {
          for (const i2 of e2) {
            const e3 = this.dependencies[i2];
            if (e3) {
              for (const i3 of t2)
                if (e3[i3])
                  return true;
            }
          }
          return false;
        }
        clearQueryDebugViz() {
        }
        _makeDebugTileBoundsBuffers(e2, t2) {
          if (!t2 || "mercator" === t2.name || this._tileDebugBuffer)
            return;
          const i2 = Qo(Gh, this.tileID.canonical, this.tileTransform)[0], r2 = new StructArrayLayout2i4(), n2 = new StructArrayLayout1ui2();
          for (let e3 = 0; e3 < i2.length; e3++) {
            const { x: t3, y: o2 } = i2[e3];
            r2.emplaceBack(t3, o2), n2.emplaceBack(e3);
          }
          n2.emplaceBack(0), this._tileDebugIndexBuffer = e2.createIndexBuffer(n2), this._tileDebugBuffer = e2.createVertexBuffer(r2, su.members), this._tileDebugSegments = SegmentVector.simpleSegment(0, 0, r2.length, n2.length);
        }
        _makeTileBoundsBuffers(e2, t2) {
          if (this._tileBoundsBuffer || !t2 || "mercator" === t2.name)
            return;
          const i2 = Qo(Gh, this.tileID.canonical, this.tileTransform)[0];
          let r2, n2;
          if (this.isRaster) {
            const e3 = function(e4, t3) {
              const i3 = qu(e4, t3), r3 = Math.pow(2, e4.z);
              for (let n4 = 0; n4 < Rh; n4++)
                for (let o3 = 0; o3 < Rh; o3++) {
                  const s3 = jo((e4.x + (o3 + jh(o3)) / Bh) / r3), a3 = No((e4.y + (n4 + jh(n4)) / Bh) / r3), l3 = t3.project(s3, a3), c2 = n4 * Rh + o3;
                  Oh[2 * c2 + 0] = Math.round((l3.x * i3.scale - i3.x) * ko), Oh[2 * c2 + 1] = Math.round((l3.y * i3.scale - i3.y) * ko);
                }
              Uh.fill(0), Vh.fill(0);
              for (let e5 = 2045; e5 >= 0; e5--) {
                const t4 = 4 * e5, i4 = Fh[t4 + 0], r4 = Fh[t4 + 1], n4 = Fh[t4 + 2], o3 = Fh[t4 + 3], s3 = i4 + n4 >> 1, a3 = r4 + o3 >> 1, l3 = s3 + a3 - r4, c2 = a3 + i4 - s3, u2 = r4 * Rh + i4, h2 = o3 * Rh + n4, p2 = a3 * Rh + s3, d2 = Math.hypot((Oh[2 * u2 + 0] + Oh[2 * h2 + 0]) / 2 - Oh[2 * p2 + 0], (Oh[2 * u2 + 1] + Oh[2 * h2 + 1]) / 2 - Oh[2 * p2 + 1]) >= 16;
                if (Uh[p2] = Uh[p2] || (d2 ? 1 : 0), e5 < 1022) {
                  const e6 = (r4 + c2 >> 1) * Rh + (i4 + l3 >> 1), t5 = (o3 + c2 >> 1) * Rh + (n4 + l3 >> 1);
                  Uh[p2] = Uh[p2] || Uh[e6] || Uh[t5];
                }
              }
              const n3 = new StructArrayLayout4i8(), o2 = new StructArrayLayout3ui6();
              let s2 = 0;
              function a2(e5, t4) {
                const i4 = t4 * Rh + e5;
                return 0 === Vh[i4] && (n3.emplaceBack(Oh[2 * i4 + 0], Oh[2 * i4 + 1], e5 * ko / Bh, t4 * ko / Bh), Vh[i4] = ++s2), Vh[i4] - 1;
              }
              function l2(e5, t4, i4, r4, n4, s3) {
                const c2 = e5 + i4 >> 1, u2 = t4 + r4 >> 1;
                if (Math.abs(e5 - n4) + Math.abs(t4 - s3) > 1 && Uh[u2 * Rh + c2])
                  l2(n4, s3, e5, t4, c2, u2), l2(i4, r4, n4, s3, c2, u2);
                else {
                  const l3 = a2(e5, t4), c3 = a2(i4, r4), u3 = a2(n4, s3);
                  o2.emplaceBack(l3, c3, u3);
                }
              }
              return l2(0, 0, Bh, Bh, Bh, 0), l2(Bh, Bh, 0, 0, 0, Bh), { vertices: n3, indices: o2 };
            }(this.tileID.canonical, t2);
            r2 = e3.vertices, n2 = e3.indices;
          } else {
            r2 = new StructArrayLayout4i8(), n2 = new StructArrayLayout3ui6();
            for (const { x: e4, y: t3 } of i2)
              r2.emplaceBack(e4, t3, 0, 0);
            const e3 = La.exports(r2.int16, void 0, 4);
            for (let t3 = 0; t3 < e3.length; t3 += 3)
              n2.emplaceBack(e3[t3], e3[t3 + 1], e3[t3 + 2]);
          }
          this._tileBoundsBuffer = e2.createVertexBuffer(r2, Nh.members), this._tileBoundsIndexBuffer = e2.createIndexBuffer(n2), this._tileBoundsSegments = SegmentVector.simpleSegment(0, 0, r2.length, n2.length);
        }
        _makeGlobeTileDebugBuffers(e2, t2) {
          const i2 = t2.projection;
          if (!i2 || "globe" !== i2.name || t2.freezeTileCoverage)
            return;
          const r2 = this.tileID.canonical, n2 = Iu(yu(r2, t2)), o2 = zu(t2.zoom);
          let s2;
          o2 > 0 && (s2 = Ms(new Float64Array(16), t2.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(e2, r2, t2, n2, s2, o2), this._makeGlobeTileDebugTextBuffer(e2, r2, t2, n2, s2, o2);
        }
        _globePoint(e2, t2, i2, r2, n2, o2, s2) {
          let a2 = Su(e2, t2, i2);
          if (o2) {
            const n3 = 1 << i2.z, l2 = Oo(r2.center.lng), c2 = Uo(r2.center.lat), u2 = (i2.x + 0.5) / n3 - l2;
            let h2 = 0;
            u2 > 0.5 ? h2 = -1 : u2 < -0.5 && (h2 = 1);
            let p2 = (e2 / ko + i2.x) / n3 + h2, d2 = (t2 / ko + i2.y) / n3;
            p2 = (p2 - l2) * r2._pixelsPerMercatorPixel + l2, d2 = (d2 - c2) * r2._pixelsPerMercatorPixel + c2;
            const f2 = [p2 * r2.worldSize, d2 * r2.worldSize, 0];
            ra(f2, f2, o2), a2 = gu(a2, f2, s2);
          }
          return ra(a2, a2, n2);
        }
        _makeGlobeTileDebugBorderBuffer(e2, t2, i2, r2, n2, o2) {
          const s2 = new StructArrayLayout2i4(), a2 = new StructArrayLayout1ui2(), l2 = new StructArrayLayout3i6(), c2 = (e3, c3, u3, h2, p2) => {
            const d2 = (u3 - e3) / (p2 - 1), f2 = (h2 - c3) / (p2 - 1), m2 = s2.length;
            for (let u4 = 0; u4 < p2; u4++) {
              const h3 = e3 + u4 * d2, p3 = c3 + u4 * f2;
              s2.emplaceBack(h3, p3);
              const _2 = this._globePoint(h3, p3, t2, i2, r2, n2, o2);
              l2.emplaceBack(_2[0], _2[1], _2[2]), a2.emplaceBack(m2 + u4);
            }
          }, u2 = ko;
          c2(0, 0, u2, 0, 16), c2(u2, 0, u2, u2, 16), c2(u2, u2, 0, u2, 16), c2(0, u2, 0, 0, 16), this._tileDebugIndexBuffer = e2.createIndexBuffer(a2), this._tileDebugBuffer = e2.createVertexBuffer(s2, su.members), this._globeTileDebugBorderBuffer = e2.createVertexBuffer(l2, ou.members), this._tileDebugSegments = SegmentVector.simpleSegment(0, 0, s2.length, a2.length);
        }
        _makeGlobeTileDebugTextBuffer(e2, t2, i2, r2, n2, o2) {
          const s2 = new StructArrayLayout2i4(), a2 = new StructArrayLayout3ui6(), l2 = new StructArrayLayout3i6(), c2 = 25;
          a2.reserve(32), s2.reserve(c2), l2.reserve(c2);
          const u2 = (e3, t3) => c2 * e3 + t3;
          for (let e3 = 0; e3 < c2; e3++) {
            const a3 = 2048 * e3;
            for (let e4 = 0; e4 < c2; e4++) {
              const c3 = 2048 * e4;
              s2.emplaceBack(c3, a3);
              const u3 = this._globePoint(c3, a3, t2, i2, r2, n2, o2);
              l2.emplaceBack(u3[0], u3[1], u3[2]);
            }
          }
          for (let e3 = 0; e3 < 4; e3++)
            for (let t3 = 0; t3 < 4; t3++) {
              const i3 = u2(e3, t3), r3 = u2(e3, t3 + 1), n3 = u2(e3 + 1, t3), o3 = u2(e3 + 1, t3 + 1);
              a2.emplaceBack(i3, r3, n3), a2.emplaceBack(n3, r3, o3);
            }
          this._tileDebugTextIndexBuffer = e2.createIndexBuffer(a2), this._tileDebugTextBuffer = e2.createVertexBuffer(s2, su.members), this._globeTileDebugTextBuffer = e2.createVertexBuffer(l2, ou.members), this._tileDebugTextSegments = SegmentVector.simpleSegment(0, 0, c2, 32);
        }
      }
      class SourceFeatureState {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(e2, t2, i2) {
          const r2 = String(t2);
          if (this.stateChanges[e2] = this.stateChanges[e2] || {}, this.stateChanges[e2][r2] = this.stateChanges[e2][r2] || {}, P(this.stateChanges[e2][r2], i2), null === this.deletedStates[e2]) {
            this.deletedStates[e2] = {};
            for (const t3 in this.state[e2])
              t3 !== r2 && (this.deletedStates[e2][t3] = null);
          } else if (this.deletedStates[e2] && null === this.deletedStates[e2][r2]) {
            this.deletedStates[e2][r2] = {};
            for (const t3 in this.state[e2][r2])
              i2[t3] || (this.deletedStates[e2][r2][t3] = null);
          } else
            for (const t3 in i2)
              this.deletedStates[e2] && this.deletedStates[e2][r2] && null === this.deletedStates[e2][r2][t3] && delete this.deletedStates[e2][r2][t3];
        }
        removeFeatureState(e2, t2, i2) {
          if (null === this.deletedStates[e2])
            return;
          const r2 = String(t2);
          if (this.deletedStates[e2] = this.deletedStates[e2] || {}, i2 && void 0 !== t2)
            null !== this.deletedStates[e2][r2] && (this.deletedStates[e2][r2] = this.deletedStates[e2][r2] || {}, this.deletedStates[e2][r2][i2] = null);
          else if (void 0 !== t2)
            if (this.stateChanges[e2] && this.stateChanges[e2][r2])
              for (i2 in this.deletedStates[e2][r2] = {}, this.stateChanges[e2][r2])
                this.deletedStates[e2][r2][i2] = null;
            else
              this.deletedStates[e2][r2] = null;
          else
            this.deletedStates[e2] = null;
        }
        getState(e2, t2) {
          const i2 = String(t2), r2 = P({}, (this.state[e2] || {})[i2], (this.stateChanges[e2] || {})[i2]);
          if (null === this.deletedStates[e2])
            return {};
          if (this.deletedStates[e2]) {
            const i3 = this.deletedStates[e2][t2];
            if (null === i3)
              return {};
            for (const e3 in i3)
              delete r2[e3];
          }
          return r2;
        }
        initializeTileState(e2, t2) {
          e2.setFeatureState(this.state, t2);
        }
        coalesceChanges(e2, t2) {
          const i2 = {};
          for (const e3 in this.stateChanges) {
            this.state[e3] = this.state[e3] || {};
            const t3 = {};
            for (const i3 in this.stateChanges[e3])
              this.state[e3][i3] || (this.state[e3][i3] = {}), P(this.state[e3][i3], this.stateChanges[e3][i3]), t3[i3] = this.state[e3][i3];
            i2[e3] = t3;
          }
          for (const e3 in this.deletedStates) {
            this.state[e3] = this.state[e3] || {};
            const t3 = {};
            if (null === this.deletedStates[e3])
              for (const i3 in this.state[e3])
                t3[i3] = {}, this.state[e3][i3] = {};
            else
              for (const i3 in this.deletedStates[e3]) {
                if (null === this.deletedStates[e3][i3])
                  this.state[e3][i3] = {};
                else
                  for (const t4 of Object.keys(this.deletedStates[e3][i3]))
                    delete this.state[e3][i3][t4];
                t3[i3] = this.state[e3][i3];
              }
            i2[e3] = i2[e3] || {}, P(i2[e3], t3);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(i2).length)
            for (const r2 in e2)
              e2[r2].setFeatureState(i2, t2);
        }
      }
      class MipLevel {
        constructor(e2) {
          this.size = e2, this.minimums = [], this.maximums = [], this.leaves = [];
        }
        getElevation(e2, t2) {
          const i2 = this.toIdx(e2, t2);
          return { min: this.minimums[i2], max: this.maximums[i2] };
        }
        isLeaf(e2, t2) {
          return this.leaves[this.toIdx(e2, t2)];
        }
        toIdx(e2, t2) {
          return t2 * this.size + e2;
        }
      }
      function qh(e2, t2, i2, r2) {
        let n2 = 0, o2 = Number.MAX_VALUE;
        for (let s2 = 0; s2 < 3; s2++)
          if (Math.abs(r2[s2]) < 1e-15) {
            if (i2[s2] < e2[s2] || i2[s2] > t2[s2])
              return null;
          } else {
            const a2 = 1 / r2[s2];
            let l2 = (e2[s2] - i2[s2]) * a2, c2 = (t2[s2] - i2[s2]) * a2;
            if (l2 > c2) {
              const e3 = l2;
              l2 = c2, c2 = e3;
            }
            if (l2 > n2 && (n2 = l2), c2 < o2 && (o2 = c2), n2 > o2)
              return null;
          }
        return n2;
      }
      function Zh(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2) {
        const h2 = r2 - e2, p2 = n2 - t2, d2 = o2 - i2, f2 = s2 - e2, m2 = a2 - t2, _2 = l2 - i2, g2 = u2[1] * _2 - u2[2] * m2, y2 = u2[2] * f2 - u2[0] * _2, x2 = u2[0] * m2 - u2[1] * f2, v2 = h2 * g2 + p2 * y2 + d2 * x2;
        if (Math.abs(v2) < 1e-15)
          return null;
        const b2 = 1 / v2, w2 = c2[0] - e2, T2 = c2[1] - t2, E2 = c2[2] - i2, S2 = (w2 * g2 + T2 * y2 + E2 * x2) * b2;
        if (S2 < 0 || S2 > 1)
          return null;
        const A2 = T2 * d2 - E2 * p2, C2 = E2 * h2 - w2 * d2, I2 = w2 * p2 - T2 * h2, M2 = (u2[0] * A2 + u2[1] * C2 + u2[2] * I2) * b2;
        return M2 < 0 || S2 + M2 > 1 ? null : (f2 * A2 + m2 * C2 + _2 * I2) * b2;
      }
      function $h(e2, t2, i2) {
        return (e2 - t2) / (i2 - t2);
      }
      function Wh(e2, t2, i2, r2, n2, o2, s2, a2, l2) {
        const c2 = 1 << i2, u2 = o2 - r2, h2 = s2 - n2, p2 = (e2 + 1) / c2 * u2 + r2, d2 = (t2 + 0) / c2 * h2 + n2, f2 = (t2 + 1) / c2 * h2 + n2;
        a2[0] = (e2 + 0) / c2 * u2 + r2, a2[1] = d2, l2[0] = p2, l2[1] = f2;
      }
      class DemMinMaxQuadTree {
        constructor(e2) {
          if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = e2, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
            return;
          const t2 = function(e3) {
            const t3 = Math.ceil(Math.log2(e3.dim / 8)), i3 = [];
            let r3 = Math.ceil(Math.pow(2, t3));
            const n2 = 1 / r3, o2 = (e4, t4, i4, r4, n3) => {
              const o3 = r4 ? 1 : 0, s3 = (e4 + 1) * i4 - o3, a3 = t4 * i4, l2 = (t4 + 1) * i4 - o3;
              n3[0] = e4 * i4, n3[1] = a3, n3[2] = s3, n3[3] = l2;
            };
            let s2 = new MipLevel(r3);
            const a2 = [];
            for (let t4 = 0; t4 < r3 * r3; t4++) {
              o2(t4 % r3, Math.floor(t4 / r3), n2, false, a2);
              const i4 = Xh(a2[0], a2[1], e3), l2 = Xh(a2[2], a2[1], e3), c2 = Xh(a2[2], a2[3], e3), u2 = Xh(a2[0], a2[3], e3);
              s2.minimums.push(Math.min(i4, l2, c2, u2)), s2.maximums.push(Math.max(i4, l2, c2, u2)), s2.leaves.push(1);
            }
            for (i3.push(s2), r3 /= 2; r3 >= 1; r3 /= 2) {
              const e4 = i3[i3.length - 1];
              s2 = new MipLevel(r3);
              for (let t4 = 0; t4 < r3 * r3; t4++) {
                o2(t4 % r3, Math.floor(t4 / r3), 2, true, a2);
                const i4 = e4.getElevation(a2[0], a2[1]), n3 = e4.getElevation(a2[2], a2[1]), l2 = e4.getElevation(a2[2], a2[3]), c2 = e4.getElevation(a2[0], a2[3]), u2 = e4.isLeaf(a2[0], a2[1]), h2 = e4.isLeaf(a2[2], a2[1]), p2 = e4.isLeaf(a2[2], a2[3]), d2 = e4.isLeaf(a2[0], a2[3]), f2 = Math.min(i4.min, n3.min, l2.min, c2.min), m2 = Math.max(i4.max, n3.max, l2.max, c2.max), _2 = u2 && h2 && p2 && d2;
                s2.maximums.push(m2), s2.minimums.push(f2), s2.leaves.push(m2 - f2 <= 5 && _2 ? 1 : 0);
              }
              i3.push(s2);
            }
            return i3;
          }(this.dem), i2 = t2.length - 1, r2 = t2[i2];
          this._addNode(r2.minimums[0], r2.maximums[0], r2.leaves[0]), this._construct(t2, 0, 0, i2, 0);
        }
        raycastRoot(e2, t2, i2, r2, n2, o2, s2 = 1) {
          return qh([e2, t2, -100], [i2, r2, this.maximums[0] * s2], n2, o2);
        }
        raycast(e2, t2, i2, r2, n2, o2, s2 = 1) {
          if (!this.nodeCount)
            return null;
          const a2 = this.raycastRoot(e2, t2, i2, r2, n2, o2, s2);
          if (null == a2)
            return null;
          const l2 = [], c2 = [], u2 = [], h2 = [], p2 = [{ idx: 0, t: a2, nodex: 0, nodey: 0, depth: 0 }];
          for (; p2.length > 0; ) {
            const { idx: a3, t: d2, nodex: f2, nodey: m2, depth: _2 } = p2.pop();
            if (this.leaves[a3]) {
              Wh(f2, m2, _2, e2, t2, i2, r2, u2, h2);
              const a4 = 1 << _2, l3 = (f2 + 0) / a4, c3 = (f2 + 1) / a4, p3 = (m2 + 0) / a4, g3 = (m2 + 1) / a4, y2 = Xh(l3, p3, this.dem) * s2, x2 = Xh(c3, p3, this.dem) * s2, v2 = Xh(c3, g3, this.dem) * s2, b2 = Xh(l3, g3, this.dem) * s2, w2 = Zh(u2[0], u2[1], y2, h2[0], u2[1], x2, h2[0], h2[1], v2, n2, o2), T2 = Zh(h2[0], h2[1], v2, u2[0], h2[1], b2, u2[0], u2[1], y2, n2, o2), E2 = Math.min(null !== w2 ? w2 : Number.MAX_VALUE, null !== T2 ? T2 : Number.MAX_VALUE);
              if (E2 !== Number.MAX_VALUE)
                return E2;
              {
                const e3 = Js([], n2, o2, d2);
                if (Hh(y2, x2, b2, v2, $h(e3[0], u2[0], h2[0]), $h(e3[1], u2[1], h2[1])) >= e3[2])
                  return d2;
              }
              continue;
            }
            let g2 = 0;
            for (let p3 = 0; p3 < this._siblingOffset.length; p3++) {
              Wh((f2 << 1) + this._siblingOffset[p3][0], (m2 << 1) + this._siblingOffset[p3][1], _2 + 1, e2, t2, i2, r2, u2, h2), u2[2] = -100, h2[2] = this.maximums[this.childOffsets[a3] + p3] * s2;
              const d3 = qh(u2, h2, n2, o2);
              if (null != d3) {
                const e3 = d3;
                l2[p3] = e3;
                let t3 = false;
                for (let i3 = 0; i3 < g2 && !t3; i3++)
                  e3 >= l2[c2[i3]] && (c2.splice(i3, 0, p3), t3 = true);
                t3 || (c2[g2] = p3), g2++;
              }
            }
            for (let e3 = 0; e3 < g2; e3++) {
              const t3 = c2[e3];
              p2.push({ idx: this.childOffsets[a3] + t3, t: l2[t3], nodex: (f2 << 1) + this._siblingOffset[t3][0], nodey: (m2 << 1) + this._siblingOffset[t3][1], depth: _2 + 1 });
            }
          }
          return null;
        }
        _addNode(e2, t2, i2) {
          return this.minimums.push(e2), this.maximums.push(t2), this.leaves.push(i2), this.childOffsets.push(0), this.nodeCount++;
        }
        _construct(e2, t2, i2, r2, n2) {
          if (1 === e2[r2].isLeaf(t2, i2))
            return;
          this.childOffsets[n2] || (this.childOffsets[n2] = this.nodeCount);
          const o2 = r2 - 1, s2 = e2[o2];
          let a2 = 0, l2 = 0;
          for (let e3 = 0; e3 < this._siblingOffset.length; e3++) {
            const r3 = 2 * t2 + this._siblingOffset[e3][0], n3 = 2 * i2 + this._siblingOffset[e3][1], o3 = s2.getElevation(r3, n3), c2 = s2.isLeaf(r3, n3), u2 = this._addNode(o3.min, o3.max, c2);
            c2 && (a2 |= 1 << e3), l2 || (l2 = u2);
          }
          for (let r3 = 0; r3 < this._siblingOffset.length; r3++)
            a2 & 1 << r3 || this._construct(e2, 2 * t2 + this._siblingOffset[r3][0], 2 * i2 + this._siblingOffset[r3][1], o2, l2 + r3);
        }
      }
      function Hh(e2, t2, i2, r2, n2, o2) {
        return Ii(Ii(e2, i2, o2), Ii(t2, r2, o2), n2);
      }
      function Xh(e2, t2, i2) {
        const r2 = i2.dim, n2 = A(e2 * r2 - 0.5, 0, r2 - 1), o2 = A(t2 * r2 - 0.5, 0, r2 - 1), s2 = Math.floor(n2), a2 = Math.floor(o2), l2 = Math.min(s2 + 1, r2 - 1), c2 = Math.min(a2 + 1, r2 - 1);
        return Hh(i2.get(s2, a2), i2.get(l2, a2), i2.get(s2, c2), i2.get(l2, c2), n2 - s2, o2 - a2);
      }
      const Kh = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
      class DEMData {
        get tree() {
          return this._tree || this._buildQuadTree(), this._tree;
        }
        constructor(e2, t2, i2, r2 = false, n2 = false) {
          if (this.uid = e2, t2.height !== t2.width)
            throw new RangeError("DEM tiles must be square");
          if (i2 && "mapbox" !== i2 && "terrarium" !== i2)
            return Z(`"${i2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
          this.stride = t2.height;
          const o2 = this.dim = t2.height - 2, s2 = new Uint32Array(t2.data.buffer);
          if (this.pixels = new Uint8Array(t2.data.buffer), this.encoding = i2 || "mapbox", this.borderReady = r2, !r2) {
            for (let e3 = 0; e3 < o2; e3++)
              s2[this._idx(-1, e3)] = s2[this._idx(0, e3)], s2[this._idx(o2, e3)] = s2[this._idx(o2 - 1, e3)], s2[this._idx(e3, -1)] = s2[this._idx(e3, 0)], s2[this._idx(e3, o2)] = s2[this._idx(e3, o2 - 1)];
            s2[this._idx(-1, -1)] = s2[this._idx(0, 0)], s2[this._idx(o2, -1)] = s2[this._idx(o2 - 1, 0)], s2[this._idx(-1, o2)] = s2[this._idx(0, o2 - 1)], s2[this._idx(o2, o2)] = s2[this._idx(o2 - 1, o2 - 1)], n2 && this._buildQuadTree();
          }
        }
        _buildQuadTree() {
          this._tree = new DemMinMaxQuadTree(this);
        }
        get(e2, t2, i2 = false) {
          i2 && (e2 = A(e2, -1, this.dim), t2 = A(t2, -1, this.dim));
          const r2 = 4 * this._idx(e2, t2);
          return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(this.pixels[r2], this.pixels[r2 + 1], this.pixels[r2 + 2]);
        }
        static getUnpackVector(e2) {
          return Kh[e2];
        }
        get unpackVector() {
          return Kh[this.encoding];
        }
        _idx(e2, t2) {
          if (e2 < -1 || e2 >= this.dim + 1 || t2 < -1 || t2 >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (t2 + 1) * this.stride + (e2 + 1);
        }
        _unpackMapbox(e2, t2, i2) {
          return (256 * e2 * 256 + 256 * t2 + i2) / 10 - 1e4;
        }
        _unpackTerrarium(e2, t2, i2) {
          return 256 * e2 + t2 + i2 / 256 - 32768;
        }
        static pack(e2, t2) {
          const i2 = [0, 0, 0, 0], r2 = DEMData.getUnpackVector(t2);
          let n2 = Math.floor((e2 + r2[3]) / r2[2]);
          return i2[2] = n2 % 256, n2 = Math.floor(n2 / 256), i2[1] = n2 % 256, n2 = Math.floor(n2 / 256), i2[0] = n2, i2;
        }
        getPixels() {
          return new RGBAImage({ width: this.stride, height: this.stride }, this.pixels);
        }
        backfillBorder(e2, t2, i2) {
          if (this.dim !== e2.dim)
            throw new Error("dem dimension mismatch");
          let r2 = t2 * this.dim, n2 = t2 * this.dim + this.dim, o2 = i2 * this.dim, s2 = i2 * this.dim + this.dim;
          switch (t2) {
            case -1:
              r2 = n2 - 1;
              break;
            case 1:
              n2 = r2 + 1;
          }
          switch (i2) {
            case -1:
              o2 = s2 - 1;
              break;
            case 1:
              s2 = o2 + 1;
          }
          const a2 = -t2 * this.dim, l2 = -i2 * this.dim;
          for (let t3 = o2; t3 < s2; t3++)
            for (let i3 = r2; i3 < n2; i3++) {
              const r3 = 4 * this._idx(i3, t3), n3 = 4 * this._idx(i3 + a2, t3 + l2);
              this.pixels[r3 + 0] = e2.pixels[n3 + 0], this.pixels[r3 + 1] = e2.pixels[n3 + 1], this.pixels[r3 + 2] = e2.pixels[n3 + 2], this.pixels[r3 + 3] = e2.pixels[n3 + 3];
            }
        }
        onDeserialize() {
          this._tree && (this._tree.dem = this);
        }
      }
      kn(DEMData, "DEMData"), kn(DemMinMaxQuadTree, "DemMinMaxQuadTree", { omit: ["dem"] });
      class TileCache {
        constructor(e2, t2) {
          this.max = e2, this.onRemove = t2, this.reset();
        }
        reset() {
          for (const e2 in this.data)
            for (const t2 of this.data[e2])
              t2.timeout && clearTimeout(t2.timeout), this.onRemove(t2.value);
          return this.data = {}, this.order = [], this;
        }
        add(e2, t2, i2) {
          const r2 = e2.wrapped().key;
          void 0 === this.data[r2] && (this.data[r2] = []);
          const n2 = { value: t2, timeout: void 0 };
          if (void 0 !== i2 && (n2.timeout = setTimeout(() => {
            this.remove(e2, n2);
          }, i2)), this.data[r2].push(n2), this.order.push(r2), this.order.length > this.max) {
            const e3 = this._getAndRemoveByKey(this.order[0]);
            e3 && this.onRemove(e3);
          }
          return this;
        }
        has(e2) {
          return e2.wrapped().key in this.data;
        }
        getAndRemove(e2) {
          return this.has(e2) ? this._getAndRemoveByKey(e2.wrapped().key) : null;
        }
        _getAndRemoveByKey(e2) {
          const t2 = this.data[e2].shift();
          return t2.timeout && clearTimeout(t2.timeout), 0 === this.data[e2].length && delete this.data[e2], this.order.splice(this.order.indexOf(e2), 1), t2.value;
        }
        getByKey(e2) {
          const t2 = this.data[e2];
          return t2 ? t2[0].value : null;
        }
        get(e2) {
          return this.has(e2) ? this.data[e2.wrapped().key][0].value : null;
        }
        remove(e2, t2) {
          if (!this.has(e2))
            return this;
          const i2 = e2.wrapped().key, r2 = void 0 === t2 ? 0 : this.data[i2].indexOf(t2), n2 = this.data[i2][r2];
          return this.data[i2].splice(r2, 1), n2.timeout && clearTimeout(n2.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(n2.value), this.order.splice(this.order.indexOf(i2), 1), this;
        }
        setMaxSize(e2) {
          for (this.max = e2; this.order.length > this.max; ) {
            const e3 = this._getAndRemoveByKey(this.order[0]);
            e3 && this.onRemove(e3);
          }
          return this;
        }
        filter(e2) {
          const t2 = [];
          for (const i2 in this.data)
            for (const r2 of this.data[i2])
              e2(r2.value) || t2.push(r2);
          for (const e3 of t2)
            this.remove(e3.value.tileID, e3);
        }
      }
      class IndexBuffer {
        constructor(e2, t2, i2) {
          this.context = e2;
          const r2 = e2.gl;
          this.buffer = r2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), r2.bufferData(r2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || t2.destroy();
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(e2) {
          const t2 = this.context.gl;
          this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Yh = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class VertexBuffer {
        constructor(e2, t2, i2, r2) {
          this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = r2, this.context = e2;
          const n2 = e2.gl;
          this.buffer = n2.createBuffer(), e2.bindVertexBuffer.set(this.buffer), n2.bufferData(n2.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? n2.DYNAMIC_DRAW : n2.STATIC_DRAW), this.dynamicDraw || t2.destroy();
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e2) {
          const t2 = this.context.gl;
          this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
        }
        enableAttributes(e2, t2) {
          for (let i2 = 0; i2 < this.attributes.length; i2++) {
            const r2 = t2.attributes[this.attributes[i2].name];
            void 0 !== r2 && e2.enableVertexAttribArray(r2);
          }
        }
        setVertexAttribPointers(e2, t2, i2) {
          for (let r2 = 0; r2 < this.attributes.length; r2++) {
            const n2 = this.attributes[r2], o2 = t2.attributes[n2.name];
            void 0 !== o2 && e2.vertexAttribPointer(o2, n2.components, e2[Yh[n2.type]], false, this.itemSize, n2.offset + this.itemSize * (i2 || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class BaseValue {
        constructor(e2) {
          this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(e2) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class ClearColor extends BaseValue {
        getDefault() {
          return Gt.transparent;
        }
        set(e2) {
          const t2 = this.current;
          (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
        }
      }
      class ClearDepth extends BaseValue {
        getDefault() {
          return 1;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
        }
      }
      class ClearStencil extends BaseValue {
        getDefault() {
          return 0;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
        }
      }
      class ColorMask extends BaseValue {
        getDefault() {
          return [true, true, true, true];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
        }
      }
      class DepthMask extends BaseValue {
        getDefault() {
          return true;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
        }
      }
      class StencilMask extends BaseValue {
        getDefault() {
          return 255;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
        }
      }
      class StencilFunc extends BaseValue {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e2) {
          const t2 = this.current;
          (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
        }
      }
      class StencilOp extends BaseValue {
        getDefault() {
          const e2 = this.gl;
          return [e2.KEEP, e2.KEEP, e2.KEEP];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
        }
      }
      class StencilTest extends BaseValue {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
        }
      }
      class DepthRange extends BaseValue {
        getDefault() {
          return [0, 1];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
        }
      }
      class DepthTest extends BaseValue {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
        }
      }
      class DepthFunc extends BaseValue {
        getDefault() {
          return this.gl.LESS;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
        }
      }
      class Blend extends BaseValue {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
        }
      }
      class BlendFunc extends BaseValue {
        getDefault() {
          const e2 = this.gl;
          return [e2.ONE, e2.ZERO];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.blendFunc(e2[0], e2[1]), this.current = e2, this.dirty = false);
        }
      }
      class BlendColor extends BaseValue {
        getDefault() {
          return Gt.transparent;
        }
        set(e2) {
          const t2 = this.current;
          (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
        }
      }
      class BlendEquation extends BaseValue {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.blendEquation(e2), this.current = e2, this.dirty = false);
        }
      }
      class CullFace extends BaseValue {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
        }
      }
      class CullFaceSide extends BaseValue {
        getDefault() {
          return this.gl.BACK;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
        }
      }
      class FrontFace extends BaseValue {
        getDefault() {
          return this.gl.CCW;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
        }
      }
      class Program$1 extends BaseValue {
        getDefault() {
          return null;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
        }
      }
      class ActiveTextureUnit extends BaseValue {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
        }
      }
      class Viewport extends BaseValue {
        getDefault() {
          const e2 = this.gl;
          return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
        }
      }
      class BindFramebuffer extends BaseValue {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class BindRenderbuffer extends BaseValue {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class BindTexture extends BaseValue {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
        }
      }
      class BindVertexBuffer extends BaseValue {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class BindElementBuffer extends BaseValue {
        getDefault() {
          return null;
        }
        set(e2) {
          const t2 = this.gl;
          t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class BindVertexArrayOES extends BaseValue {
        constructor(e2) {
          super(e2), this.vao = e2.extVertexArrayObject;
        }
        getDefault() {
          return null;
        }
        set(e2) {
          this.vao && (e2 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e2), this.current = e2, this.dirty = false);
        }
      }
      class PixelStoreUnpack extends BaseValue {
        getDefault() {
          return 4;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
        }
      }
      class PixelStoreUnpackPremultiplyAlpha extends BaseValue {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
        }
      }
      class PixelStoreUnpackFlipY extends BaseValue {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
        }
      }
      class FramebufferAttachment extends BaseValue {
        constructor(e2, t2) {
          super(e2), this.context = e2, this.parent = t2;
        }
        getDefault() {
          return null;
        }
      }
      class ColorAttachment extends FramebufferAttachment {
        setDirty() {
          this.dirty = true;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t2 = this.gl;
          t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
        }
      }
      class DepthAttachment extends FramebufferAttachment {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t2 = this.gl;
          t2.framebufferRenderbuffer(t2.FRAMEBUFFER, this.attachment(), t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class DepthStencilAttachment extends DepthAttachment {
        attachment() {
          return this.gl.DEPTH_STENCIL_ATTACHMENT;
        }
      }
      class Framebuffer {
        constructor(e2, t2, i2, r2) {
          this.context = e2, this.width = t2, this.height = i2;
          const n2 = this.framebuffer = e2.gl.createFramebuffer();
          this.colorAttachment = new ColorAttachment(e2, n2), r2 && (this.depthAttachment = new DepthAttachment(e2, n2));
        }
        destroy() {
          const e2 = this.context.gl, t2 = this.colorAttachment.get();
          if (t2 && e2.deleteTexture(t2), this.depthAttachment) {
            const t3 = this.depthAttachment.get();
            t3 && e2.deleteRenderbuffer(t3);
          }
          e2.deleteFramebuffer(this.framebuffer);
        }
      }
      class DepthMode {
        constructor(e2, t2, i2) {
          this.func = e2, this.mask = t2, this.range = i2;
        }
      }
      DepthMode.ReadOnly = false, DepthMode.ReadWrite = true, DepthMode.disabled = new DepthMode(519, DepthMode.ReadOnly, [0, 1]);
      const Jh = 7680;
      class StencilMode {
        constructor(e2, t2, i2, r2, n2, o2) {
          this.test = e2, this.ref = t2, this.mask = i2, this.fail = r2, this.depthFail = n2, this.pass = o2;
        }
      }
      StencilMode.disabled = new StencilMode({ func: 519, mask: 0 }, 0, 0, Jh, Jh, Jh);
      class ColorMode {
        constructor(e2, t2, i2) {
          this.blendFunction = e2, this.blendColor = t2, this.mask = i2;
        }
      }
      ColorMode.Replace = [1, 0], ColorMode.disabled = new ColorMode(ColorMode.Replace, Gt.transparent, [false, false, false, false]), ColorMode.unblended = new ColorMode(ColorMode.Replace, Gt.transparent, [true, true, true, true]), ColorMode.alphaBlended = new ColorMode([1, 771], Gt.transparent, [true, true, true, true]);
      const Qh = 1029, ep = 2305;
      class CullFaceMode {
        constructor(e2, t2, i2) {
          this.enable = e2, this.mode = t2, this.frontFace = i2;
        }
      }
      CullFaceMode.disabled = new CullFaceMode(false, Qh, ep), CullFaceMode.backCCW = new CullFaceMode(true, Qh, ep), CullFaceMode.backCW = new CullFaceMode(true, Qh, 2304), CullFaceMode.frontCW = new CullFaceMode(true, 1028, 2304), CullFaceMode.frontCCW = new CullFaceMode(true, 1028, ep);
      class Context {
        constructor(e2) {
          this.gl = e2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new ClearColor(this), this.clearDepth = new ClearDepth(this), this.clearStencil = new ClearStencil(this), this.colorMask = new ColorMask(this), this.depthMask = new DepthMask(this), this.stencilMask = new StencilMask(this), this.stencilFunc = new StencilFunc(this), this.stencilOp = new StencilOp(this), this.stencilTest = new StencilTest(this), this.depthRange = new DepthRange(this), this.depthTest = new DepthTest(this), this.depthFunc = new DepthFunc(this), this.blend = new Blend(this), this.blendFunc = new BlendFunc(this), this.blendColor = new BlendColor(this), this.blendEquation = new BlendEquation(this), this.cullFace = new CullFace(this), this.cullFaceSide = new CullFaceSide(this), this.frontFace = new FrontFace(this), this.program = new Program$1(this), this.activeTexture = new ActiveTextureUnit(this), this.viewport = new Viewport(this), this.bindFramebuffer = new BindFramebuffer(this), this.bindRenderbuffer = new BindRenderbuffer(this), this.bindTexture = new BindTexture(this), this.bindVertexBuffer = new BindVertexBuffer(this), this.bindElementBuffer = new BindElementBuffer(this), this.bindVertexArrayOES = this.extVertexArrayObject && new BindVertexArrayOES(this), this.pixelStoreUnpack = new PixelStoreUnpack(this), this.pixelStoreUnpackPremultiplyAlpha = new PixelStoreUnpackPremultiplyAlpha(this), this.pixelStoreUnpackFlipY = new PixelStoreUnpackFlipY(this), this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = false, this.extStandardDerivativesForceOff = false, this.extDebugRendererInfo = e2.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e2.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e2.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.extTextureHalfFloat = e2.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (e2.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = e2.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = e2.getExtension("OES_standard_derivatives"), this.extTimerQuery = e2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE);
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(e2, t2) {
          return new IndexBuffer(this, e2, t2);
        }
        createVertexBuffer(e2, t2, i2) {
          return new VertexBuffer(this, e2, t2, i2);
        }
        createRenderbuffer(e2, t2, i2) {
          const r2 = this.gl, n2 = r2.createRenderbuffer();
          return this.bindRenderbuffer.set(n2), r2.renderbufferStorage(r2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), n2;
        }
        createFramebuffer(e2, t2, i2) {
          return new Framebuffer(this, e2, t2, i2);
        }
        clear({ color: e2, depth: t2, stencil: i2 }) {
          const r2 = this.gl;
          let n2 = 0;
          e2 && (n2 |= r2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), void 0 !== t2 && (n2 |= r2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), void 0 !== i2 && (n2 |= r2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), r2.clear(n2);
        }
        setCullFace(e2) {
          false === e2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
        }
        setDepthMode(e2) {
          e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
        }
        setStencilMode(e2) {
          e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
        }
        setColorMode(e2) {
          m(e2.blendFunction, ColorMode.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
        }
        unbindVAO() {
          this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
        }
      }
      class SourceCache extends Evented {
        constructor(e2, t2, i2) {
          super(), this.id = e2, this._onlySymbols = i2, t2.on("data", (e3) => {
            "source" === e3.dataType && "metadata" === e3.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e3.dataType && "content" === e3.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
          }), t2.on("error", () => {
            this._sourceErrored = true;
          }), this._source = t2, this._tiles = {}, this._cache = new TileCache(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new SourceFeatureState(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
        }
        onAdd(e2) {
          this.map = e2, this._minTileCacheSize = void 0 === this._minTileCacheSize && e2 ? e2._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e2 ? e2._maxTileCacheSize : this._maxTileCacheSize;
        }
        loaded() {
          if (this._sourceErrored)
            return true;
          if (!this._sourceLoaded)
            return false;
          if (!this._source.loaded())
            return false;
          for (const e2 in this._tiles) {
            const t2 = this._tiles[e2];
            if ("loaded" !== t2.state && "errored" !== t2.state)
              return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused)
            return;
          const e2 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, e2 && this.reload(), this.transform && this.update(this.transform);
        }
        _loadTile(e2, t2) {
          return e2.isSymbolTile = this._onlySymbols, this._source.loadTile(e2, t2);
        }
        _unloadTile(e2) {
          if (this._source.unloadTile)
            return this._source.unloadTile(e2, () => {
            });
        }
        _abortTile(e2) {
          if (this._source.abortTile)
            return this._source.abortTile(e2, () => {
            });
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(e2) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const t2 in this._tiles) {
            const i2 = this._tiles[t2];
            i2.upload(e2), i2.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return D(this._tiles).map((e2) => e2.tileID).sort(tp).map((e2) => e2.key);
        }
        getRenderableIds(e2) {
          const t2 = [];
          for (const i2 in this._tiles)
            this._isIdRenderable(+i2, e2) && t2.push(this._tiles[i2]);
          return e2 ? t2.sort((e3, t3) => {
            const i2 = e3.tileID, r2 = t3.tileID, n2 = new d(i2.canonical.x, i2.canonical.y)._rotate(this.transform.angle), o2 = new d(r2.canonical.x, r2.canonical.y)._rotate(this.transform.angle);
            return i2.overscaledZ - r2.overscaledZ || o2.y - n2.y || o2.x - n2.x;
          }).map((e3) => e3.tileID.key) : t2.map((e3) => e3.tileID).sort(tp).map((e3) => e3.key);
        }
        hasRenderableParent(e2) {
          const t2 = this.findLoadedParent(e2, 0);
          return !!t2 && this._isIdRenderable(t2.tileID.key);
        }
        _isIdRenderable(e2, t2) {
          return this._tiles[e2] && this._tiles[e2].hasData() && !this._coveredTiles[e2] && (t2 || !this._tiles[e2].holdingForFade());
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = true;
          else {
            this._cache.reset();
            for (const e2 in this._tiles)
              "errored" !== this._tiles[e2].state && this._reloadTile(+e2, "reloading");
          }
        }
        _reloadTile(e2, t2) {
          const i2 = this._tiles[e2];
          i2 && ("loading" !== i2.state && (i2.state = t2), this._loadTile(i2, this._tileLoaded.bind(this, i2, e2, t2)));
        }
        _tileLoaded(e2, t2, i2, r2) {
          if (r2)
            if (e2.state = "errored", 404 !== r2.status)
              this._source.fire(new ErrorEvent(r2, { tile: e2 }));
            else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
              const e3 = this.map.painter.terrain;
              this.update(this.transform, e3.getScaledDemTileSize(), true), e3.resetTileLookupCache(this.id);
            } else
              this.update(this.transform);
          else
            e2.timeAdded = Je.now(), "expired" === i2 && (e2.refreshedUponExpiration = true), this._setTileReloadTimer(t2, e2), "raster-dem" === this._source.type && e2.dem && this._backfillDEM(e2), this._state.initializeTileState(e2, this.map ? this.map.painter : null), this._source.fire(new Event("data", { dataType: "source", tile: e2, coord: e2.tileID, sourceCacheId: this.id }));
        }
        _backfillDEM(e2) {
          const t2 = this.getRenderableIds();
          for (let r2 = 0; r2 < t2.length; r2++) {
            const n2 = t2[r2];
            if (e2.neighboringTiles && e2.neighboringTiles[n2]) {
              const t3 = this.getTileByID(n2);
              i2(e2, t3), i2(t3, e2);
            }
          }
          function i2(e3, t3) {
            if (!e3.dem || e3.dem.borderReady)
              return;
            e3.needsHillshadePrepare = true, e3.needsDEMTextureUpload = true;
            let i3 = t3.tileID.canonical.x - e3.tileID.canonical.x;
            const r2 = t3.tileID.canonical.y - e3.tileID.canonical.y, n2 = Math.pow(2, e3.tileID.canonical.z), o2 = t3.tileID.key;
            0 === i3 && 0 === r2 || Math.abs(r2) > 1 || (Math.abs(i3) > 1 && (1 === Math.abs(i3 + n2) ? i3 += n2 : 1 === Math.abs(i3 - n2) && (i3 -= n2)), t3.dem && e3.dem && (e3.dem.backfillBorder(t3.dem, i3, r2), e3.neighboringTiles && e3.neighboringTiles[o2] && (e3.neighboringTiles[o2].backfilled = true)));
          }
        }
        getTile(e2) {
          return this.getTileByID(e2.key);
        }
        getTileByID(e2) {
          return this._tiles[e2];
        }
        _retainLoadedChildren(e2, t2, i2, r2) {
          for (const n2 in this._tiles) {
            let o2 = this._tiles[n2];
            if (r2[n2] || !o2.hasData() || o2.tileID.overscaledZ <= t2 || o2.tileID.overscaledZ > i2)
              continue;
            let s2 = o2.tileID;
            for (; o2 && o2.tileID.overscaledZ > t2 + 1; ) {
              const e3 = o2.tileID.scaledTo(o2.tileID.overscaledZ - 1);
              o2 = this._tiles[e3.key], o2 && o2.hasData() && (s2 = e3);
            }
            let a2 = s2;
            for (; a2.overscaledZ > t2; )
              if (a2 = a2.scaledTo(a2.overscaledZ - 1), e2[a2.key]) {
                r2[s2.key] = s2;
                break;
              }
          }
        }
        findLoadedParent(e2, t2) {
          if (e2.key in this._loadedParentTiles) {
            const i2 = this._loadedParentTiles[e2.key];
            return i2 && i2.tileID.overscaledZ >= t2 ? i2 : null;
          }
          for (let i2 = e2.overscaledZ - 1; i2 >= t2; i2--) {
            const t3 = e2.scaledTo(i2), r2 = this._getLoadedTile(t3);
            if (r2)
              return r2;
          }
        }
        _getLoadedTile(e2) {
          const t2 = this._tiles[e2.key];
          return t2 && t2.hasData() ? t2 : this._cache.getByKey(this._source.reparseOverscaled ? e2.wrapped().key : e2.canonical.key);
        }
        updateCacheSize(e2, t2) {
          t2 = t2 || this._source.tileSize;
          const i2 = Math.ceil(e2.width / t2) + 1, r2 = Math.ceil(e2.height / t2) + 1, n2 = Math.floor(i2 * r2 * 5), o2 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, n2) : n2, s2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o2) : o2;
          this._cache.setMaxSize(s2);
        }
        handleWrapJump(e2) {
          const t2 = Math.round((e2 - (void 0 === this._prevLng ? e2 : this._prevLng)) / 360);
          if (this._prevLng = e2, t2) {
            const e3 = {};
            for (const i2 in this._tiles) {
              const r2 = this._tiles[i2];
              r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + t2), e3[r2.tileID.key] = r2;
            }
            this._tiles = e3;
            for (const e4 in this._timers)
              clearTimeout(this._timers[e4]), delete this._timers[e4];
            for (const e4 in this._tiles)
              this._setTileReloadTimer(+e4, this._tiles[e4]);
          }
        }
        update(e2, t2, i2) {
          if (this.transform = e2, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
            return;
          if (this.usedForTerrain && !i2)
            return;
          let r2;
          this.updateCacheSize(e2, t2), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? r2 = e2.getVisibleUnwrappedCoordinates(this._source.tileID).map((e3) => new OverscaledTileID(e3.canonical.z, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y)) : (r2 = e2.coveringTiles({ tileSize: t2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !i2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (r2 = r2.filter((e3) => this._source.hasTile(e3)))) : r2 = [];
          const n2 = this._updateRetainedTiles(r2);
          if (ip(this._source.type) && 0 !== r2.length) {
            const e3 = {}, t3 = {}, i3 = Object.keys(n2);
            for (const r3 of i3) {
              const i4 = n2[r3], o4 = this._tiles[r3];
              if (!o4 || o4.fadeEndTime && o4.fadeEndTime <= Je.now())
                continue;
              const s2 = this.findLoadedParent(i4, Math.max(i4.overscaledZ - SourceCache.maxOverzooming, this._source.minzoom));
              s2 && (this._addTile(s2.tileID), e3[s2.tileID.key] = s2.tileID), t3[r3] = i4;
            }
            const o3 = r2[r2.length - 1].overscaledZ;
            for (const e4 in this._tiles) {
              const i4 = this._tiles[e4];
              if (n2[e4] || !i4.hasData())
                continue;
              let r3 = i4.tileID;
              for (; r3.overscaledZ > o3; ) {
                r3 = r3.scaledTo(r3.overscaledZ - 1);
                const o4 = this._tiles[r3.key];
                if (o4 && o4.hasData() && t3[r3.key]) {
                  n2[e4] = i4.tileID;
                  break;
                }
              }
            }
            for (const t4 in e3)
              n2[t4] || (this._coveredTiles[t4] = true, n2[t4] = e3[t4]);
          }
          for (const e3 in n2)
            this._tiles[e3].clearFadeHold();
          const o2 = function(e3, t3) {
            const i3 = [];
            for (const r3 in e3)
              r3 in t3 || i3.push(r3);
            return i3;
          }(this._tiles, n2);
          for (const e3 of o2) {
            const t3 = this._tiles[e3];
            t3.hasSymbolBuckets && !t3.holdingForFade() ? t3.setHoldDuration(this.map._fadeDuration) : t3.hasSymbolBuckets && !t3.symbolFadeFinished() || this._removeTile(+e3);
          }
          this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
        }
        releaseSymbolFadeTiles() {
          for (const e2 in this._tiles)
            this._tiles[e2].holdingForFade() && this._removeTile(+e2);
        }
        _updateRetainedTiles(e2) {
          const t2 = {};
          if (0 === e2.length)
            return t2;
          const i2 = {}, r2 = e2.reduce((e3, t3) => Math.min(e3, t3.overscaledZ), 1 / 0), n2 = e2[0].overscaledZ, o2 = Math.max(n2 - SourceCache.maxOverzooming, this._source.minzoom), s2 = Math.max(n2 + SourceCache.maxUnderzooming, this._source.minzoom), a2 = {};
          for (const i3 of e2) {
            const e3 = this._addTile(i3);
            t2[i3.key] = i3, e3.hasData() || r2 < this._source.maxzoom && (a2[i3.key] = i3);
          }
          this._retainLoadedChildren(a2, r2, s2, t2);
          for (const r3 of e2) {
            let e3 = this._tiles[r3.key];
            if (e3.hasData())
              continue;
            if (r3.canonical.z >= this._source.maxzoom) {
              const e4 = r3.children(this._source.maxzoom)[0], i3 = this.getTile(e4);
              if (i3 && i3.hasData()) {
                t2[e4.key] = e4;
                continue;
              }
            } else {
              const e4 = r3.children(this._source.maxzoom);
              if (t2[e4[0].key] && t2[e4[1].key] && t2[e4[2].key] && t2[e4[3].key])
                continue;
            }
            let n3 = e3.wasRequested();
            for (let s3 = r3.overscaledZ - 1; s3 >= o2; --s3) {
              const o3 = r3.scaledTo(s3);
              if (i2[o3.key])
                break;
              if (i2[o3.key] = true, e3 = this.getTile(o3), !e3 && n3 && (e3 = this._addTile(o3)), e3 && (t2[o3.key] = o3, n3 = e3.wasRequested(), e3.hasData()))
                break;
            }
          }
          return t2;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const e2 in this._tiles) {
            const t2 = [];
            let i2, r2 = this._tiles[e2].tileID;
            for (; r2.overscaledZ > 0; ) {
              if (r2.key in this._loadedParentTiles) {
                i2 = this._loadedParentTiles[r2.key];
                break;
              }
              t2.push(r2.key);
              const e3 = r2.scaledTo(r2.overscaledZ - 1);
              if (i2 = this._getLoadedTile(e3), i2)
                break;
              r2 = e3;
            }
            for (const e3 of t2)
              this._loadedParentTiles[e3] = i2;
          }
        }
        _addTile(e2) {
          let t2 = this._tiles[e2.key];
          if (t2)
            return t2;
          t2 = this._cache.getAndRemove(e2), t2 && (this._setTileReloadTimer(e2.key, t2), t2.tileID = e2, this._state.initializeTileState(t2, this.map ? this.map.painter : null), this._cacheTimers[e2.key] && (clearTimeout(this._cacheTimers[e2.key]), delete this._cacheTimers[e2.key], this._setTileReloadTimer(e2.key, t2)));
          const i2 = Boolean(t2);
          if (!i2) {
            const i3 = this.map ? this.map.painter : null;
            t2 = new Tile(e2, this._source.tileSize * e2.overscaleFactor(), this.transform.tileZoom, i3, this._isRaster), this._loadTile(t2, this._tileLoaded.bind(this, t2, e2.key, t2.state));
          }
          return t2 ? (t2.uses++, this._tiles[e2.key] = t2, i2 || this._source.fire(new Event("dataloading", { tile: t2, coord: t2.tileID, dataType: "source" })), t2) : null;
        }
        _setTileReloadTimer(e2, t2) {
          e2 in this._timers && (clearTimeout(this._timers[e2]), delete this._timers[e2]);
          const i2 = t2.getExpiryTimeout();
          i2 && (this._timers[e2] = setTimeout(() => {
            this._reloadTile(e2, "expired"), delete this._timers[e2];
          }, i2));
        }
        _removeTile(e2) {
          const t2 = this._tiles[e2];
          t2 && (t2.uses--, delete this._tiles[e2], this._timers[e2] && (clearTimeout(this._timers[e2]), delete this._timers[e2]), t2.uses > 0 || (t2.hasData() && "reloading" !== t2.state ? this._cache.add(t2.tileID, t2, t2.getExpiryTimeout()) : (t2.aborted = true, this._abortTile(t2), this._unloadTile(t2))));
        }
        clearTiles() {
          this._shouldReloadOnResume = false, this._paused = false;
          for (const e2 in this._tiles)
            this._removeTile(+e2);
          this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
        }
        tilesIn(e2, t2, i2) {
          const r2 = [], n2 = this.transform;
          if (!n2)
            return r2;
          const o2 = "globe" === n2.projection.name, s2 = Oo(n2.center.lng);
          for (const a2 in this._tiles) {
            const l2 = this._tiles[a2];
            if (i2 && l2.clearQueryDebugViz(), l2.holdingForFade())
              continue;
            let c2;
            if (o2) {
              const e3 = l2.tileID.canonical;
              if (0 === e3.z) {
                const t3 = [Math.abs(A(s2, ...rp(e3, -1)) - s2), Math.abs(A(s2, ...rp(e3, 1)) - s2)];
                c2 = [0, 2 * t3.indexOf(Math.min(...t3)) - 1];
              } else {
                const t3 = [Math.abs(A(s2, ...rp(e3, -1)) - s2), Math.abs(A(s2, ...rp(e3, 0)) - s2), Math.abs(A(s2, ...rp(e3, 1)) - s2)];
                c2 = [t3.indexOf(Math.min(...t3)) - 1];
              }
            } else
              c2 = [0];
            for (const i3 of c2) {
              const o3 = e2.containsTile(l2, n2, t2, i3);
              o3 && r2.push(o3);
            }
          }
          return r2;
        }
        getVisibleCoordinates(e2) {
          const t2 = this.getRenderableIds(e2).map((e3) => this._tiles[e3].tileID);
          for (const e3 of t2)
            e3.projMatrix = this.transform.calculateProjMatrix(e3.toUnwrapped());
          return t2;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return true;
          if (ip(this._source.type))
            for (const e2 in this._tiles) {
              const t2 = this._tiles[e2];
              if (void 0 !== t2.fadeEndTime && t2.fadeEndTime >= Je.now())
                return true;
            }
          return false;
        }
        setFeatureState(e2, t2, i2) {
          this._state.updateState(e2 = e2 || "_geojsonTileLayer", t2, i2);
        }
        removeFeatureState(e2, t2, i2) {
          this._state.removeFeatureState(e2 = e2 || "_geojsonTileLayer", t2, i2);
        }
        getFeatureState(e2, t2) {
          return this._state.getState(e2 = e2 || "_geojsonTileLayer", t2);
        }
        setDependencies(e2, t2, i2) {
          const r2 = this._tiles[e2];
          r2 && r2.setDependencies(t2, i2);
        }
        reloadTilesForDependencies(e2, t2) {
          for (const i2 in this._tiles)
            this._tiles[i2].hasDependency(e2, t2) && this._reloadTile(+i2, "reloading");
          this._cache.filter((i2) => !i2.hasDependency(e2, t2));
        }
        _preloadTiles(e2, t2) {
          const i2 = /* @__PURE__ */ new Map(), r2 = Array.isArray(e2) ? e2 : [e2], n2 = this.map.painter.terrain, o2 = this.usedForTerrain && n2 ? n2.getScaledDemTileSize() : this._source.tileSize;
          for (const e3 of r2) {
            const t3 = e3.coveringTiles({ tileSize: o2, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
            for (const e4 of t3)
              i2.set(e4.key, e4);
            this.usedForTerrain && e3.updateElevation(false);
          }
          M(Array.from(i2.values()), (e3, t3) => {
            const i3 = new Tile(e3, this._source.tileSize * e3.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
            this._loadTile(i3, (e4) => {
              "raster-dem" === this._source.type && i3.dem && this._backfillDEM(i3), t3(e4, i3);
            });
          }, t2);
        }
      }
      function tp(e2, t2) {
        const i2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0), r2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0);
        return e2.overscaledZ - t2.overscaledZ || r2 - i2 || t2.canonical.y - e2.canonical.y || t2.canonical.x - e2.canonical.x;
      }
      function ip(e2) {
        return "raster" === e2 || "image" === e2 || "video" === e2 || "custom" === e2;
      }
      function rp(e2, t2) {
        const i2 = 1 << e2.z;
        return [e2.x / i2 + t2, (e2.x + 1) / i2 + t2];
      }
      SourceCache.maxOverzooming = 10, SourceCache.maxUnderzooming = 3;
      class DEMSampler {
        constructor(e2, t2, i2) {
          this._demTile = e2, this._dem = this._demTile.dem, this._scale = t2, this._offset = i2;
        }
        static create(e2, t2, i2) {
          const r2 = i2 || e2.findDEMTileFor(t2);
          if (!r2 || !r2.dem)
            return;
          const n2 = r2.dem, o2 = r2.tileID, s2 = 1 << t2.canonical.z - o2.canonical.z;
          return new DEMSampler(r2, r2.tileSize / ko / s2, [(t2.canonical.x / s2 - o2.canonical.x) * n2.dim, (t2.canonical.y / s2 - o2.canonical.y) * n2.dim]);
        }
        tileCoordToPixel(e2, t2) {
          const i2 = t2 * this._scale + this._offset[1], r2 = Math.floor(e2 * this._scale + this._offset[0]), n2 = Math.floor(i2);
          return new d(r2, n2);
        }
        getElevationAt(e2, t2, i2, r2) {
          const n2 = e2 * this._scale + this._offset[0], o2 = t2 * this._scale + this._offset[1], s2 = Math.floor(n2), a2 = Math.floor(o2), l2 = this._dem;
          return r2 = !!r2, i2 ? Ii(Ii(l2.get(s2, a2, r2), l2.get(s2, a2 + 1, r2), o2 - a2), Ii(l2.get(s2 + 1, a2, r2), l2.get(s2 + 1, a2 + 1, r2), o2 - a2), n2 - s2) : l2.get(s2, a2, r2);
        }
        getElevationAtPixel(e2, t2, i2) {
          return this._dem.get(e2, t2, !!i2);
        }
        getMeterToDEM(e2) {
          return (1 << this._demTile.tileID.canonical.z) * Vo(1, e2) * this._dem.stride;
        }
      }
      function np(e2, t2, i2, r2, n2) {
        return V(e2, (e3, o2) => {
          const s2 = t2 instanceof PossiblyEvaluated ? t2.get(o2) : null;
          return s2 && s2.evaluate ? s2.evaluate(i2, r2, n2) : s2;
        });
      }
      function op(e2, t2) {
        return t2 - e2;
      }
      kn(class FeatureIndex {
        constructor(e2, t2) {
          this.tileID = e2, this.x = e2.canonical.x, this.y = e2.canonical.y, this.z = e2.canonical.z, this.grid = new Pn(ko, 16, 0), this.featureIndexArray = new FeatureIndexArray(), this.promoteId = t2;
        }
        insert(e2, t2, i2, r2, n2, o2 = 0) {
          const s2 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(i2, r2, n2, o2);
          const a2 = this.grid;
          for (let e3 = 0; e3 < t2.length; e3++) {
            const i3 = t2[e3], r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let e4 = 0; e4 < i3.length; e4++) {
              const t3 = i3[e4];
              r3[0] = Math.min(r3[0], t3.x), r3[1] = Math.min(r3[1], t3.y), r3[2] = Math.max(r3[2], t3.x), r3[3] = Math.max(r3[3], t3.y);
            }
            r3[0] < ko && r3[1] < ko && r3[2] >= 0 && r3[3] >= 0 && a2.insert(s2, r3[0], r3[1], r3[2], r3[3]);
          }
        }
        loadVTLayers() {
          if (!this.vtLayers) {
            this.vtLayers = new Pl(new Ec(this.rawTileData)).layers, this.sourceLayerCoder = new DictionaryCoder(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
            for (const e2 in this.vtLayers)
              this.vtFeatures[e2] = [];
          }
          return this.vtLayers;
        }
        query(e2, t2, i2, r2) {
          this.loadVTLayers();
          const n2 = e2.params || {}, o2 = qr(n2.filter), s2 = e2.tileResult, a2 = e2.transform, l2 = s2.bufferedTilespaceBounds, c2 = this.grid.query(l2.min.x, l2.min.y, l2.max.x, l2.max.y, (e3, t3, i3, r3) => ds(s2.bufferedTilespaceGeometry, e3, t3, i3, r3));
          c2.sort(op);
          let u2 = null;
          a2.elevation && c2.length > 0 && (u2 = DEMSampler.create(a2.elevation, this.tileID));
          const h2 = {};
          let p2;
          for (let a3 = 0; a3 < c2.length; a3++) {
            const l3 = c2[a3];
            if (l3 === p2)
              continue;
            p2 = l3;
            const d2 = this.featureIndexArray.get(l3);
            let f2 = null;
            this.loadMatchingFeature(h2, d2, o2, n2.layers, n2.availableImages, t2, i2, r2, (t3, i3, r3, n3 = 0) => (f2 || (f2 = Qo(t3, this.tileID.canonical, e2.tileTransform)), i3.queryIntersectsFeature(s2, t3, r3, f2, this.z, e2.transform, e2.pixelPosMatrix, u2, n3)));
          }
          return h2;
        }
        loadMatchingFeature(e2, t2, i2, r2, n2, o2, s2, a2, l2) {
          const { featureIndex: c2, bucketIndex: u2, sourceLayerIndex: h2, layoutVertexArrayOffset: p2 } = t2, d2 = this.bucketLayerIDs[u2];
          if (r2 && !function(e3, t3) {
            for (let i3 = 0; i3 < e3.length; i3++)
              if (t3.indexOf(e3[i3]) >= 0)
                return true;
            return false;
          }(r2, d2))
            return;
          const f2 = this.sourceLayerCoder.decode(h2), m2 = this.vtLayers[f2].feature(c2);
          if (i2.needGeometry) {
            const e3 = es(m2, true);
            if (!i2.filter(new EvaluationParameters(this.tileID.overscaledZ), e3, this.tileID.canonical))
              return;
          } else if (!i2.filter(new EvaluationParameters(this.tileID.overscaledZ), m2))
            return;
          const _2 = this.getId(m2, f2);
          for (let t3 = 0; t3 < d2.length; t3++) {
            const i3 = d2[t3];
            if (r2 && r2.indexOf(i3) < 0)
              continue;
            const u3 = o2[i3];
            if (!u3)
              continue;
            let h3 = {};
            void 0 !== _2 && a2 && (h3 = a2.getState(u3.sourceLayer || "_geojsonTileLayer", _2));
            const f3 = P({}, s2[i3]);
            f3.paint = np(f3.paint, u3.paint, m2, h3, n2), f3.layout = np(f3.layout, u3.layout, m2, h3, n2);
            const g2 = !l2 || l2(m2, u3, h3, p2);
            if (!g2)
              continue;
            const y2 = new Feature(m2, this.z, this.x, this.y, _2);
            y2.layer = f3;
            let x2 = e2[i3];
            void 0 === x2 && (x2 = e2[i3] = []), x2.push({ featureIndex: c2, feature: y2, intersectionZ: g2 });
          }
        }
        lookupSymbolFeatures(e2, t2, i2, r2, n2, o2, s2, a2) {
          const l2 = {};
          this.loadVTLayers();
          const c2 = qr(n2);
          for (const n3 of e2)
            this.loadMatchingFeature(l2, { bucketIndex: i2, sourceLayerIndex: r2, featureIndex: n3, layoutVertexArrayOffset: 0 }, c2, o2, s2, a2, t2);
          return l2;
        }
        loadFeature(e2) {
          const { featureIndex: t2, sourceLayerIndex: i2 } = e2;
          this.loadVTLayers();
          const r2 = this.sourceLayerCoder.decode(i2), n2 = this.vtFeatures[r2];
          if (n2[t2])
            return n2[t2];
          const o2 = this.vtLayers[r2].feature(t2);
          return n2[t2] = o2, o2;
        }
        hasLayer(e2) {
          for (const t2 of this.bucketLayerIDs)
            for (const i2 of t2)
              if (e2 === i2)
                return true;
          return false;
        }
        getId(e2, t2) {
          let i2 = e2.id;
          if (this.promoteId) {
            const r2 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[t2];
            null != r2 && (i2 = e2.properties[r2]), "boolean" == typeof i2 && (i2 = Number(i2));
          }
          return i2;
        }
      }, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] }), kn(class LineAtlas {
        constructor(e2, t2) {
          this.width = e2, this.height = t2, this.nextRow = 0, this.image = new AlphaImage({ width: e2, height: t2 }), this.positions = {}, this.uploaded = false;
        }
        getDash(e2, t2) {
          const i2 = this.getKey(e2, t2);
          return this.positions[i2];
        }
        trim() {
          const e2 = this.width, t2 = this.height = R(this.nextRow);
          this.image.resize({ width: e2, height: t2 });
        }
        getKey(e2, t2) {
          return e2.join(",") + t2;
        }
        getDashRanges(e2, t2, i2) {
          const r2 = [];
          let n2 = e2.length % 2 == 1 ? -e2[e2.length - 1] * i2 : 0, o2 = e2[0] * i2, s2 = true;
          r2.push({ left: n2, right: o2, isDash: s2, zeroLength: 0 === e2[0] });
          let a2 = e2[0];
          for (let t3 = 1; t3 < e2.length; t3++) {
            s2 = !s2;
            const l2 = e2[t3];
            n2 = a2 * i2, a2 += l2, o2 = a2 * i2, r2.push({ left: n2, right: o2, isDash: s2, zeroLength: 0 === l2 });
          }
          return r2;
        }
        addRoundDash(e2, t2, i2) {
          const r2 = t2 / 2;
          for (let t3 = -i2; t3 <= i2; t3++) {
            const n2 = this.width * (this.nextRow + i2 + t3);
            let o2 = 0, s2 = e2[o2];
            for (let a2 = 0; a2 < this.width; a2++) {
              a2 / s2.right > 1 && (s2 = e2[++o2]);
              const l2 = Math.abs(a2 - s2.left), c2 = Math.abs(a2 - s2.right), u2 = Math.min(l2, c2);
              let h2;
              const p2 = t3 / i2 * (r2 + 1);
              if (s2.isDash) {
                const e3 = r2 - Math.abs(p2);
                h2 = Math.sqrt(u2 * u2 + e3 * e3);
              } else
                h2 = r2 - Math.sqrt(u2 * u2 + p2 * p2);
              this.image.data[n2 + a2] = Math.max(0, Math.min(255, h2 + 128));
            }
          }
        }
        addRegularDash(e2, t2) {
          for (let t3 = e2.length - 1; t3 >= 0; --t3) {
            const i3 = e2[t3], r3 = e2[t3 + 1];
            i3.zeroLength ? e2.splice(t3, 1) : r3 && r3.isDash === i3.isDash && (r3.left = i3.left, e2.splice(t3, 1));
          }
          const i2 = e2[0], r2 = e2[e2.length - 1];
          i2.isDash === r2.isDash && (i2.left = r2.left - this.width, r2.right = i2.right + this.width);
          const n2 = this.width * this.nextRow;
          let o2 = 0, s2 = e2[o2];
          for (let i3 = 0; i3 < this.width; i3++) {
            i3 / s2.right > 1 && (s2 = e2[++o2]);
            const r3 = Math.abs(i3 - s2.left), a2 = Math.abs(i3 - s2.right), l2 = Math.min(r3, a2);
            this.image.data[n2 + i3] = Math.max(0, Math.min(255, (s2.isDash ? l2 : -l2) + t2 + 128));
          }
        }
        addDash(e2, t2) {
          const i2 = this.getKey(e2, t2);
          if (this.positions[i2])
            return this.positions[i2];
          const r2 = "round" === t2, n2 = r2 ? 7 : 0, o2 = 2 * n2 + 1;
          if (this.nextRow + o2 > this.height)
            return Z("LineAtlas out of space"), null;
          0 === e2.length && e2.push(1);
          let s2 = 0;
          for (let t3 = 0; t3 < e2.length; t3++)
            e2[t3] < 0 && (Z("Negative value is found in line dasharray, replacing values with 0"), e2[t3] = 0), s2 += e2[t3];
          if (0 !== s2) {
            const i3 = this.width / s2, o3 = this.getDashRanges(e2, this.width, i3);
            r2 ? this.addRoundDash(o3, i3, n2) : this.addRegularDash(o3, "square" === t2 ? 0.5 * i3 : 0);
          }
          const a2 = this.nextRow + n2;
          this.nextRow += o2;
          const l2 = { tl: [a2, n2], br: [s2, 0] };
          return this.positions[i2] = l2, l2;
        }
      }, "LineAtlas"), kn(class GlyphAtlas {
        constructor(e2) {
          const t2 = {}, i2 = [];
          for (const r3 in e2) {
            const n3 = e2[r3], o3 = t2[r3] = {};
            for (const e3 in n3.glyphs) {
              const t3 = n3.glyphs[+e3];
              if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height)
                continue;
              const r4 = t3.metrics.localGlyph ? 2 : 1, s2 = { x: 0, y: 0, w: t3.bitmap.width + 2 * r4, h: t3.bitmap.height + 2 * r4 };
              i2.push(s2), o3[e3] = s2;
            }
          }
          const { w: r2, h: n2 } = Hc(i2), o2 = new AlphaImage({ width: r2 || 1, height: n2 || 1 });
          for (const i3 in e2) {
            const r3 = e2[i3];
            for (const e3 in r3.glyphs) {
              const n3 = r3.glyphs[+e3];
              if (!n3 || 0 === n3.bitmap.width || 0 === n3.bitmap.height)
                continue;
              const s2 = t2[i3][e3], a2 = n3.metrics.localGlyph ? 2 : 1;
              AlphaImage.copy(n3.bitmap, o2, { x: 0, y: 0 }, { x: s2.x + a2, y: s2.y + a2 }, n3.bitmap);
            }
          }
          this.image = o2, this.positions = t2;
        }
      }, "GlyphAtlas");
      class DedupedRequest {
        constructor(e2) {
          this.entries = {}, this.scheduler = e2;
        }
        request(e2, t2, i2, r2) {
          const n2 = this.entries[e2] = this.entries[e2] || { callbacks: [] };
          if (n2.result) {
            const [e3, i3] = n2.result;
            return this.scheduler ? this.scheduler.add(() => {
              r2(e3, i3);
            }, t2) : r2(e3, i3), () => {
            };
          }
          return n2.callbacks.push(r2), n2.cancel || (n2.cancel = i2((i3, r3) => {
            n2.result = [i3, r3];
            for (const e3 of n2.callbacks)
              this.scheduler ? this.scheduler.add(() => {
                e3(i3, r3);
              }, t2) : e3(i3, r3);
            setTimeout(() => delete this.entries[e2], 3e3);
          })), () => {
            n2.result || (n2.callbacks = n2.callbacks.filter((e3) => e3 !== r2), n2.callbacks.length || (n2.cancel(), delete this.entries[e2]));
          };
        }
      }
      function sp(e2, t2, i2) {
        const r2 = JSON.stringify(e2.request);
        return e2.data && (this.deduped.entries[r2] = { result: [null, e2.data] }), this.deduped.request(r2, { type: "parseTile", isSymbolTile: e2.isSymbolTile, zoom: e2.tileZoom }, (t3) => {
          const r3 = _e(e2.request, (e3, r4, n2, o2) => {
            e3 ? t3(e3) : r4 && t3(null, { vectorTile: i2 ? void 0 : new Pl(new Ec(r4)), rawData: r4, cacheControl: n2, expires: o2 });
          });
          return () => {
            r3.cancel(), t3();
          };
        }, t2);
      }
      class RasterTileSource extends Evented {
        constructor(e2, t2, i2, r2) {
          super(), this.id = e2, this.dispatcher = i2, this.setEventedParent(r2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = P({ type: "raster" }, t2), P(this, z(t2, ["url", "scheme", "tileSize"]));
        }
        load() {
          this._loaded = false, this.fire(new Event("dataloading", { dataType: "source" })), this._tileJSONRequest = Lh(this._options, this.map._requestManager, null, null, (e2, t2) => {
            this._tileJSONRequest = null, this._loaded = true, e2 ? this.fire(new ErrorEvent(e2)) : t2 && (P(this, t2), t2.bounds && (this.tileBounds = new TileBounds(t2.bounds, this.minzoom, this.maxzoom)), Le(t2.tiles), this.fire(new Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
        serialize() {
          return P({}, this._options);
        }
        hasTile(e2) {
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        loadTile(e2, t2) {
          const i2 = Je.devicePixelRatio >= 2, r2 = this.map._requestManager.normalizeTileURL(e2.tileID.canonical.url(this.tiles, this.scheme), i2, this.tileSize);
          e2.request = be(this.map._requestManager.transformRequest(r2, pe.Tile), (i3, r3, n2, o2) => (delete e2.request, e2.aborted ? (e2.state = "unloaded", t2(null)) : i3 ? (e2.state = "errored", t2(i3)) : r3 ? (this.map._refreshExpiredTiles && e2.setExpiryData({ cacheControl: n2, expires: o2 }), e2.setTexture(r3, this.map.painter), e2.state = "loaded", he(this.dispatcher), void t2(null)) : t2(null)));
        }
        static loadTileData(e2, t2, i2) {
          e2.setTexture(t2, i2);
        }
        static unloadTileData(e2, t2) {
          e2.texture && t2.saveTileTexture(e2.texture);
        }
        abortTile(e2, t2) {
          e2.request && (e2.request.cancel(), delete e2.request), t2();
        }
        unloadTile(e2, t2) {
          e2.texture && this.map.painter.saveTileTexture(e2.texture), t2();
        }
        hasTransition() {
          return false;
        }
      }
      let ap;
      function lp(e2, t2, i2, r2, n2, o2, s2, a2) {
        const l2 = [e2, i2, n2, t2, r2, o2, 1, 1, 1], c2 = [s2, a2, 1], u2 = Ss([], l2), [h2, p2, d2] = na(c2, c2, function(e3, t3) {
          if (e3 === t3) {
            var i3 = t3[1], r3 = t3[2], n3 = t3[5];
            e3[1] = t3[3], e3[2] = t3[6], e3[3] = i3, e3[5] = t3[7], e3[6] = r3, e3[7] = n3;
          } else
            e3[0] = t3[0], e3[1] = t3[3], e3[2] = t3[6], e3[3] = t3[1], e3[4] = t3[4], e3[5] = t3[7], e3[6] = t3[2], e3[7] = t3[5], e3[8] = t3[8];
          return e3;
        }(u2, u2));
        return As(l2, [h2, 0, 0, 0, p2, 0, 0, 0, d2], l2);
      }
      class ImageSource extends Evented {
        constructor(e2, t2, i2, r2) {
          super(), this.id = e2, this.dispatcher = i2, this.coordinates = t2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(r2), this.options = t2, this._dirty = false;
        }
        load(t2, i2) {
          this._loaded = i2 || false, this.fire(new Event("dataloading", { dataType: "source" })), this.url = this.options.url, this._imageRequest = be(this.map._requestManager.transformRequest(this.url, pe.Image), (i3, r2) => {
            if (this._imageRequest = null, this._loaded = true, i3)
              this.fire(new ErrorEvent(i3));
            else if (r2) {
              const { HTMLImageElement: i4 } = e;
              this.image = r2 instanceof i4 ? Je.getImageData(r2) : r2, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t2 && (this.coordinates = t2), this._finishLoading();
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(e2) {
          return this.image && e2.url ? (this._imageRequest && e2.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e2.url, this.load(e2.coordinates, this._loaded), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new Event("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        onRemove() {
          this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();
        }
        setCoordinates(e2) {
          this.coordinates = e2, this._boundsArray = void 0;
          const t2 = e2.map(MercatorCoordinate.fromLngLat);
          return this.tileID = function(e3) {
            let t3 = 1 / 0, i2 = 1 / 0, r2 = -1 / 0, n2 = -1 / 0;
            for (const o3 of e3)
              t3 = Math.min(t3, o3.x), i2 = Math.min(i2, o3.y), r2 = Math.max(r2, o3.x), n2 = Math.max(n2, o3.y);
            const o2 = Math.max(r2 - t3, n2 - i2), s2 = Math.max(0, Math.floor(-Math.log(o2) / Math.LN2)), a2 = Math.pow(2, s2);
            return new CanonicalTileID(s2, Math.floor((t3 + r2) / 2 * a2), Math.floor((i2 + n2) / 2 * a2));
          }(t2), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new Event("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        _clear() {
          this._boundsArray = void 0;
        }
        _prepareData(e2) {
          for (const e3 in this.tiles) {
            const t3 = this.tiles[e3];
            "loaded" !== t3.state && (t3.state = "loaded", t3.texture = this.texture);
          }
          if (this._boundsArray)
            return;
          const t2 = qu(this.tileID, this.map.transform.projection), [i2, r2, n2, o2] = this.coordinates.map((e3) => {
            const i3 = t2.projection.project(e3[0], e3[1]);
            return $u(t2, i3)._round();
          });
          this.perspectiveTransform = function(e3, t3, i3, r3, n3, o3, s3, a2, l2, c2) {
            const u2 = lp(0, 0, e3, 0, 0, t3, e3, t3), h2 = lp(i3, r3, n3, o3, s3, a2, l2, c2);
            return As(h2, Ss(u2, u2), h2), [h2[6] / h2[8] * e3 / ko, h2[7] / h2[8] * t3 / ko];
          }(this.width, this.height, i2.x, i2.y, r2.x, r2.y, o2.x, o2.y, n2.x, n2.y);
          const s2 = this._boundsArray = new StructArrayLayout4i8();
          s2.emplaceBack(i2.x, i2.y, 0, 0), s2.emplaceBack(r2.x, r2.y, ko, 0), s2.emplaceBack(o2.x, o2.y, 0, ko), s2.emplaceBack(n2.x, n2.y, ko, ko), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = e2.createVertexBuffer(s2, Nh.members), this.boundsSegments = SegmentVector.simpleSegment(0, 0, 4, 2);
        }
        prepare() {
          if (0 === Object.keys(this.tiles).length || !this.image)
            return;
          const e2 = this.map.painter.context, t2 = e2.gl;
          this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new Texture(e2, this.image, t2.RGBA), this.texture.bind(t2.LINEAR, t2.CLAMP_TO_EDGE)), this._dirty = false), this._prepareData(e2);
        }
        loadTile(e2, t2) {
          this.tileID && this.tileID.equals(e2.tileID.canonical) ? (this.tiles[String(e2.tileID.wrap)] = e2, e2.buckets = {}, t2(null)) : (e2.state = "errored", t2(null));
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return false;
        }
      }
      const cp = { vector: class VectorTileSource extends Evented {
        constructor(e2, t2, i2, r2) {
          if (super(), this.id = e2, this.dispatcher = i2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, P(this, z(t2, ["url", "scheme", "tileSize", "promoteId"])), this._options = P({ type: "vector" }, t2), this._collectResourceTiming = t2.collectResourceTiming, 512 !== this.tileSize)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(r2), this._tileWorkers = {}, this._deduped = new DedupedRequest();
        }
        load(e2) {
          this._loaded = false, this.fire(new Event("dataloading", { dataType: "source" }));
          const t2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, i2 = this.map._worldview;
          this._tileJSONRequest = Lh(this._options, this.map._requestManager, t2, i2, (r2, n2) => {
            this._tileJSONRequest = null, this._loaded = true, r2 ? (t2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${t2}`), i2 && 2 !== i2.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${i2}`), this.fire(new ErrorEvent(r2))) : n2 && (P(this, n2), n2.bounds && (this.tileBounds = new TileBounds(n2.bounds, this.minzoom, this.maxzoom)), Le(n2.tiles, this.map._requestManager._customAccessToken), this.fire(new Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new Event("data", { dataType: "source", sourceDataType: "content" }))), e2 && e2(r2);
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e2) {
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        reload() {
          this.cancelTileJSONRequest(), this.load(() => {
            const e2 = this.map.style._getSourceCaches(this.id);
            for (const t2 of e2)
              t2.clearTiles();
          });
        }
        setSourceProperty(e2) {
          e2(), this.reload();
        }
        setTiles(e2) {
          return this._options.tiles = e2, this.reload(), this;
        }
        setUrl(e2) {
          return this.url = e2, this._options.url = e2, this.reload(), this;
        }
        onRemove() {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return P({}, this._options);
        }
        loadTile(e2, t2) {
          const i2 = this.map._requestManager.normalizeTileURL(e2.tileID.canonical.url(this.tiles, this.scheme)), r2 = { request: this.map._requestManager.transformRequest(i2, pe.Tile), data: void 0, uid: e2.uid, tileID: e2.tileID, tileZoom: e2.tileZoom, zoom: e2.tileID.overscaledZ, tileSize: this.tileSize * e2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: Je.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: e2.isSymbolTile };
          if (r2.request.collectResourceTiming = this._collectResourceTiming, e2.actor && "expired" !== e2.state)
            "loading" === e2.state ? e2.reloadCallback = t2 : e2.request = e2.actor.send("reloadTile", r2, n2.bind(this));
          else if (e2.actor = this._tileWorkers[i2] = this._tileWorkers[i2] || this.dispatcher.getActor(), this.dispatcher.ready)
            e2.request = e2.actor.send("loadTile", r2, n2.bind(this), void 0, true);
          else {
            const t3 = sp.call({ deduped: this._deduped }, r2, (t4, i3) => {
              t4 || !i3 ? n2.call(this, t4) : (r2.data = { cacheControl: i3.cacheControl, expires: i3.expires, rawData: i3.rawData.slice(0) }, e2.actor && e2.actor.send("loadTile", r2, n2.bind(this), void 0, true));
            }, true);
            e2.request = { cancel: t3 };
          }
          function n2(i3, r3) {
            return delete e2.request, e2.aborted ? t2(null) : i3 && 404 !== i3.status ? t2(i3) : (r3 && r3.resourceTiming && (e2.resourceTiming = r3.resourceTiming), this.map._refreshExpiredTiles && r3 && e2.setExpiryData(r3), e2.loadVectorData(r3, this.map.painter), he(this.dispatcher), t2(null), void (e2.reloadCallback && (this.loadTile(e2, e2.reloadCallback), e2.reloadCallback = null)));
          }
        }
        abortTile(e2) {
          e2.request && (e2.request.cancel(), delete e2.request), e2.actor && e2.actor.send("abortTile", { uid: e2.uid, type: this.type, source: this.id });
        }
        unloadTile(e2) {
          e2.unloadVectorData(), e2.actor && e2.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
        }
        hasTransition() {
          return false;
        }
        afterUpdate() {
          this._tileWorkers = {};
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }, raster: RasterTileSource, "raster-dem": class RasterDEMTileSource extends RasterTileSource {
        constructor(e2, t2, i2, r2) {
          super(e2, t2, i2, r2), this.type = "raster-dem", this.maxzoom = 22, this._options = P({ type: "raster-dem" }, t2), this.encoding = t2.encoding || "mapbox";
        }
        loadTile(t2, i2) {
          const r2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
          function n2(e2, r3) {
            e2 && (t2.state = "errored", i2(e2)), r3 && (t2.dem = r3, t2.dem.onDeserialize(), t2.needsHillshadePrepare = true, t2.needsDEMTextureUpload = true, t2.state = "loaded", i2(null));
          }
          t2.request = be(this.map._requestManager.transformRequest(r2, pe.Tile), function(r3, o2, s2, a2) {
            if (delete t2.request, t2.aborted)
              t2.state = "unloaded", i2(null);
            else if (r3)
              t2.state = "errored", i2(r3);
            else if (o2) {
              this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: s2, expires: a2 });
              const i3 = e.ImageBitmap && o2 instanceof e.ImageBitmap && (null == ap && (ap = e.OffscreenCanvas && new e.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e.createImageBitmap), ap), r4 = 1 - (o2.width - ((l2 = o2.width) <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(l2) / Math.LN2)))) / 2;
              r4 < 1 || t2.neighboringTiles || (t2.neighboringTiles = this._getNeighboringTiles(t2.tileID));
              const c2 = i3 ? o2 : Je.getImageData(o2, r4), u2 = { uid: t2.uid, coord: t2.tileID, source: this.id, rawImageData: c2, encoding: this.encoding, padding: r4 };
              t2.actor && "expired" !== t2.state || (t2.actor = this.dispatcher.getActor(), t2.actor.send("loadDEMTile", u2, n2.bind(this), void 0, true));
            }
            var l2;
          }.bind(this));
        }
        _getNeighboringTiles(e2) {
          const t2 = e2.canonical, i2 = Math.pow(2, t2.z), r2 = (t2.x - 1 + i2) % i2, n2 = 0 === t2.x ? e2.wrap - 1 : e2.wrap, o2 = (t2.x + 1 + i2) % i2, s2 = t2.x + 1 === i2 ? e2.wrap + 1 : e2.wrap, a2 = {};
          return a2[new OverscaledTileID(e2.overscaledZ, n2, t2.z, r2, t2.y).key] = { backfilled: false }, a2[new OverscaledTileID(e2.overscaledZ, s2, t2.z, o2, t2.y).key] = { backfilled: false }, t2.y > 0 && (a2[new OverscaledTileID(e2.overscaledZ, n2, t2.z, r2, t2.y - 1).key] = { backfilled: false }, a2[new OverscaledTileID(e2.overscaledZ, e2.wrap, t2.z, t2.x, t2.y - 1).key] = { backfilled: false }, a2[new OverscaledTileID(e2.overscaledZ, s2, t2.z, o2, t2.y - 1).key] = { backfilled: false }), t2.y + 1 < i2 && (a2[new OverscaledTileID(e2.overscaledZ, n2, t2.z, r2, t2.y + 1).key] = { backfilled: false }, a2[new OverscaledTileID(e2.overscaledZ, e2.wrap, t2.z, t2.x, t2.y + 1).key] = { backfilled: false }, a2[new OverscaledTileID(e2.overscaledZ, s2, t2.z, o2, t2.y + 1).key] = { backfilled: false }), a2;
        }
        unloadTile(e2) {
          e2.demTexture && this.map.painter.saveTileTexture(e2.demTexture), e2.fbo && (e2.fbo.destroy(), delete e2.fbo), e2.dem && delete e2.dem, delete e2.neighboringTiles, e2.state = "unloaded";
        }
      }, geojson: class GeoJSONSource extends Evented {
        constructor(e2, t2, i2, r2) {
          super(), this.id = e2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = i2.getActor(), this.setEventedParent(r2), this._data = t2.data, this._options = P({}, t2), this._collectResourceTiming = t2.collectResourceTiming, void 0 !== t2.maxzoom && (this.maxzoom = t2.maxzoom), t2.type && (this.type = t2.type), t2.attribution && (this.attribution = t2.attribution), this.promoteId = t2.promoteId;
          const n2 = ko / this.tileSize;
          this.workerOptions = P({ source: this.id, cluster: t2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== t2.buffer ? t2.buffer : 128) * n2, tolerance: (void 0 !== t2.tolerance ? t2.tolerance : 0.375) * n2, extent: ko, maxZoom: this.maxzoom, lineMetrics: t2.lineMetrics || false, generateId: t2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== t2.clusterMaxZoom ? t2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, t2.clusterMinPoints || 2), extent: ko, radius: (void 0 !== t2.clusterRadius ? t2.clusterRadius : 50) * n2, log: false, generateId: t2.generateId || false }, clusterProperties: t2.clusterProperties, filter: t2.filter }, t2.workerOptions);
        }
        onAdd(e2) {
          this.map = e2, this.setData(this._data);
        }
        setData(e2) {
          return this._data = e2, this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(e2, t2) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e2, source: this.id }, t2), this;
        }
        getClusterChildren(e2, t2) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: e2, source: this.id }, t2), this;
        }
        getClusterLeaves(e2, t2, i2, r2) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: e2, limit: t2, offset: i2 }, r2), this;
        }
        _updateWorkerData() {
          if (this._pendingLoad)
            return void (this._coalesce = true);
          this.fire(new Event("dataloading", { dataType: "source" })), this._loaded = false;
          const e2 = P({}, this.workerOptions), t2 = this._data;
          "string" == typeof t2 ? (e2.request = this.map._requestManager.transformRequest(Je.resolveURL(t2), pe.Source), e2.request.collectResourceTiming = this._collectResourceTiming) : e2.data = JSON.stringify(t2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, e2, (e3, t3) => {
            if (this._loaded = true, this._pendingLoad = null, e3)
              this.fire(new ErrorEvent(e3));
            else {
              const e4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
              this._collectResourceTiming && t3 && t3.resourceTiming && t3.resourceTiming[this.id] && (e4.resourceTiming = t3.resourceTiming[this.id]), this.fire(new Event("data", e4)), this._metadataFired = true;
            }
            this._coalesce && (this._updateWorkerData(), this._coalesce = false);
          });
        }
        loaded() {
          return this._loaded;
        }
        loadTile(e2, t2) {
          const i2 = e2.actor ? "reloadTile" : "loadTile";
          e2.actor = this.actor, e2.request = this.actor.send(i2, { type: this.type, uid: e2.uid, tileID: e2.tileID, tileZoom: e2.tileZoom, zoom: e2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: Je.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (r2, n2) => (delete e2.request, e2.unloadVectorData(), e2.aborted ? t2(null) : r2 ? t2(r2) : (e2.loadVectorData(n2, this.map.painter, "reloadTile" === i2), t2(null))), void 0, "loadTile" === i2);
        }
        abortTile(e2) {
          e2.request && (e2.request.cancel(), delete e2.request), e2.aborted = true;
        }
        unloadTile(e2) {
          e2.unloadVectorData(), this.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
        }
        onRemove() {
          this._pendingLoad && this._pendingLoad.cancel();
        }
        serialize() {
          return P({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return false;
        }
      }, video: class VideoSource extends ImageSource {
        constructor(e2, t2, i2, r2) {
          super(e2, t2, i2, r2), this.roundZoom = true, this.type = "video", this.options = t2;
        }
        load() {
          this._loaded = false;
          const t2 = this.options;
          this.urls = [];
          for (const e2 of t2.urls)
            this.urls.push(this.map._requestManager.transformRequest(e2, pe.Source).url);
          !function(t3, i2) {
            const r2 = e.document.createElement("video");
            r2.muted = true, r2.onloadstart = function() {
              i2(null, r2);
            };
            for (let i3 = 0; i3 < t3.length; i3++) {
              const n2 = e.document.createElement("source");
              ge(t3[i3]) || (r2.crossOrigin = "Anonymous"), n2.src = t3[i3], r2.appendChild(n2);
            }
          }(this.urls, (e2, t3) => {
            this._loaded = true, e2 ? this.fire(new ErrorEvent(e2)) : t3 && (this.video = t3, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(e2) {
          if (this.video) {
            const t2 = this.video.seekable;
            e2 < t2.start(0) || e2 > t2.end(0) ? this.fire(new ErrorEvent(new ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${t2.start(0)} and ${t2.end(0)}-second mark.`))) : this.video.currentTime = e2;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e2) {
          this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
            return;
          const e2 = this.map.painter.context, t2 = e2.gl;
          this.texture ? this.video.paused || (this.texture.bind(t2.LINEAR, t2.CLAMP_TO_EDGE), t2.texSubImage2D(t2.TEXTURE_2D, 0, 0, 0, t2.RGBA, t2.UNSIGNED_BYTE, this.video)) : (this.texture = new Texture(e2, this.video, t2.RGBA), this.texture.bind(t2.LINEAR, t2.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(e2);
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }, image: ImageSource, canvas: class CanvasSource extends ImageSource {
        constructor(t2, i2, r2, n2) {
          super(t2, i2, r2, n2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((e2) => !Array.isArray(e2) || 2 !== e2.length || e2.some((e3) => "number" != typeof e3)) || this.fire(new ErrorEvent(new ValidationError(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new ErrorEvent(new ValidationError(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new ErrorEvent(new ValidationError(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof e.HTMLCanvasElement || this.fire(new ErrorEvent(new ValidationError(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new ErrorEvent(new ValidationError(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
        }
        load() {
          this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof e.HTMLCanvasElement ? this.options.canvas : e.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = true, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = false);
          }, this._finishLoading());
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e2) {
          this.map = e2, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let e2 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, e2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e2 = true), this._hasInvalidDimensions())
            return;
          if (0 === Object.keys(this.tiles).length)
            return;
          const t2 = this.map.painter.context;
          this.texture ? (e2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new Texture(t2, this.canvas, t2.gl.RGBA, { premultiply: true }), this._prepareData(t2);
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const e2 of [this.canvas.width, this.canvas.height])
            if (isNaN(e2) || e2 <= 0)
              return true;
          return false;
        }
      }, custom: class CustomSource extends Evented {
        constructor(e2, t2, i2, r2) {
          super(), this.id = e2, this.type = "custom", this._dataType = "raster", this._dispatcher = i2, this._implementation = t2, this.setEventedParent(r2), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new TileBounds(this._implementation.bounds, this.minzoom, this.maxzoom)), t2.update = this._update.bind(this), t2.clearTiles = this._clearTiles.bind(this), t2.coveringTiles = this._coveringTiles.bind(this), P(this, z(t2, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
        }
        serialize() {
          return z(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
        }
        load() {
          this._loaded = true, this.fire(new Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new Event("data", { dataType: "source", sourceDataType: "content" }));
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e2) {
          this._map = e2, this._loaded = false, this.fire(new Event("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(e2), this.load();
        }
        onRemove(e2) {
          this._implementation.onRemove && this._implementation.onRemove(e2);
        }
        hasTile(e2) {
          if (this._implementation.hasTile) {
            const { x: t2, y: i2, z: r2 } = e2.canonical;
            return this._implementation.hasTile({ x: t2, y: i2, z: r2 });
          }
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        loadTile(t2, i2) {
          const { x: r2, y: n2, z: o2 } = t2.tileID.canonical, s2 = new e.AbortController();
          t2.request = Promise.resolve(this._implementation.loadTile({ x: r2, y: n2, z: o2 }, { signal: s2.signal })).then(function(r3) {
            return delete t2.request, t2.aborted ? (t2.state = "unloaded", i2(null)) : void 0 === r3 ? (t2.state = "errored", i2(null)) : null === r3 ? (this.loadTileData(t2, { width: this.tileSize, height: this.tileSize, data: null }), t2.state = "loaded", i2(null)) : function(t3) {
              return t3 instanceof e.ImageData || t3 instanceof e.HTMLCanvasElement || t3 instanceof e.ImageBitmap || t3 instanceof e.HTMLImageElement;
            }(r3) ? (this.loadTileData(t2, r3), t2.state = "loaded", void i2(null)) : (t2.state = "errored", i2(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
          }.bind(this)).catch((e2) => {
            20 !== e2.code && (t2.state = "errored", i2(e2));
          }), t2.request.cancel = () => s2.abort();
        }
        loadTileData(e2, t2) {
          RasterTileSource.loadTileData(e2, t2, this._map.painter);
        }
        unloadTileData(e2) {
          RasterTileSource.unloadTileData(e2, this._map.painter);
        }
        unloadTile(e2, t2) {
          if (this.unloadTileData(e2), this._implementation.unloadTile) {
            const { x: t3, y: i2, z: r2 } = e2.tileID.canonical;
            this._implementation.unloadTile({ x: t3, y: i2, z: r2 });
          }
          t2();
        }
        abortTile(e2, t2) {
          e2.request && e2.request.cancel && (e2.request.cancel(), delete e2.request), t2();
        }
        hasTransition() {
          return false;
        }
        _coveringTiles() {
          return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e2) => ({ x: e2.canonical.x, y: e2.canonical.y, z: e2.canonical.z }));
        }
        _clearTiles() {
          this._map.style._clearSource(this.id);
        }
        _update() {
          this.fire(new Event("data", { dataType: "source", sourceDataType: "content" }));
        }
      } }, up = function(e2, t2, i2, r2) {
        const n2 = new cp[t2.type](e2, t2, i2, r2);
        if (n2.id !== e2)
          throw new Error(`Expected Source id to be ${e2} instead of ${n2.id}`);
        return O(["load", "abort", "unload", "serialize", "prepare"], n2), n2;
      };
      function hp(e2, t2) {
        const i2 = Is([]);
        return zs(i2, i2, [0.5 * e2.width, 0.5 * -e2.height, 1]), Ps(i2, i2, [1, -1, 0]), Ds(i2, i2, e2.calculateProjMatrix(t2.toUnwrapped())), Float32Array.from(i2);
      }
      function pp(e2, t2, i2, r2, n2, o2, s2, a2 = false) {
        const l2 = e2.tilesIn(r2, s2, a2);
        l2.sort(fp);
        const c2 = [];
        for (const r3 of l2)
          c2.push({ wrappedTileID: r3.tile.tileID.wrapped().key, queryResults: r3.tile.queryRenderedFeatures(t2, i2, e2._state, r3, n2, o2, hp(e2.transform, r3.tile.tileID), a2) });
        const u2 = function(e3) {
          const t3 = {}, i3 = {};
          for (const r3 of e3) {
            const e4 = r3.queryResults, n3 = r3.wrappedTileID, o3 = i3[n3] = i3[n3] || {};
            for (const i4 in e4) {
              const r4 = e4[i4], n4 = o3[i4] = o3[i4] || {}, s3 = t3[i4] = t3[i4] || [];
              for (const e5 of r4)
                n4[e5.featureIndex] || (n4[e5.featureIndex] = true, s3.push(e5));
            }
          }
          return t3;
        }(c2);
        for (const t3 in u2)
          u2[t3].forEach((t4) => {
            const i3 = t4.feature, r3 = i3.layer;
            r3 && "background" !== r3.type && "sky" !== r3.type && (i3.source = r3.source, r3["source-layer"] && (i3.sourceLayer = r3["source-layer"]), i3.state = void 0 !== i3.id ? e2.getFeatureState(r3["source-layer"], i3.id) : {});
          });
        return u2;
      }
      function dp(e2, t2) {
        const i2 = e2.getRenderableIds().map((t3) => e2.getTileByID(t3)), r2 = [], n2 = {};
        for (let e3 = 0; e3 < i2.length; e3++) {
          const o2 = i2[e3], s2 = o2.tileID.canonical.key;
          n2[s2] || (n2[s2] = true, o2.querySourceFeatures(r2, t2));
        }
        return r2;
      }
      function fp(e2, t2) {
        const i2 = e2.tileID, r2 = t2.tileID;
        return i2.overscaledZ - r2.overscaledZ || i2.canonical.y - r2.canonical.y || i2.wrap - r2.wrap || i2.canonical.x - r2.canonical.x;
      }
      function mp() {
        return null != Dm.workerClass ? new Dm.workerClass() : new e.Worker(Dm.workerUrl);
      }
      const _p = "mapboxgl_preloaded_worker_pool";
      class WorkerPool {
        constructor() {
          this.active = {};
        }
        acquire(e2) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < WorkerPool.workerCount; )
              this.workers.push(new mp());
          return this.active[e2] = true, this.workers.slice();
        }
        release(e2) {
          delete this.active[e2], 0 === this.numActive() && (this.workers.forEach((e3) => {
            e3.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[_p];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      let gp;
      function yp() {
        return gp || (gp = new WorkerPool()), gp;
      }
      WorkerPool.workerCount = 2;
      var xp = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function vp(e2, t2) {
        const i2 = {};
        for (const t3 in e2)
          "ref" !== t3 && (i2[t3] = e2[t3]);
        return xp.forEach((e3) => {
          e3 in t2 && (i2[e3] = t2[e3]);
        }), i2;
      }
      function bp(e2) {
        e2 = e2.slice();
        const t2 = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < e2.length; i2++)
          t2[e2[i2].id] = e2[i2];
        for (let i2 = 0; i2 < e2.length; i2++)
          "ref" in e2[i2] && (e2[i2] = vp(e2[i2], t2[e2[i2].ref]));
        return e2;
      }
      const wp = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setProjection: "setProjection" };
      function Tp(e2, t2, i2) {
        i2.push({ command: wp.addSource, args: [e2, t2[e2]] });
      }
      function Ep(e2, t2, i2) {
        t2.push({ command: wp.removeSource, args: [e2] }), i2[e2] = true;
      }
      function Sp(e2, t2, i2, r2) {
        Ep(e2, i2, r2), Tp(e2, t2, i2);
      }
      function Ap(e2, t2, i2) {
        let r2;
        for (r2 in e2[i2])
          if (e2[i2].hasOwnProperty(r2) && "data" !== r2 && !m(e2[i2][r2], t2[i2][r2]))
            return false;
        for (r2 in t2[i2])
          if (t2[i2].hasOwnProperty(r2) && "data" !== r2 && !m(e2[i2][r2], t2[i2][r2]))
            return false;
        return true;
      }
      function Cp(e2, t2, i2, r2, n2, o2) {
        let s2;
        for (s2 in t2 = t2 || {}, e2 = e2 || {})
          e2.hasOwnProperty(s2) && (m(e2[s2], t2[s2]) || i2.push({ command: o2, args: [r2, s2, t2[s2], n2] }));
        for (s2 in t2)
          t2.hasOwnProperty(s2) && !e2.hasOwnProperty(s2) && (m(e2[s2], t2[s2]) || i2.push({ command: o2, args: [r2, s2, t2[s2], n2] }));
      }
      function Ip(e2) {
        return e2.id;
      }
      function Mp(e2, t2) {
        return e2[t2.id] = t2, e2;
      }
      class PathInterpolator {
        constructor(e2, t2) {
          this.reset(e2, t2);
        }
        reset(e2, t2) {
          this.points = e2 || [], this._distances = [0];
          for (let e3 = 1; e3 < this.points.length; e3++)
            this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(e2) {
          if (1 === this.points.length)
            return this.points[0];
          e2 = A(e2, 0, 1);
          let t2 = 1, i2 = this._distances[t2];
          const r2 = e2 * this.paddedLength + this.padding;
          for (; i2 < r2 && t2 < this._distances.length; )
            i2 = this._distances[++t2];
          const n2 = t2 - 1, o2 = this._distances[n2], s2 = i2 - o2, a2 = s2 > 0 ? (r2 - o2) / s2 : 0;
          return this.points[n2].mult(1 - a2).add(this.points[t2].mult(a2));
        }
      }
      class GridIndex {
        constructor(e2, t2, i2) {
          const r2 = this.boxCells = [], n2 = this.circleCells = [];
          this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
          for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++)
            r2.push([]), n2.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e2, t2, i2, r2, n2) {
          this._forEachCell(t2, i2, r2, n2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(r2), this.bboxes.push(n2);
        }
        insertCircle(e2, t2, i2, r2) {
          this._forEachCell(t2 - r2, i2 - r2, t2 + r2, i2 + r2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(r2);
        }
        _insertBoxCell(e2, t2, i2, r2, n2, o2) {
          this.boxCells[n2].push(o2);
        }
        _insertCircleCell(e2, t2, i2, r2, n2, o2) {
          this.circleCells[n2].push(o2);
        }
        _query(e2, t2, i2, r2, n2, o2) {
          if (i2 < 0 || e2 > this.width || r2 < 0 || t2 > this.height)
            return !n2 && [];
          const s2 = [];
          if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= r2) {
            if (n2)
              return true;
            for (let e3 = 0; e3 < this.boxKeys.length; e3++)
              s2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
            for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
              const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], r3 = this.circles[3 * e3 + 2];
              s2.push({ key: this.circleKeys[e3], x1: t3 - r3, y1: i3 - r3, x2: t3 + r3, y2: i3 + r3 });
            }
            return o2 ? s2.filter(o2) : s2;
          }
          return this._forEachCell(e2, t2, i2, r2, this._queryCell, s2, { hitTest: n2, seenUids: { box: {}, circle: {} } }, o2), n2 ? s2.length > 0 : s2;
        }
        _queryCircle(e2, t2, i2, r2, n2) {
          const o2 = e2 - i2, s2 = e2 + i2, a2 = t2 - i2, l2 = t2 + i2;
          if (s2 < 0 || o2 > this.width || l2 < 0 || a2 > this.height)
            return !r2 && [];
          const c2 = [];
          return this._forEachCell(o2, a2, s2, l2, this._queryCellCircle, c2, { hitTest: r2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, n2), r2 ? c2.length > 0 : c2;
        }
        query(e2, t2, i2, r2, n2) {
          return this._query(e2, t2, i2, r2, false, n2);
        }
        hitTest(e2, t2, i2, r2, n2) {
          return this._query(e2, t2, i2, r2, true, n2);
        }
        hitTestCircle(e2, t2, i2, r2) {
          return this._queryCircle(e2, t2, i2, true, r2);
        }
        _queryCell(e2, t2, i2, r2, n2, o2, s2, a2) {
          const l2 = s2.seenUids, c2 = this.boxCells[n2];
          if (null !== c2) {
            const n3 = this.bboxes;
            for (const u3 of c2)
              if (!l2.box[u3]) {
                l2.box[u3] = true;
                const c3 = 4 * u3;
                if (e2 <= n3[c3 + 2] && t2 <= n3[c3 + 3] && i2 >= n3[c3 + 0] && r2 >= n3[c3 + 1] && (!a2 || a2(this.boxKeys[u3]))) {
                  if (s2.hitTest)
                    return o2.push(true), true;
                  o2.push({ key: this.boxKeys[u3], x1: n3[c3], y1: n3[c3 + 1], x2: n3[c3 + 2], y2: n3[c3 + 3] });
                }
              }
          }
          const u2 = this.circleCells[n2];
          if (null !== u2) {
            const n3 = this.circles;
            for (const c3 of u2)
              if (!l2.circle[c3]) {
                l2.circle[c3] = true;
                const u3 = 3 * c3;
                if (this._circleAndRectCollide(n3[u3], n3[u3 + 1], n3[u3 + 2], e2, t2, i2, r2) && (!a2 || a2(this.circleKeys[c3]))) {
                  if (s2.hitTest)
                    return o2.push(true), true;
                  {
                    const e3 = n3[u3], t3 = n3[u3 + 1], i3 = n3[u3 + 2];
                    o2.push({ key: this.circleKeys[c3], x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 });
                  }
                }
              }
          }
        }
        _queryCellCircle(e2, t2, i2, r2, n2, o2, s2, a2) {
          const l2 = s2.circle, c2 = s2.seenUids, u2 = this.boxCells[n2];
          if (null !== u2) {
            const e3 = this.bboxes;
            for (const t3 of u2)
              if (!c2.box[t3]) {
                c2.box[t3] = true;
                const i3 = 4 * t3;
                if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!a2 || a2(this.boxKeys[t3])))
                  return o2.push(true), true;
              }
          }
          const h2 = this.circleCells[n2];
          if (null !== h2) {
            const e3 = this.circles;
            for (const t3 of h2)
              if (!c2.circle[t3]) {
                c2.circle[t3] = true;
                const i3 = 3 * t3;
                if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l2.x, l2.y, l2.radius) && (!a2 || a2(this.circleKeys[t3])))
                  return o2.push(true), true;
              }
          }
        }
        _forEachCell(e2, t2, i2, r2, n2, o2, s2, a2) {
          const l2 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t2), u2 = this._convertToXCellCoord(i2), h2 = this._convertToYCellCoord(r2);
          for (let p2 = l2; p2 <= u2; p2++)
            for (let l3 = c2; l3 <= h2; l3++)
              if (n2.call(this, e2, t2, i2, r2, this.xCellCount * l3 + p2, o2, s2, a2))
                return;
        }
        _convertToXCellCoord(e2) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
        }
        _convertToYCellCoord(e2) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
        }
        _circlesCollide(e2, t2, i2, r2, n2, o2) {
          const s2 = r2 - e2, a2 = n2 - t2, l2 = i2 + o2;
          return l2 * l2 > s2 * s2 + a2 * a2;
        }
        _circleAndRectCollide(e2, t2, i2, r2, n2, o2, s2) {
          const a2 = (o2 - r2) / 2, l2 = Math.abs(e2 - (r2 + a2));
          if (l2 > a2 + i2)
            return false;
          const c2 = (s2 - n2) / 2, u2 = Math.abs(t2 - (n2 + c2));
          if (u2 > c2 + i2)
            return false;
          if (l2 <= a2 || u2 <= c2)
            return true;
          const h2 = l2 - a2, p2 = u2 - c2;
          return h2 * h2 + p2 * p2 <= i2 * i2;
        }
      }
      const Dp = Math.tan(85 * Math.PI / 180);
      function Pp(e2, t2, i2, r2, n2, o2, s2) {
        const a2 = Cs();
        if (i2)
          if ("globe" === o2.name) {
            const e3 = function(e4, t3) {
              const { x: i3, y: r3 } = e4.point, n3 = Pu(i3, r3, e4.worldSize / e4._pixelsPerMercatorPixel, 0, 0);
              return Ds(n3, n3, Mu(_u(t3)));
            }(n2, t2);
            Ds(a2, a2, e3);
          } else {
            const e3 = Ts([], s2);
            a2[0] = e3[0], a2[1] = e3[1], a2[4] = e3[2], a2[5] = e3[3], r2 || Bs(a2, a2, n2.angle);
          }
        else
          Ds(a2, n2.labelPlaneMatrix, e2);
        return a2;
      }
      function zp(e2, t2, i2, r2, n2, o2, s2) {
        const a2 = Pp(e2, t2, i2, r2, n2, o2, s2);
        return "globe" === o2.name && i2 || (a2[2] = a2[6] = a2[10] = a2[14] = 0), a2;
      }
      function Lp(e2, t2, i2, r2, n2, o2, s2) {
        if (i2) {
          if ("globe" === o2.name) {
            const a3 = Pp(e2, t2, i2, r2, n2, o2, s2);
            return Ms(a3, a3), Ds(a3, e2, a3), a3;
          }
          {
            const t3 = (a2 = e2, (l2 = new ws(16))[0] = a2[0], l2[1] = a2[1], l2[2] = a2[2], l2[3] = a2[3], l2[4] = a2[4], l2[5] = a2[5], l2[6] = a2[6], l2[7] = a2[7], l2[8] = a2[8], l2[9] = a2[9], l2[10] = a2[10], l2[11] = a2[11], l2[12] = a2[12], l2[13] = a2[13], l2[14] = a2[14], l2[15] = a2[15], l2), i3 = Is([]);
            return i3[0] = s2[0], i3[1] = s2[1], i3[4] = s2[2], i3[5] = s2[3], Ds(t3, t3, i3), r2 || Bs(t3, t3, -n2.angle), t3;
          }
        }
        return n2.glCoordMatrix;
        var a2, l2;
      }
      function kp(e2, t2, i2, r2) {
        const n2 = [e2, t2, i2, 1];
        i2 ? da(n2, n2, r2) : Zp(n2, n2, r2);
        const o2 = n2[3];
        return n2[0] /= o2, n2[1] /= o2, n2[2] /= o2, n2;
      }
      function Bp(e2, t2) {
        return Math.min(0.5 + e2 / t2 * 0.5, 1.5);
      }
      function Rp(e2, t2) {
        const i2 = e2[0] / e2[3], r2 = e2[1] / e2[3];
        return i2 >= -t2[0] && i2 <= t2[0] && r2 >= -t2[1] && r2 <= t2[1];
      }
      function Fp(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2) {
        const u2 = i2.transform, h2 = r2 ? e2.textSizeData : e2.iconSizeData, p2 = xc(h2, i2.transform.zoom), f2 = "globe" === u2.projection.name, m2 = [256 / i2.width * 2 + 1, 256 / i2.height * 2 + 1], _2 = r2 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
        _2.clear();
        let g2 = null;
        f2 && (g2 = r2 ? e2.text.globeExtVertexArray : e2.icon.globeExtVertexArray);
        const y2 = e2.lineVertexArray, x2 = r2 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, v2 = i2.transform.width / i2.transform.height;
        let b2, w2 = false;
        for (let r3 = 0; r3 < x2.length; r3++) {
          const f3 = x2.get(r3), { numGlyphs: T2, writingMode: E2 } = f3;
          if (E2 !== Xc.vertical || w2 || b2 === Xc.horizontal || (w2 = true), b2 = E2, (f3.hidden || E2 === Xc.vertical) && !w2) {
            qp(T2, _2);
            continue;
          }
          w2 = false;
          const S2 = new d(f3.tileAnchorX, f3.tileAnchorY);
          let { x: A2, y: C2, z: I2 } = u2.projection.projectTilePoint(S2.x, S2.y, c2.canonical);
          if (l2) {
            const [e3, t3, i3] = l2(S2);
            A2 += e3, C2 += t3, I2 += i3;
          }
          const M2 = [A2, C2, I2, 1];
          if (da(M2, M2, t2), !Rp(M2, m2)) {
            qp(T2, _2);
            continue;
          }
          const D2 = Bp(i2.transform.cameraToCenterDistance, M2[3]), P2 = yc(h2, p2, f3), z2 = s2 ? P2 / D2 : P2 * D2, L2 = kp(A2, C2, I2, n2);
          if (L2[3] <= 0) {
            qp(T2, _2);
            continue;
          }
          let k2 = {};
          const B2 = s2 ? null : l2, R2 = Vp(f3, z2, false, a2, t2, n2, o2, e2.glyphOffsetArray, y2, _2, g2, L2, S2, k2, v2, B2, u2.projection, c2, s2);
          w2 = R2.useVertical, B2 && R2.needsFlipping && (k2 = {}), (R2.notEnoughRoom || w2 || R2.needsFlipping && Vp(f3, z2, true, a2, t2, n2, o2, e2.glyphOffsetArray, y2, _2, g2, L2, S2, k2, v2, B2, u2.projection, c2, s2).notEnoughRoom) && qp(T2, _2);
        }
        r2 ? (e2.text.dynamicLayoutVertexBuffer.updateData(_2), g2 && e2.text.globeExtVertexBuffer.updateData(g2)) : (e2.icon.dynamicLayoutVertexBuffer.updateData(_2), g2 && e2.icon.globeExtVertexBuffer.updateData(g2));
      }
      function Op(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2, m2) {
        const { lineStartIndex: _2, glyphStartIndex: g2, segment: y2 } = a2, x2 = g2 + a2.numGlyphs, v2 = _2 + a2.lineLength, b2 = t2.getoffsetX(g2), w2 = t2.getoffsetX(x2 - 1), T2 = Gp(e2 * b2, i2, r2, n2, o2, s2, y2, _2, v2, l2, c2, u2, h2, p2, true, d2, f2, m2);
        if (!T2)
          return null;
        const E2 = Gp(e2 * w2, i2, r2, n2, o2, s2, y2, _2, v2, l2, c2, u2, h2, p2, true, d2, f2, m2);
        return E2 ? { first: T2, last: E2 } : null;
      }
      function Up(e2, t2, i2, r2) {
        return e2 === Xc.horizontal && Math.abs(r2) > Math.abs(i2) ? { useVertical: true } : e2 === Xc.vertical ? r2 > 0 ? { needsFlipping: true } : null : 0 !== t2 && function(e3, t3) {
          return 0 === e3 || Math.abs(t3 / e3) > Dp;
        }(i2, r2) ? 1 === t2 ? { needsFlipping: true } : null : i2 < 0 ? { needsFlipping: true } : null;
      }
      function Vp(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, f2, m2, _2, g2, y2, x2) {
        const v2 = t2 / 24, b2 = e2.lineOffsetX * v2, w2 = e2.lineOffsetY * v2, { lineStartIndex: T2, glyphStartIndex: E2, numGlyphs: S2, segment: A2, writingMode: C2, flipState: I2 } = e2, M2 = T2 + e2.lineLength, D2 = (e3) => {
          if (u2) {
            const [t4, i4, r4] = e3.up, n3 = c2.length;
            ch(u2, n3 + 0, t4, i4, r4), ch(u2, n3 + 1, t4, i4, r4), ch(u2, n3 + 2, t4, i4, r4), ch(u2, n3 + 3, t4, i4, r4);
          }
          const [t3, i3, r3] = e3.point;
          uh(c2, t3, i3, r3, e3.angle);
        };
        if (S2 > 1) {
          const t3 = Op(v2, a2, b2, w2, i2, h2, p2, e2, l2, o2, f2, _2, false, g2, y2, x2);
          if (!t3)
            return { notEnoughRoom: true };
          if (r2 && !i2) {
            let [i3, r3, n3] = t3.first.point, [o3, a3, l3] = t3.last.point;
            [i3, r3] = kp(i3, r3, n3, s2), [o3, a3] = kp(o3, a3, l3, s2);
            const c3 = Up(C2, I2, (o3 - i3) * m2, a3 - r3);
            if (e2.flipState = c3 && c3.needsFlipping ? 1 : 2, c3)
              return c3;
          }
          D2(t3.first);
          for (let e3 = E2 + 1; e3 < E2 + S2 - 1; e3++) {
            const t4 = Gp(v2 * a2.getoffsetX(e3), b2, w2, i2, h2, p2, A2, T2, M2, l2, o2, f2, _2, false, false, g2, y2, x2);
            if (!t4)
              return c2.length -= 4 * (e3 - E2), { notEnoughRoom: true };
            D2(t4);
          }
          D2(t3.last);
        } else {
          if (r2 && !i2) {
            const t4 = kp(p2.x, p2.y, 0, n2), i3 = T2 + A2 + 1, r3 = new d(l2.getx(i3), l2.gety(i3)), o3 = kp(r3.x, r3.y, 0, n2), s3 = o3[3] > 0 ? o3 : Np(p2, r3, t4, 1, n2, void 0, g2, y2.canonical), a3 = Up(C2, I2, (s3[0] - t4[0]) * m2, s3[1] - t4[1]);
            if (e2.flipState = a3 && a3.needsFlipping ? 1 : 2, a3)
              return a3;
          }
          const t3 = Gp(v2 * a2.getoffsetX(E2), b2, w2, i2, h2, p2, A2, T2, M2, l2, o2, f2, _2, false, false, g2, y2, x2);
          if (!t3)
            return { notEnoughRoom: true };
          D2(t3);
        }
        return {};
      }
      function jp(e2, t2, i2, r2, n2) {
        const { x: o2, y: s2, z: a2 } = r2.projectTilePoint(e2.x, e2.y, t2);
        if (!n2)
          return kp(o2, s2, a2, i2);
        const [l2, c2, u2] = n2(e2);
        return kp(o2 + l2, s2 + c2, a2 + u2, i2);
      }
      function Np(e2, t2, i2, r2, n2, o2, s2, a2) {
        const l2 = jp(e2.sub(t2)._unit()._add(e2), a2, n2, s2, o2);
        return aa(l2, i2, l2), ea(l2, l2), Js(l2, i2, l2, r2);
      }
      function Gp(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, f2, m2, _2, g2, y2) {
        const x2 = r2 ? e2 - t2 : e2 + t2;
        let v2 = x2 > 0 ? 1 : -1, b2 = 0;
        r2 && (v2 *= -1, b2 = Math.PI), v2 < 0 && (b2 += Math.PI);
        let w2 = a2 + s2 + (v2 > 0 ? 0 : 1) | 0, T2 = n2, E2 = n2, S2 = 0, A2 = 0;
        const C2 = Math.abs(x2), I2 = [], M2 = [];
        let D2 = o2, P2 = D2;
        const z2 = () => Np(P2, D2, E2, C2 - S2 + 1, u2, p2, _2, g2.canonical);
        for (; S2 + A2 <= C2; ) {
          if (w2 += v2, w2 < a2 || w2 >= l2)
            return null;
          if (E2 = T2, P2 = D2, I2.push(E2), f2 && M2.push(P2), D2 = new d(c2.getx(w2), c2.gety(w2)), T2 = h2[w2], !T2) {
            const e3 = jp(D2, g2.canonical, u2, _2, p2);
            T2 = e3[3] > 0 ? h2[w2] = e3 : z2();
          }
          S2 += A2, A2 = Qs(E2, T2);
        }
        m2 && p2 && (h2[w2] && (T2 = z2(), A2 = Qs(E2, T2)), h2[w2] = T2);
        const L2 = (C2 - S2) / A2, k2 = D2.sub(P2)._mult(L2)._add(P2), B2 = aa([], T2, E2), R2 = Js([], E2, B2, L2);
        let F2 = [0, 0, 1], O2 = B2[0], U2 = B2[1];
        if (y2 && (F2 = _2.upVector(g2.canonical, k2.x, k2.y), 0 !== F2[0] || 0 !== F2[1] || 1 !== F2[2])) {
          const e3 = [F2[2], 0, -F2[0]], t3 = ia([], F2, e3);
          ea(e3, e3), ea(t3, t3), O2 = ta(B2, e3), U2 = ta(B2, t3);
        }
        if (i2) {
          const e3 = ia([], F2, B2);
          ea(e3, e3), Js(R2, R2, e3, i2 * v2);
        }
        const V2 = b2 + Math.atan2(U2, O2);
        return I2.push(R2), f2 && M2.push(k2), { point: R2, angle: V2, path: I2, tilePath: M2, up: F2 };
      }
      function qp(e2, t2) {
        const i2 = t2.length, r2 = i2 + 4 * e2;
        t2.resize(r2), t2.float32.fill(-1 / 0, 4 * i2, 4 * r2);
      }
      function Zp(e2, t2, i2) {
        const r2 = t2[0], n2 = t2[1];
        return e2[0] = i2[0] * r2 + i2[4] * n2 + i2[12], e2[1] = i2[1] * r2 + i2[5] * n2 + i2[13], e2[3] = i2[3] * r2 + i2[7] * n2 + i2[15], e2;
      }
      const $p = 100;
      class CollisionIndex {
        constructor(e2, t2, i2 = new GridIndex(e2.width + 200, e2.height + 200, 25), r2 = new GridIndex(e2.width + 200, e2.height + 200, 25)) {
          this.transform = e2, this.grid = i2, this.ignoredGrid = r2, this.pitchfactor = Math.cos(e2._pitch) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + $p, this.screenBottomBoundary = e2.height + $p, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.fogState = t2;
        }
        placeCollisionBox(e2, t2, i2, r2, n2, o2, s2, a2) {
          let l2 = i2.projectedAnchorX, c2 = i2.projectedAnchorY, u2 = i2.projectedAnchorZ;
          const h2 = i2.elevation, p2 = i2.tileID, d2 = e2.getProjection();
          if (h2 && p2) {
            const [e3, t3, r3] = d2.upVector(p2.canonical, i2.tileAnchorX, i2.tileAnchorY), n3 = d2.upVectorScale(p2.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
            l2 += e3 * h2 * n3, c2 += t3 * h2 * n3, u2 += r3 * h2 * n3;
          }
          const f2 = this.projectAndGetPerspectiveRatio(s2, l2, c2, u2, i2.tileID, "globe" === d2.name || !!h2 || this.transform.pitch > 0, d2), m2 = o2 * f2.perspectiveRatio, _2 = (i2.x1 * t2 + r2.x - i2.padding) * m2 + f2.point.x, g2 = (i2.y1 * t2 + r2.y - i2.padding) * m2 + f2.point.y, y2 = (i2.x2 * t2 + r2.x + i2.padding) * m2 + f2.point.x, x2 = (i2.y2 * t2 + r2.y + i2.padding) * m2 + f2.point.y, v2 = f2.perspectiveRatio <= 0.55 || f2.occluded;
          return !this.isInsideGrid(_2, g2, y2, x2) || !n2 && this.grid.hitTest(_2, g2, y2, x2, a2) || v2 ? { box: [], offscreen: false, occluded: f2.occluded } : { box: [_2, g2, y2, x2], offscreen: this.isOffscreen(_2, g2, y2, x2), occluded: false };
        }
        placeCollisionCircles(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, f2, m2) {
          const _2 = [], g2 = this.transform.elevation, y2 = e2.getProjection(), x2 = g2 ? g2.getAtTileOffsetFunc(m2, this.transform.center.lat, this.transform.worldSize, y2) : null, v2 = new d(i2.tileAnchorX, i2.tileAnchorY);
          let { x: b2, y: w2, z: T2 } = y2.projectTilePoint(v2.x, v2.y, m2.canonical);
          if (x2) {
            const [e3, t3, i3] = x2(v2);
            b2 += e3, w2 += t3, T2 += i3;
          }
          const E2 = "globe" === y2.name, S2 = this.projectAndGetPerspectiveRatio(s2, b2, w2, T2, m2, E2 || !!g2 || this.transform.pitch > 0, y2), { perspectiveRatio: A2 } = S2, C2 = (u2 ? o2 / A2 : o2 * A2) / 24, I2 = kp(b2, w2, T2, a2), M2 = S2.signedDistanceFromCamera > 0 ? Op(C2, n2, i2.lineOffsetX * C2, i2.lineOffsetY * C2, false, I2, v2, i2, r2, a2, {}, g2 && !u2 ? x2 : null, u2 && !!g2, y2, m2, u2) : null;
          let D2 = false, P2 = false, z2 = true;
          if (M2 && !S2.occluded) {
            const e3 = 0.5 * p2 * A2 + f2, i3 = new d(-100, -100), r3 = new d(this.screenRightBoundary, this.screenBottomBoundary), n3 = new PathInterpolator(), { first: o3, last: s3 } = M2, a3 = o3.path.length;
            let u3 = [];
            for (let e4 = a3 - 1; e4 >= 1; e4--)
              u3.push(o3.path[e4]);
            for (let e4 = 1; e4 < s3.path.length; e4++)
              u3.push(s3.path[e4]);
            const m3 = 2.5 * e3;
            l2 && (u3 = u3.map(([e4, t3, i4], r4) => (x2 && !E2 && (i4 = x2(r4 < a3 - 1 ? o3.tilePath[a3 - 1 - r4] : s3.tilePath[r4 - a3 + 2])[2]), kp(e4, t3, i4, l2))), u3.some((e4) => e4[3] <= 0) && (u3 = []));
            let g3 = [];
            if (u3.length > 0) {
              let e4 = 1 / 0, t3 = -1 / 0, n4 = 1 / 0, o4 = -1 / 0;
              for (const i4 of u3)
                e4 = Math.min(e4, i4[0]), n4 = Math.min(n4, i4[1]), t3 = Math.max(t3, i4[0]), o4 = Math.max(o4, i4[1]);
              t3 >= i3.x && e4 <= r3.x && o4 >= i3.y && n4 <= r3.y && (g3 = [u3.map((e5) => new d(e5[0], e5[1]))], (e4 < i3.x || t3 > r3.x || n4 < i3.y || o4 > r3.y) && (g3 = function(e5, t4, i4, r4, n5) {
                const o5 = [];
                for (let s4 = 0; s4 < e5.length; s4++) {
                  const a4 = e5[s4];
                  let l3;
                  for (let e6 = 0; e6 < a4.length - 1; e6++) {
                    let s5 = a4[e6], c3 = a4[e6 + 1];
                    s5.x < t4 && c3.x < t4 || (s5.x < t4 ? s5 = new d(t4, s5.y + (t4 - s5.x) / (c3.x - s5.x) * (c3.y - s5.y))._round() : c3.x < t4 && (c3 = new d(t4, s5.y + (t4 - s5.x) / (c3.x - s5.x) * (c3.y - s5.y))._round()), s5.y < i4 && c3.y < i4 || (s5.y < i4 ? s5 = new d(s5.x + (i4 - s5.y) / (c3.y - s5.y) * (c3.x - s5.x), i4)._round() : c3.y < i4 && (c3 = new d(s5.x + (i4 - s5.y) / (c3.y - s5.y) * (c3.x - s5.x), i4)._round()), s5.x >= r4 && c3.x >= r4 || (s5.x >= r4 ? s5 = new d(r4, s5.y + (r4 - s5.x) / (c3.x - s5.x) * (c3.y - s5.y))._round() : c3.x >= r4 && (c3 = new d(r4, s5.y + (r4 - s5.x) / (c3.x - s5.x) * (c3.y - s5.y))._round()), s5.y >= n5 && c3.y >= n5 || (s5.y >= n5 ? s5 = new d(s5.x + (n5 - s5.y) / (c3.y - s5.y) * (c3.x - s5.x), n5)._round() : c3.y >= n5 && (c3 = new d(s5.x + (n5 - s5.y) / (c3.y - s5.y) * (c3.x - s5.x), n5)._round()), l3 && s5.equals(l3[l3.length - 1]) || (l3 = [s5], o5.push(l3)), l3.push(c3)))));
                  }
                }
                return o5;
              }(g3, i3.x, i3.y, r3.x, r3.y)));
            }
            for (const i4 of g3) {
              n3.reset(i4, 0.25 * e3);
              let r4 = 0;
              r4 = n3.length <= 0.5 * e3 ? 1 : Math.ceil(n3.paddedLength / m3) + 1;
              for (let i5 = 0; i5 < r4; i5++) {
                const o4 = i5 / Math.max(r4 - 1, 1), s4 = n3.lerp(o4), a4 = s4.x + $p, l3 = s4.y + $p;
                _2.push(a4, l3, e3, 0);
                const u4 = a4 - e3, p3 = l3 - e3, d2 = a4 + e3, f3 = l3 + e3;
                if (z2 = z2 && this.isOffscreen(u4, p3, d2, f3), P2 = P2 || this.isInsideGrid(u4, p3, d2, f3), !t2 && this.grid.hitTestCircle(a4, l3, e3, h2) && (D2 = true, !c2))
                  return { circles: [], offscreen: false, collisionDetected: D2, occluded: false };
              }
            }
          }
          return { circles: !c2 && D2 || !P2 ? [] : _2, offscreen: z2, collisionDetected: D2, occluded: S2.occluded };
        }
        queryRenderedSymbols(e2) {
          if (0 === e2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
            return {};
          const t2 = [];
          let i2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, o2 = -1 / 0;
          for (const s3 of e2) {
            const e3 = new d(s3.x + $p, s3.y + $p);
            i2 = Math.min(i2, e3.x), r2 = Math.min(r2, e3.y), n2 = Math.max(n2, e3.x), o2 = Math.max(o2, e3.y), t2.push(e3);
          }
          const s2 = this.grid.query(i2, r2, n2, o2).concat(this.ignoredGrid.query(i2, r2, n2, o2)), a2 = {}, l2 = {};
          for (const e3 of s2) {
            const i3 = e3.key;
            void 0 === a2[i3.bucketInstanceId] && (a2[i3.bucketInstanceId] = {}), a2[i3.bucketInstanceId][i3.featureIndex] || rs(t2, [new d(e3.x1, e3.y1), new d(e3.x2, e3.y1), new d(e3.x2, e3.y2), new d(e3.x1, e3.y2)]) && (a2[i3.bucketInstanceId][i3.featureIndex] = true, void 0 === l2[i3.bucketInstanceId] && (l2[i3.bucketInstanceId] = []), l2[i3.bucketInstanceId].push(i3.featureIndex));
          }
          return l2;
        }
        insertCollisionBox(e2, t2, i2, r2, n2) {
          (t2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: r2, collisionGroupID: n2 }, e2[0], e2[1], e2[2], e2[3]);
        }
        insertCollisionCircles(e2, t2, i2, r2, n2) {
          const o2 = t2 ? this.ignoredGrid : this.grid, s2 = { bucketInstanceId: i2, featureIndex: r2, collisionGroupID: n2 };
          for (let t3 = 0; t3 < e2.length; t3 += 4)
            o2.insertCircle(s2, e2[t3], e2[t3 + 1], e2[t3 + 2]);
        }
        projectAndGetPerspectiveRatio(e2, t2, i2, r2, n2, o2, s2) {
          const a2 = [t2, i2, r2, 1];
          let l2 = false;
          if (r2 || this.transform.pitch > 0) {
            da(a2, a2, e2);
            const o3 = "globe" === s2.name;
            if (this.fogState && n2 && !o3) {
              const e3 = function(e4, t3, i3, r3, n3, o4) {
                const s3 = [t3, i3, r3];
                return ra(s3, s3, o4.calculateFogTileMatrix(n3)), Sh(e4, s3, o4.pitch, o4._fov);
              }(this.fogState, t2, i2, r2, n2.toUnwrapped(), this.transform);
              l2 = e3 > 0.9;
            }
          } else
            Zp(a2, a2, e2);
          const c2 = a2[3];
          return { point: new d((a2[0] / c2 + 1) / 2 * this.transform.width + $p, (-a2[1] / c2 + 1) / 2 * this.transform.height + $p), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(s2) / c2 * 0.5, 1.5), signedDistanceFromCamera: c2, occluded: o2 && a2[2] > c2 || l2 };
        }
        isOffscreen(e2, t2, i2, r2) {
          return i2 < $p || e2 >= this.screenRightBoundary || r2 < $p || t2 > this.screenBottomBoundary;
        }
        isInsideGrid(e2, t2, i2, r2) {
          return i2 >= 0 && e2 < this.gridRightBoundary && r2 >= 0 && t2 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const e2 = Is([]);
          return Ps(e2, e2, [-100, -100, 0]), e2;
        }
      }
      function Wp(e2, t2, i2) {
        const r2 = t2.createTileMatrix(e2, e2.worldSize, i2.toUnwrapped());
        return Ds(new Float32Array(16), e2.projMatrix, r2);
      }
      function Hp(e2, t2, i2) {
        if (t2.projection.name === i2.projection.name)
          return e2.projMatrix;
        const r2 = i2.clone();
        return r2.setProjection(t2.projection), Wp(r2, t2.getProjection(), e2);
      }
      function Xp(e2, t2, i2) {
        return t2.name === i2.projection.name ? e2.projMatrix : Wp(i2, t2, e2);
      }
      class OpacityState {
        constructor(e2, t2, i2, r2) {
          this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : r2 && i2 ? 1 : 0, this.placed = i2;
        }
        isHidden() {
          return 0 === this.opacity && !this.placed;
        }
      }
      class JointOpacityState {
        constructor(e2, t2, i2, r2, n2, o2 = false) {
          this.text = new OpacityState(e2 ? e2.text : null, t2, i2, n2), this.icon = new OpacityState(e2 ? e2.icon : null, t2, r2, n2), this.clipped = o2;
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class JointPlacement {
        constructor(e2, t2, i2, r2 = false) {
          this.text = e2, this.icon = t2, this.skipFade = i2, this.clipped = r2;
        }
      }
      class CollisionCircleArray {
        constructor() {
          this.invProjMatrix = Cs(), this.viewportMatrix = Cs(), this.circles = [];
        }
      }
      class RetainedQueryData {
        constructor(e2, t2, i2, r2, n2) {
          this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = r2, this.tileID = n2;
        }
      }
      class CollisionGroups {
        constructor(e2) {
          this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e2) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[e2]) {
            const t2 = ++this.maxGroupID;
            this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
          }
          return this.collisionGroups[e2];
        }
      }
      function Kp(e2, t2, i2, r2, n2) {
        const { horizontalAlign: o2, verticalAlign: s2 } = Kc(e2), a2 = -(o2 - 0.5) * t2, l2 = -(s2 - 0.5) * i2, c2 = iu(e2, r2);
        return new d(a2 + c2[0] * n2, l2 + c2[1] * n2);
      }
      function Yp(e2, t2, i2, r2, n2) {
        const o2 = new d(e2, t2);
        return i2 && o2._rotate(r2 ? n2 : -n2), o2;
      }
      class Placement {
        constructor(e2, t2, i2, r2, n2) {
          this.transform = e2.clone(), this.projection = e2.projection.name, this.collisionIndex = new CollisionIndex(this.transform, n2), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t2, this.retainedQueryData = {}, this.collisionGroups = new CollisionGroups(i2), this.collisionCircleArrays = {}, this.prevPlacement = r2, r2 && (r2.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(e2, t2, i2, r2) {
          const n2 = i2.getBucket(t2), o2 = i2.latestFeatureIndex;
          if (!n2 || !o2 || t2.id !== n2.layerIds[0])
            return;
          const s2 = n2.layers[0].layout, a2 = i2.collisionBoxArray, l2 = Math.pow(2, this.transform.zoom - i2.tileID.overscaledZ), c2 = i2.tileSize / ko, u2 = i2.tileID.toUnwrapped();
          this.transform.setProjection(n2.projection);
          const h2 = (p2 = i2.tileID, d2 = n2.getProjection(), f2 = this.transform, d2.name === this.projection ? f2.calculateProjMatrix(p2.toUnwrapped()) : Wp(f2, d2, p2));
          var p2, d2, f2;
          const m2 = "map" === s2.get("text-pitch-alignment"), _2 = "map" === s2.get("text-rotation-alignment");
          t2.compileFilter();
          const g2 = t2.dynamicFilter(), y2 = t2.dynamicFilterNeedsFeature(), x2 = this.transform.calculatePixelsToTileUnitsMatrix(i2), v2 = zp(h2, i2.tileID.canonical, m2, _2, this.transform, n2.getProjection(), x2);
          let b2 = null;
          if (m2) {
            const e3 = Lp(h2, i2.tileID.canonical, m2, _2, this.transform, n2.getProjection(), x2);
            b2 = Ds([], this.transform.labelPlaneMatrix, e3);
          }
          let w2 = null;
          g2 && i2.latestFeatureIndex && (w2 = { unwrappedTileID: u2, dynamicFilter: g2, dynamicFilterNeedsFeature: y2, featureIndex: i2.latestFeatureIndex }), this.retainedQueryData[n2.bucketInstanceId] = new RetainedQueryData(n2.bucketInstanceId, o2, n2.sourceLayerIndex, n2.index, i2.tileID);
          const T2 = { bucket: n2, layout: s2, posMatrix: h2, textLabelPlaneMatrix: v2, labelToScreenMatrix: b2, clippingData: w2, scale: l2, textPixelRatio: c2, holdingForFade: i2.holdingForFade(), collisionBoxArray: a2, partiallyEvaluatedTextSize: xc(n2.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: xc(n2.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(n2.sourceID) };
          if (r2)
            for (const t3 of n2.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: r3, symbolInstanceEnd: n3 } = t3;
              e2.push({ sortKey: i3, symbolInstanceStart: r3, symbolInstanceEnd: n3, parameters: T2 });
            }
          else
            e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: n2.symbolInstances.length, parameters: T2 });
        }
        attemptAnchorPlacement(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2, m2, _2, g2) {
          const { textOffset0: y2, textOffset1: x2, crossTileID: v2 } = h2, b2 = [y2, x2], w2 = Kp(e2, i2, r2, b2, n2), T2 = this.collisionIndex.placeCollisionBox(d2, n2, t2, Yp(w2.x, w2.y, o2, s2, this.transform.angle), u2, a2, l2, c2.predicate);
          if (m2) {
            const e3 = d2.getSymbolInstanceIconSize(g2, this.transform.zoom, h2.placedIconSymbolIndex);
            if (0 === this.collisionIndex.placeCollisionBox(d2, e3, m2, Yp(w2.x, w2.y, o2, s2, this.transform.angle), u2, a2, l2, c2.predicate).box.length)
              return;
          }
          if (T2.box.length > 0) {
            let t3;
            return this.prevPlacement && this.prevPlacement.variableOffsets[v2] && this.prevPlacement.placements[v2] && this.prevPlacement.placements[v2].text && (t3 = this.prevPlacement.variableOffsets[v2].anchor), this.variableOffsets[v2] = { textOffset: b2, width: i2, height: r2, anchor: e2, textScale: n2, prevAnchor: t3 }, this.markUsedJustification(d2, e2, h2, f2), d2.allowVerticalPlacement && (this.markUsedOrientation(d2, f2, h2), this.placedOrientations[v2] = f2), { shift: w2, placedGlyphBoxes: T2 };
          }
        }
        placeLayerBucketPart(e2, t2, i2, r2) {
          const { bucket: n2, layout: o2, posMatrix: s2, textLabelPlaneMatrix: a2, labelToScreenMatrix: l2, clippingData: c2, textPixelRatio: u2, holdingForFade: h2, collisionBoxArray: p2, partiallyEvaluatedTextSize: f2, partiallyEvaluatedIconSize: m2, collisionGroup: _2 } = e2.parameters, g2 = o2.get("text-optional"), y2 = o2.get("icon-optional"), x2 = o2.get("text-allow-overlap"), v2 = o2.get("icon-allow-overlap"), b2 = "map" === o2.get("text-rotation-alignment"), w2 = "map" === o2.get("text-pitch-alignment"), T2 = "none" !== o2.get("icon-text-fit"), E2 = "viewport-y" === o2.get("symbol-z-order");
          this.transform.setProjection(n2.projection);
          let S2 = x2 && (v2 || !n2.hasIconData() || y2), A2 = v2 && (x2 || !n2.hasTextData() || g2);
          !n2.collisionArrays && p2 && n2.deserializeCollisionBoxes(p2), i2 && r2 && n2.updateCollisionDebugBuffers(this.transform.zoom, p2);
          const C2 = (e3, r3, p3) => {
            const { crossTileID: E3, numVerticalGlyphVertices: C3 } = e3;
            if (c2) {
              const i3 = { zoom: this.transform.zoom, pitch: this.transform.pitch };
              let r4 = null;
              if (c2.dynamicFilterNeedsFeature) {
                const t3 = this.retainedQueryData[n2.bucketInstanceId];
                r4 = c2.featureIndex.loadFeature({ featureIndex: e3.featureIndex, bucketIndex: t3.bucketIndex, sourceLayerIndex: t3.sourceLayerIndex, layoutVertexArrayOffset: 0 });
              }
              if (!(0, c2.dynamicFilter)(i3, r4, this.retainedQueryData[n2.bucketInstanceId].tileID.canonical, new d(e3.tileAnchorX, e3.tileAnchorY), this.transform.calculateDistanceTileData(c2.unwrappedTileID)))
                return this.placements[E3] = new JointPlacement(false, false, false, true), void (t2[E3] = true);
            }
            if (t2[E3])
              return;
            if (h2)
              return void (this.placements[E3] = new JointPlacement(false, false, false));
            let I2 = false, M2 = false, D2 = true, P2 = false, z2 = false, L2 = null, k2 = { box: null, offscreen: null, occluded: null }, B2 = { box: null, offscreen: null, occluded: null }, R2 = null, F2 = null, O2 = null, U2 = 0, V2 = 0, j2 = 0;
            p3.textFeatureIndex ? U2 = p3.textFeatureIndex : e3.useRuntimeCollisionCircles && (U2 = e3.featureIndex), p3.verticalTextFeatureIndex && (V2 = p3.verticalTextFeatureIndex);
            const N2 = (e4) => {
              e4.tileID = this.retainedQueryData[n2.bucketInstanceId].tileID;
              const t3 = this.transform.elevation;
              (t3 || e4.elevation) && (e4.elevation = t3 ? t3.getAtTileOffset(e4.tileID, e4.tileAnchorX, e4.tileAnchorY) : 0);
            }, G2 = p3.textBox;
            if (G2) {
              N2(G2);
              const t3 = (t4) => {
                let i4 = Xc.horizontal;
                if (n2.allowVerticalPlacement && !t4 && this.prevPlacement) {
                  const t5 = this.prevPlacement.placedOrientations[E3];
                  t5 && (this.placedOrientations[E3] = t5, i4 = t5, this.markUsedOrientation(n2, i4, e3));
                }
                return i4;
              }, i3 = (e4, t4) => {
                if (n2.allowVerticalPlacement && C3 > 0 && p3.verticalTextBox) {
                  for (const i4 of n2.writingModes)
                    if (i4 === Xc.vertical ? (k2 = t4(), B2 = k2) : k2 = e4(), k2 && k2.box && k2.box.length)
                      break;
                } else
                  k2 = e4();
              };
              if (o2.get("text-variable-anchor")) {
                let a3 = o2.get("text-variable-anchor");
                if (this.prevPlacement && this.prevPlacement.variableOffsets[E3]) {
                  const e4 = this.prevPlacement.variableOffsets[E3];
                  a3.indexOf(e4.anchor) > 0 && (a3 = a3.filter((t4) => t4 !== e4.anchor), a3.unshift(e4.anchor));
                }
                const l3 = (t4, i4, o3) => {
                  const l4 = n2.getSymbolInstanceTextSize(f2, e3, this.transform.zoom, r3), c4 = (t4.x2 - t4.x1) * l4 + 2 * t4.padding, h3 = (t4.y2 - t4.y1) * l4 + 2 * t4.padding, p4 = T2 && !v2 ? i4 : null;
                  p4 && N2(p4);
                  let d2 = { box: [], offscreen: false, occluded: false };
                  const g3 = x2 ? 2 * a3.length : a3.length;
                  for (let i5 = 0; i5 < g3; ++i5) {
                    const g4 = this.attemptAnchorPlacement(a3[i5 % a3.length], t4, c4, h3, l4, b2, w2, u2, s2, _2, i5 >= a3.length, e3, r3, n2, o3, p4, f2, m2);
                    if (g4 && (d2 = g4.placedGlyphBoxes, d2 && d2.box && d2.box.length)) {
                      I2 = true, L2 = g4.shift;
                      break;
                    }
                  }
                  return d2;
                };
                i3(() => l3(G2, p3.iconBox, Xc.horizontal), () => {
                  const e4 = p3.verticalTextBox;
                  return e4 && N2(e4), n2.allowVerticalPlacement && !(k2 && k2.box && k2.box.length) && C3 > 0 && e4 ? l3(e4, p3.verticalIconBox, Xc.vertical) : { box: null, offscreen: null, occluded: null };
                }), k2 && (I2 = k2.box, D2 = k2.offscreen, P2 = k2.occluded);
                const c3 = t3(k2 && k2.box);
                if (!I2 && this.prevPlacement) {
                  const t4 = this.prevPlacement.variableOffsets[E3];
                  t4 && (this.variableOffsets[E3] = t4, this.markUsedJustification(n2, t4.anchor, e3, c3));
                }
              } else {
                const o3 = (t4, i4) => {
                  const o4 = n2.getSymbolInstanceTextSize(f2, e3, this.transform.zoom, r3), a3 = this.collisionIndex.placeCollisionBox(n2, o4, t4, new d(0, 0), x2, u2, s2, _2.predicate);
                  return a3 && a3.box && a3.box.length && (this.markUsedOrientation(n2, i4, e3), this.placedOrientations[E3] = i4), a3;
                };
                i3(() => o3(G2, Xc.horizontal), () => {
                  const e4 = p3.verticalTextBox;
                  return n2.allowVerticalPlacement && C3 > 0 && e4 ? (N2(e4), o3(e4, Xc.vertical)) : { box: null, offscreen: null, occluded: null };
                }), t3(k2 && k2.box && k2.box.length);
              }
            }
            if (R2 = k2, I2 = R2 && R2.box && R2.box.length > 0, D2 = R2 && R2.offscreen, P2 = R2 && R2.occluded, e3.useRuntimeCollisionCircles) {
              const t3 = n2.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex >= 0 ? e3.centerJustifiedTextSymbolIndex : e3.verticalPlacedTextSymbolIndex), r4 = yc(n2.textSizeData, f2, t3), c3 = o2.get("text-padding");
              F2 = this.collisionIndex.placeCollisionCircles(n2, x2, t3, n2.lineVertexArray, n2.glyphOffsetArray, r4, s2, a2, l2, i2, w2, _2.predicate, e3.collisionCircleDiameter * r4 / 24, c3, this.retainedQueryData[n2.bucketInstanceId].tileID), I2 = x2 || F2.circles.length > 0 && !F2.collisionDetected, D2 = D2 && F2.offscreen, P2 = F2.occluded;
            }
            if (p3.iconFeatureIndex && (j2 = p3.iconFeatureIndex), p3.iconBox) {
              const t3 = (t4) => {
                N2(t4);
                const i3 = T2 && L2 ? Yp(L2.x, L2.y, b2, w2, this.transform.angle) : new d(0, 0), r4 = n2.getSymbolInstanceIconSize(m2, this.transform.zoom, e3.placedIconSymbolIndex);
                return this.collisionIndex.placeCollisionBox(n2, r4, t4, i3, v2, u2, s2, _2.predicate);
              };
              B2 && B2.box && B2.box.length && p3.verticalIconBox ? (O2 = t3(p3.verticalIconBox), M2 = O2.box.length > 0) : (O2 = t3(p3.iconBox), M2 = O2.box.length > 0), D2 = D2 && O2.offscreen, z2 = O2.occluded;
            }
            const q2 = g2 || 0 === e3.numHorizontalGlyphVertices && 0 === C3, Z2 = y2 || 0 === e3.numIconVertices;
            if (q2 || Z2 ? Z2 ? q2 || (M2 = M2 && I2) : I2 = M2 && I2 : M2 = I2 = M2 && I2, I2 && R2 && R2.box && this.collisionIndex.insertCollisionBox(R2.box, o2.get("text-ignore-placement"), n2.bucketInstanceId, B2 && B2.box && V2 ? V2 : U2, _2.ID), M2 && O2 && this.collisionIndex.insertCollisionBox(O2.box, o2.get("icon-ignore-placement"), n2.bucketInstanceId, j2, _2.ID), F2 && (I2 && this.collisionIndex.insertCollisionCircles(F2.circles, o2.get("text-ignore-placement"), n2.bucketInstanceId, U2, _2.ID), i2)) {
              const e4 = n2.bucketInstanceId;
              let t3 = this.collisionCircleArrays[e4];
              void 0 === t3 && (t3 = this.collisionCircleArrays[e4] = new CollisionCircleArray());
              for (let e5 = 0; e5 < F2.circles.length; e5 += 4)
                t3.circles.push(F2.circles[e5 + 0]), t3.circles.push(F2.circles[e5 + 1]), t3.circles.push(F2.circles[e5 + 2]), t3.circles.push(F2.collisionDetected ? 1 : 0);
            }
            const $2 = "globe" !== n2.projection.name;
            S2 = S2 && ($2 || !P2), A2 = A2 && ($2 || !z2), this.placements[E3] = new JointPlacement(I2 || S2, M2 || A2, D2 || n2.justReloaded), t2[E3] = true;
          };
          if (E2) {
            const e3 = n2.getSortedSymbolIndexes(this.transform.angle);
            for (let t3 = e3.length - 1; t3 >= 0; --t3) {
              const i3 = e3[t3];
              C2(n2.symbolInstances.get(i3), i3, n2.collisionArrays[i3]);
            }
          } else
            for (let t3 = e2.symbolInstanceStart; t3 < e2.symbolInstanceEnd; t3++)
              C2(n2.symbolInstances.get(t3), t3, n2.collisionArrays[t3]);
          if (i2 && n2.bucketInstanceId in this.collisionCircleArrays) {
            const e3 = this.collisionCircleArrays[n2.bucketInstanceId];
            Ms(e3.invProjMatrix, s2), e3.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          n2.justReloaded = false;
        }
        markUsedJustification(e2, t2, i2, r2) {
          const { leftJustifiedTextSymbolIndex: n2, centerJustifiedTextSymbolIndex: o2, rightJustifiedTextSymbolIndex: s2, verticalPlacedTextSymbolIndex: a2, crossTileID: l2 } = i2, c2 = function(e3) {
            switch (e3) {
              case "right":
              case "top-right":
              case "bottom-right":
                return "right";
              case "left":
              case "top-left":
              case "bottom-left":
                return "left";
            }
            return "center";
          }(t2), u2 = r2 === Xc.vertical ? a2 : "left" === c2 ? n2 : "center" === c2 ? o2 : "right" === c2 ? s2 : -1;
          n2 >= 0 && (e2.text.placedSymbolArray.get(n2).crossTileID = u2 >= 0 && n2 !== u2 ? 0 : l2), o2 >= 0 && (e2.text.placedSymbolArray.get(o2).crossTileID = u2 >= 0 && o2 !== u2 ? 0 : l2), s2 >= 0 && (e2.text.placedSymbolArray.get(s2).crossTileID = u2 >= 0 && s2 !== u2 ? 0 : l2), a2 >= 0 && (e2.text.placedSymbolArray.get(a2).crossTileID = u2 >= 0 && a2 !== u2 ? 0 : l2);
        }
        markUsedOrientation(e2, t2, i2) {
          const r2 = t2 === Xc.horizontal || t2 === Xc.horizontalOnly ? t2 : 0, n2 = t2 === Xc.vertical ? t2 : 0, { leftJustifiedTextSymbolIndex: o2, centerJustifiedTextSymbolIndex: s2, rightJustifiedTextSymbolIndex: a2, verticalPlacedTextSymbolIndex: l2 } = i2, c2 = e2.text.placedSymbolArray;
          o2 >= 0 && (c2.get(o2).placedOrientation = r2), s2 >= 0 && (c2.get(s2).placedOrientation = r2), a2 >= 0 && (c2.get(a2).placedOrientation = r2), l2 >= 0 && (c2.get(l2).placedOrientation = n2);
        }
        commit(e2) {
          this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const t2 = this.prevPlacement;
          let i2 = false;
          this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
          const r2 = t2 ? t2.symbolFadeChange(e2) : 1, n2 = t2 ? t2.opacities : {}, o2 = t2 ? t2.variableOffsets : {}, s2 = t2 ? t2.placedOrientations : {};
          for (const e3 in this.placements) {
            const t3 = this.placements[e3], o3 = n2[e3];
            o3 ? (this.opacities[e3] = new JointOpacityState(o3, r2, t3.text, t3.icon, null, t3.clipped), i2 = i2 || t3.text !== o3.text.placed || t3.icon !== o3.icon.placed) : (this.opacities[e3] = new JointOpacityState(null, r2, t3.text, t3.icon, t3.skipFade, t3.clipped), i2 = i2 || t3.text || t3.icon);
          }
          for (const e3 in n2) {
            const t3 = n2[e3];
            if (!this.opacities[e3]) {
              const n3 = new JointOpacityState(t3, r2, false, false);
              n3.isHidden() || (this.opacities[e3] = n3, i2 = i2 || t3.text.placed || t3.icon.placed);
            }
          }
          for (const e3 in o2)
            this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = o2[e3]);
          for (const e3 in s2)
            this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = s2[e3]);
          i2 ? this.lastPlacementChangeTime = e2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
        }
        updateLayerOpacities(e2, t2) {
          const i2 = {};
          for (const r2 of t2) {
            const t3 = r2.getBucket(e2);
            t3 && r2.latestFeatureIndex && e2.id === t3.layerIds[0] && this.updateBucketOpacities(t3, i2, r2.collisionBoxArray);
          }
        }
        updateBucketOpacities(e2, t2, i2) {
          e2.hasTextData() && e2.text.opacityVertexArray.clear(), e2.hasIconData() && e2.icon.opacityVertexArray.clear(), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
          const r2 = e2.layers[0].layout, n2 = !!e2.layers[0].dynamicFilter(), o2 = new JointOpacityState(null, 0, false, false, true), s2 = r2.get("text-allow-overlap"), a2 = r2.get("icon-allow-overlap"), l2 = r2.get("text-variable-anchor"), c2 = "map" === r2.get("text-rotation-alignment"), u2 = "map" === r2.get("text-pitch-alignment"), h2 = "none" !== r2.get("icon-text-fit"), p2 = new JointOpacityState(null, 0, s2 && (a2 || !e2.hasIconData() || r2.get("icon-optional")), a2 && (s2 || !e2.hasTextData() || r2.get("text-optional")), true);
          !e2.collisionArrays && i2 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(i2);
          const f2 = (e3, t3, i3) => {
            for (let r3 = 0; r3 < t3 / 4; r3++)
              e3.opacityVertexArray.emplaceBack(i3);
          };
          let m2 = 0;
          for (let i3 = 0; i3 < e2.symbolInstances.length; i3++) {
            const r3 = e2.symbolInstances.get(i3), { numHorizontalGlyphVertices: s3, numVerticalGlyphVertices: a3, crossTileID: _2, numIconVertices: g2 } = r3;
            let y2 = this.opacities[_2];
            t2[_2] ? y2 = o2 : y2 || (y2 = p2, this.opacities[_2] = y2), t2[_2] = true;
            const x2 = s3 > 0 || a3 > 0, v2 = g2 > 0, b2 = this.placedOrientations[_2], w2 = b2 === Xc.vertical, T2 = b2 === Xc.horizontal || b2 === Xc.horizontalOnly;
            if (!x2 && !v2 || y2.isHidden() || m2++, x2) {
              const t3 = sd(y2.text);
              f2(e2.text, s3, w2 ? ad : t3), f2(e2.text, a3, T2 ? ad : t3);
              const i4 = y2.text.isHidden(), { leftJustifiedTextSymbolIndex: n3, centerJustifiedTextSymbolIndex: o3, rightJustifiedTextSymbolIndex: l3, verticalPlacedTextSymbolIndex: c3 } = r3, u3 = e2.text.placedSymbolArray, h3 = i4 || w2 ? 1 : 0;
              n3 >= 0 && (u3.get(n3).hidden = h3), o3 >= 0 && (u3.get(o3).hidden = h3), l3 >= 0 && (u3.get(l3).hidden = h3), c3 >= 0 && (u3.get(c3).hidden = i4 || T2 ? 1 : 0);
              const p3 = this.variableOffsets[_2];
              p3 && this.markUsedJustification(e2, p3.anchor, r3, b2);
              const d2 = this.placedOrientations[_2];
              d2 && (this.markUsedJustification(e2, "left", r3, d2), this.markUsedOrientation(e2, d2, r3));
            }
            if (v2) {
              const t3 = sd(y2.icon), { placedIconSymbolIndex: i4, verticalPlacedIconSymbolIndex: n3 } = r3, o3 = e2.icon.placedSymbolArray, s4 = y2.icon.isHidden() ? 1 : 0;
              i4 >= 0 && (f2(e2.icon, g2, w2 ? ad : t3), o3.get(i4).hidden = s4), n3 >= 0 && (f2(e2.icon, r3.numVerticalIconVertices, T2 ? ad : t3), o3.get(n3).hidden = s4);
            }
            if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
              const t3 = e2.collisionArrays[i3];
              if (t3) {
                let i4 = new d(0, 0), r4 = true;
                if (t3.textBox || t3.verticalTextBox) {
                  if (l2) {
                    const e3 = this.variableOffsets[_2];
                    e3 ? (i4 = Kp(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textScale), c2 && i4._rotate(u2 ? this.transform.angle : -this.transform.angle)) : r4 = false;
                  }
                  n2 && (r4 = !y2.clipped), t3.textBox && Jp(e2.textCollisionBox.collisionVertexArray, y2.text.placed, !r4 || w2, i4.x, i4.y), t3.verticalTextBox && Jp(e2.textCollisionBox.collisionVertexArray, y2.text.placed, !r4 || T2, i4.x, i4.y);
                }
                const o3 = r4 && Boolean(!T2 && t3.verticalIconBox);
                t3.iconBox && Jp(e2.iconCollisionBox.collisionVertexArray, y2.icon.placed, o3, h2 ? i4.x : 0, h2 ? i4.y : 0), t3.verticalIconBox && Jp(e2.iconCollisionBox.collisionVertexArray, y2.icon.placed, !o3, h2 ? i4.x : 0, h2 ? i4.y : 0);
              }
            }
          }
          if (e2.fullyClipped = 0 === m2, e2.sortFeatures(this.transform.angle), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.bucketInstanceId in this.collisionCircleArrays) {
            const t3 = this.collisionCircleArrays[e2.bucketInstanceId];
            e2.placementInvProjMatrix = t3.invProjMatrix, e2.placementViewportMatrix = t3.viewportMatrix, e2.collisionCircleArray = t3.circles, delete this.collisionCircleArrays[e2.bucketInstanceId];
          }
        }
        symbolFadeChange(e2) {
          return 0 === this.fadeDuration ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e2) {
          return Math.max(0, (this.transform.zoom - e2) / 1.5);
        }
        hasTransitions(e2) {
          return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e2, t2) {
          const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
          return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
        }
        setStale() {
          this.stale = true;
        }
      }
      function Jp(e2, t2, i2, r2, n2) {
        e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, n2 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, n2 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, n2 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, n2 || 0);
      }
      const Qp = Math.pow(2, 25), ed = Math.pow(2, 24), td = Math.pow(2, 17), id = Math.pow(2, 16), rd = Math.pow(2, 9), nd = Math.pow(2, 8), od = Math.pow(2, 1);
      function sd(e2) {
        if (0 === e2.opacity && !e2.placed)
          return 0;
        if (1 === e2.opacity && e2.placed)
          return 4294967295;
        const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
        return i2 * Qp + t2 * ed + i2 * td + t2 * id + i2 * rd + t2 * nd + i2 * od + t2;
      }
      const ad = 0;
      class LayerPlacement {
        constructor(e2) {
          this._sortAcrossTiles = "viewport-y" !== e2.layout.get("symbol-z-order") && void 0 !== e2.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(e2, t2, i2, r2, n2) {
          const o2 = this._bucketParts;
          for (; this._currentTileIndex < e2.length; )
            if (t2.getBucketParts(o2, r2, e2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, n2())
              return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o2.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < o2.length; ) {
            const e3 = o2[this._currentPartIndex];
            if (t2.placeLayerBucketPart(e3, this._seenCrossTileIDs, i2, 0 === e3.symbolInstanceStart), this._currentPartIndex++, n2())
              return true;
          }
          return false;
        }
      }
      class PauseablePlacement {
        constructor(e2, t2, i2, r2, n2, o2, s2, a2) {
          this.placement = new Placement(e2, n2, o2, s2, a2), this._currentPlacementIndex = t2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = r2, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(e2, t2, i2) {
          const r2 = Je.now(), n2 = () => {
            const e3 = Je.now() - r2;
            return !this._forceFullPlacement && e3 > 2;
          };
          for (; this._currentPlacementIndex >= 0; ) {
            const r3 = t2[e2[this._currentPlacementIndex]], o2 = this.placement.collisionIndex.transform.zoom;
            if ("symbol" === r3.type && (!r3.minzoom || r3.minzoom <= o2) && (!r3.maxzoom || r3.maxzoom > o2)) {
              if (this._inProgressLayer || (this._inProgressLayer = new LayerPlacement(r3)), this._inProgressLayer.continuePlacement(i2[r3.source], this.placement, this._showCollisionBoxes, r3, n2))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(e2) {
          return this.placement.commit(e2), this.placement;
        }
      }
      class TileLayerIndex {
        constructor(e2, t2, i2) {
          this.tileID = e2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
          for (let i3 = 0; i3 < t2.length; i3++) {
            const r2 = t2.get(i3), n2 = r2.key;
            this.indexedSymbolInstances[n2] || (this.indexedSymbolInstances[n2] = []), this.indexedSymbolInstances[n2].push({ crossTileID: r2.crossTileID, coord: this.getScaledCoordinates(r2, e2) });
          }
        }
        getScaledCoordinates(e2, t2) {
          const i2 = 0.03125 / Math.pow(2, t2.canonical.z - this.tileID.canonical.z);
          return { x: Math.floor((t2.canonical.x * ko + e2.tileAnchorX) * i2), y: Math.floor((t2.canonical.y * ko + e2.tileAnchorY) * i2) };
        }
        findMatches(e2, t2, i2) {
          const r2 = this.tileID.canonical.z < t2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t2.canonical.z);
          for (let n2 = 0; n2 < e2.length; n2++) {
            const o2 = e2.get(n2);
            if (o2.crossTileID)
              continue;
            const s2 = this.indexedSymbolInstances[o2.key];
            if (!s2)
              continue;
            const a2 = this.getScaledCoordinates(o2, t2);
            for (const e3 of s2)
              if (Math.abs(e3.coord.x - a2.x) <= r2 && Math.abs(e3.coord.y - a2.y) <= r2 && !i2[e3.crossTileID]) {
                i2[e3.crossTileID] = true, o2.crossTileID = e3.crossTileID;
                break;
              }
          }
        }
      }
      class CrossTileIDs {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class CrossTileSymbolLayerIndex {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e2) {
          const t2 = Math.round((e2 - this.lng) / 360);
          if (0 !== t2)
            for (const e3 in this.indexes) {
              const i2 = this.indexes[e3], r2 = {};
              for (const e4 in i2) {
                const n2 = i2[e4];
                n2.tileID = n2.tileID.unwrapTo(n2.tileID.wrap + t2), r2[n2.tileID.key] = n2;
              }
              this.indexes[e3] = r2;
            }
          this.lng = e2;
        }
        addBucket(e2, t2, i2) {
          if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
            if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId)
              return false;
            this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
          }
          for (let e3 = 0; e3 < t2.symbolInstances.length; e3++)
            t2.symbolInstances.get(e3).crossTileID = 0;
          this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = {});
          const r2 = this.usedCrossTileIDs[e2.overscaledZ];
          for (const i3 in this.indexes) {
            const n2 = this.indexes[i3];
            if (Number(i3) > e2.overscaledZ)
              for (const i4 in n2) {
                const o2 = n2[i4];
                o2.tileID.isChildOf(e2) && o2.findMatches(t2.symbolInstances, e2, r2);
              }
            else {
              const o2 = n2[e2.scaledTo(Number(i3)).key];
              o2 && o2.findMatches(t2.symbolInstances, e2, r2);
            }
          }
          for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
            const n2 = t2.symbolInstances.get(e3);
            n2.crossTileID || (n2.crossTileID = i2.generate(), r2[n2.crossTileID] = true);
          }
          return void 0 === this.indexes[e2.overscaledZ] && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new TileLayerIndex(e2, t2.symbolInstances, t2.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(e2, t2) {
          for (const i2 in t2.indexedSymbolInstances)
            for (const r2 of t2.indexedSymbolInstances[i2])
              delete this.usedCrossTileIDs[e2][r2.crossTileID];
        }
        removeStaleBuckets(e2) {
          let t2 = false;
          for (const i2 in this.indexes) {
            const r2 = this.indexes[i2];
            for (const n2 in r2)
              e2[r2[n2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, r2[n2]), delete r2[n2], t2 = true);
          }
          return t2;
        }
      }
      class CrossTileSymbolIndex {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new CrossTileIDs(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e2, t2, i2, r2) {
          let n2 = this.layerIndexes[e2.id];
          void 0 === n2 && (n2 = this.layerIndexes[e2.id] = new CrossTileSymbolLayerIndex());
          let o2 = false;
          const s2 = {};
          "globe" !== r2.name && n2.handleWrapJump(i2);
          for (const i3 of t2) {
            const t3 = i3.getBucket(e2);
            t3 && e2.id === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), n2.addBucket(i3.tileID, t3, this.crossTileIDs) && (o2 = true), s2[t3.bucketInstanceId] = true);
          }
          return n2.removeStaleBuckets(s2) && (o2 = true), o2;
        }
        pruneUnusedLayers(e2) {
          const t2 = {};
          e2.forEach((e3) => {
            t2[e3] = true;
          });
          for (const e3 in this.layerIndexes)
            t2[e3] || delete this.layerIndexes[e3];
        }
      }
      const ld = (e2, t2) => Dn(e2, t2 && t2.filter((e3) => "source.canvas" !== e3.identifier)), cd = z(wp, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]), ud = z(wp, ["setCenter", "setZoom", "setBearing", "setPitch"]), hd = { version: 8, layers: [], sources: {} }, pd = { fill: true, line: true, background: true, hillshade: true, raster: true };
      class Style extends Evented {
        constructor(e2, t2 = {}) {
          super(), this.map = e2, this.dispatcher = new Dispatcher(yp(), this), this.imageManager = new ImageManager(), this.imageManager.setEventedParent(this), this.glyphManager = new GlyphManager(e2._requestManager, t2.localFontFamily ? 2 : t2.localIdeographFontFamily ? 1 : 0, t2.localFontFamily || t2.localIdeographFontFamily), this.crossTileSymbolIndex = new CrossTileSymbolIndex(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = false, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", de());
          const i2 = this;
          this._rtlTextPluginCallback = Style.registerForPluginStateChange((e3) => {
            i2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e3.pluginStatus, pluginURL: e3.pluginURL }, (e4, t3) => {
              if (to(e4), t3 && t3.every((e5) => e5))
                for (const e5 in i2._sourceCaches) {
                  const t4 = i2._sourceCaches[e5], r2 = t4.getSource().type;
                  "vector" !== r2 && "geojson" !== r2 || t4.reload();
                }
            });
          }), this.on("data", (e3) => {
            if ("source" !== e3.dataType || "metadata" !== e3.sourceDataType)
              return;
            const t3 = this.getSource(e3.sourceId);
            if (t3 && t3.vectorLayerIds)
              for (const e4 in this._layers) {
                const i3 = this._layers[e4];
                i3.source === t3.id && this._validateLayer(i3);
              }
          });
        }
        loadURL(e2, t2 = {}) {
          this.fire(new Event("dataloading", { dataType: "style" }));
          const i2 = "boolean" == typeof t2.validate ? t2.validate : !Te(e2);
          e2 = this.map._requestManager.normalizeStyleURL(e2, t2.accessToken);
          const r2 = this.map._requestManager.transformRequest(e2, pe.Style);
          this._request = me(r2, (e3, t3) => {
            this._request = null, e3 ? this.fire(new ErrorEvent(e3)) : t3 && this._load(t3, i2);
          });
        }
        loadJSON(e2, t2 = {}) {
          this.fire(new Event("dataloading", { dataType: "style" })), this._request = Je.frame(() => {
            this._request = null, this._load(e2, false !== t2.validate);
          });
        }
        loadEmpty() {
          this.fire(new Event("dataloading", { dataType: "style" })), this._load(hd, false);
        }
        _updateLayerCount(e2, t2) {
          const i2 = t2 ? 1 : -1;
          e2.is3D() && (this._num3DLayers += i2), "circle" === e2.type && (this._numCircleLayers += i2), "symbol" === e2.type && (this._numSymbolLayers += i2);
        }
        _load(e2, t2) {
          if (t2 && ld(this, xn(e2)))
            return;
          this._loaded = true, this.stylesheet = N(e2), this._updateMapProjection();
          for (const t3 in e2.sources)
            this.addSource(t3, e2.sources[t3], { validate: false });
          this._changed = false, e2.sprite ? this._loadSprite(e2.sprite) : (this.imageManager.setLoaded(true), this.dispatcher.broadcast("spriteLoaded", true)), this.glyphManager.setURL(e2.glyphs);
          const i2 = bp(this.stylesheet.layers);
          this._order = i2.map((e3) => e3.id), this._layers = {}, this._serializedLayers = {};
          for (let e3 of i2)
            e3 = xh(e3), e3.setEventedParent(this, { layer: { id: e3.id } }), this._layers[e3.id] = e3, this._serializedLayers[e3.id] = e3.serialize(), this._updateLayerCount(e3, true);
          this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new Light(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new Event("data", { dataType: "style" })), this.fire(new Event("style.load"));
        }
        terrainSetForDrapingOnly() {
          return !!this.terrain && 0 === this.terrain.drapeRenderMode;
        }
        setProjection(e2) {
          e2 ? this.stylesheet.projection = e2 : delete this.stylesheet.projection, this._updateMapProjection();
        }
        applyProjectionUpdate() {
          this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
        }
        _updateMapProjection() {
          this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
        }
        _loadSprite(e2) {
          this._spriteRequest = function(e3, t2, i2) {
            let r2, n2, o2;
            const s2 = Je.devicePixelRatio > 1 ? "@2x" : "";
            let a2 = me(t2.transformRequest(t2.normalizeSpriteURL(e3, s2, ".json"), pe.SpriteJSON), (e4, t3) => {
              a2 = null, o2 || (o2 = e4, r2 = t3, c2());
            }), l2 = be(t2.transformRequest(t2.normalizeSpriteURL(e3, s2, ".png"), pe.SpriteImage), (e4, t3) => {
              l2 = null, o2 || (o2 = e4, n2 = t3, c2());
            });
            function c2() {
              if (o2)
                i2(o2);
              else if (r2 && n2) {
                const e4 = Je.getImageData(n2), t3 = {};
                for (const i3 in r2) {
                  const { width: n3, height: o3, x: s3, y: a3, sdf: l3, pixelRatio: c3, stretchX: u2, stretchY: h2, content: p2 } = r2[i3], d2 = new RGBAImage({ width: n3, height: o3 });
                  RGBAImage.copy(e4, d2, { x: s3, y: a3 }, { x: 0, y: 0 }, { width: n3, height: o3 }), t3[i3] = { data: d2, pixelRatio: c3, sdf: l3, stretchX: u2, stretchY: h2, content: p2 };
                }
                i2(null, t3);
              }
            }
            return { cancel() {
              a2 && (a2.cancel(), a2 = null), l2 && (l2.cancel(), l2 = null);
            } };
          }(e2, this.map._requestManager, (e3, t2) => {
            if (this._spriteRequest = null, e3)
              this.fire(new ErrorEvent(e3));
            else if (t2)
              for (const e4 in t2)
                this.imageManager.addImage(e4, t2[e4]);
            this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", true), this.fire(new Event("data", { dataType: "style" }));
          });
        }
        _validateLayer(e2) {
          const t2 = this.getSource(e2.source);
          if (!t2)
            return;
          const i2 = e2.sourceLayer;
          i2 && ("geojson" === t2.type || t2.vectorLayerIds && -1 === t2.vectorLayerIds.indexOf(i2)) && this.fire(new ErrorEvent(new Error(`Source layer "${i2}" does not exist on source "${t2.id}" as specified by style layer "${e2.id}"`)));
        }
        loaded() {
          if (!this._loaded)
            return false;
          if (Object.keys(this._updatedSources).length)
            return false;
          for (const e2 in this._sourceCaches)
            if (!this._sourceCaches[e2].loaded())
              return false;
          return !!this.imageManager.isLoaded();
        }
        _serializeLayers(e2) {
          const t2 = [];
          for (const i2 of e2) {
            const e3 = this._layers[i2];
            "custom" !== e3.type && t2.push(e3.serialize());
          }
          return t2;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition())
            return true;
          if (this.fog && this.fog.hasTransition())
            return true;
          for (const e2 in this._sourceCaches)
            if (this._sourceCaches[e2].hasTransition())
              return true;
          for (const e2 in this._layers)
            if (this._layers[e2].hasTransition())
              return true;
          return false;
        }
        get order() {
          return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
        }
        isLayerDraped(e2) {
          return !!this.terrain && pd[e2.type];
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }
        update(e2) {
          if (!this._loaded)
            return;
          const t2 = this._changed;
          if (this._changed) {
            const t3 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
            (t3.length || i3.length) && this._updateWorkerLayers(t3, i3);
            for (const e3 in this._updatedSources) {
              const t4 = this._updatedSources[e3];
              "reload" === t4 ? this._reloadSource(e3) : "clear" === t4 && this._clearSource(e3);
            }
            this._updateTilesForChangedImages();
            for (const t4 in this._updatedPaintProps)
              this._layers[t4].updateTransitions(e2);
            this.light.updateTransitions(e2), this.fog && this.fog.updateTransitions(e2), this._resetUpdates();
          }
          const i2 = {};
          for (const e3 in this._sourceCaches) {
            const t3 = this._sourceCaches[e3];
            i2[e3] = t3.used, t3.used = false;
          }
          for (const t3 of this._order) {
            const i3 = this._layers[t3];
            if (i3.recalculate(e2, this._availableImages), !i3.isHidden(e2.zoom)) {
              const e3 = this._getLayerSourceCache(i3);
              e3 && (e3.used = true);
            }
            const r2 = this.map.painter;
            if (r2) {
              const t4 = i3.getProgramIds();
              if (!t4)
                continue;
              const n2 = i3.getProgramConfiguration(e2.zoom);
              for (const e3 of t4)
                r2.useProgram(e3, n2);
            }
          }
          for (const e3 in i2) {
            const t3 = this._sourceCaches[e3];
            i2[e3] !== t3.used && t3.getSource().fire(new Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: t3.getSource().id }));
          }
          this.light.recalculate(e2), this.terrain && this.terrain.recalculate(e2), this.fog && this.fog.recalculate(e2), this.z = e2.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), t2 && this.fire(new Event("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const e2 = Object.keys(this._changedImages);
          if (e2.length) {
            for (const t2 in this._sourceCaches)
              this._sourceCaches[t2].reloadTilesForDependencies(["icons", "patterns"], e2);
            this._changedImages = {};
          }
        }
        _updateWorkerLayers(e2, t2) {
          this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(e2), removedIds: t2 });
        }
        _resetUpdates() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
        }
        setState(e2) {
          if (this._checkLoaded(), ld(this, xn(e2)))
            return false;
          (e2 = N(e2)).layers = bp(e2.layers);
          const t2 = function(e3, t3) {
            if (!e3)
              return [{ command: wp.setStyle, args: [t3] }];
            let i3 = [];
            try {
              if (!m(e3.version, t3.version))
                return [{ command: wp.setStyle, args: [t3] }];
              m(e3.center, t3.center) || i3.push({ command: wp.setCenter, args: [t3.center] }), m(e3.zoom, t3.zoom) || i3.push({ command: wp.setZoom, args: [t3.zoom] }), m(e3.bearing, t3.bearing) || i3.push({ command: wp.setBearing, args: [t3.bearing] }), m(e3.pitch, t3.pitch) || i3.push({ command: wp.setPitch, args: [t3.pitch] }), m(e3.sprite, t3.sprite) || i3.push({ command: wp.setSprite, args: [t3.sprite] }), m(e3.glyphs, t3.glyphs) || i3.push({ command: wp.setGlyphs, args: [t3.glyphs] }), m(e3.transition, t3.transition) || i3.push({ command: wp.setTransition, args: [t3.transition] }), m(e3.light, t3.light) || i3.push({ command: wp.setLight, args: [t3.light] }), m(e3.fog, t3.fog) || i3.push({ command: wp.setFog, args: [t3.fog] }), m(e3.projection, t3.projection) || i3.push({ command: wp.setProjection, args: [t3.projection] });
              const r2 = {}, n2 = [];
              !function(e4, t4, i4, r3) {
                let n3;
                for (n3 in t4 = t4 || {}, e4 = e4 || {})
                  e4.hasOwnProperty(n3) && (t4.hasOwnProperty(n3) || Ep(n3, i4, r3));
                for (n3 in t4)
                  t4.hasOwnProperty(n3) && (e4.hasOwnProperty(n3) ? m(e4[n3], t4[n3]) || ("geojson" === e4[n3].type && "geojson" === t4[n3].type && Ap(e4, t4, n3) ? i4.push({ command: wp.setGeoJSONSourceData, args: [n3, t4[n3].data] }) : Sp(n3, t4, i4, r3)) : Tp(n3, t4, i4));
              }(e3.sources, t3.sources, n2, r2);
              const o2 = [];
              e3.layers && e3.layers.forEach((e4) => {
                e4.source && r2[e4.source] ? i3.push({ command: wp.removeLayer, args: [e4.id] }) : o2.push(e4);
              });
              let s2 = e3.terrain;
              s2 && r2[s2.source] && (i3.push({ command: wp.setTerrain, args: [void 0] }), s2 = void 0), i3 = i3.concat(n2), m(s2, t3.terrain) || i3.push({ command: wp.setTerrain, args: [t3.terrain] }), function(e4, t4, i4) {
                t4 = t4 || [];
                const r3 = (e4 = e4 || []).map(Ip), n3 = t4.map(Ip), o3 = e4.reduce(Mp, {}), s3 = t4.reduce(Mp, {}), a2 = r3.slice(), l2 = /* @__PURE__ */ Object.create(null);
                let c2, u2, h2, p2, d2, f2, _2;
                for (c2 = 0, u2 = 0; c2 < r3.length; c2++)
                  h2 = r3[c2], s3.hasOwnProperty(h2) ? u2++ : (i4.push({ command: wp.removeLayer, args: [h2] }), a2.splice(a2.indexOf(h2, u2), 1));
                for (c2 = 0, u2 = 0; c2 < n3.length; c2++)
                  h2 = n3[n3.length - 1 - c2], a2[a2.length - 1 - c2] !== h2 && (o3.hasOwnProperty(h2) ? (i4.push({ command: wp.removeLayer, args: [h2] }), a2.splice(a2.lastIndexOf(h2, a2.length - u2), 1)) : u2++, f2 = a2[a2.length - c2], i4.push({ command: wp.addLayer, args: [s3[h2], f2] }), a2.splice(a2.length - c2, 0, h2), l2[h2] = true);
                for (c2 = 0; c2 < n3.length; c2++)
                  if (h2 = n3[c2], p2 = o3[h2], d2 = s3[h2], !l2[h2] && !m(p2, d2))
                    if (m(p2.source, d2.source) && m(p2["source-layer"], d2["source-layer"]) && m(p2.type, d2.type)) {
                      for (_2 in Cp(p2.layout, d2.layout, i4, h2, null, wp.setLayoutProperty), Cp(p2.paint, d2.paint, i4, h2, null, wp.setPaintProperty), m(p2.filter, d2.filter) || i4.push({ command: wp.setFilter, args: [h2, d2.filter] }), m(p2.minzoom, d2.minzoom) && m(p2.maxzoom, d2.maxzoom) || i4.push({ command: wp.setLayerZoomRange, args: [h2, d2.minzoom, d2.maxzoom] }), p2)
                        p2.hasOwnProperty(_2) && "layout" !== _2 && "paint" !== _2 && "filter" !== _2 && "metadata" !== _2 && "minzoom" !== _2 && "maxzoom" !== _2 && (0 === _2.indexOf("paint.") ? Cp(p2[_2], d2[_2], i4, h2, _2.slice(6), wp.setPaintProperty) : m(p2[_2], d2[_2]) || i4.push({ command: wp.setLayerProperty, args: [h2, _2, d2[_2]] }));
                      for (_2 in d2)
                        d2.hasOwnProperty(_2) && !p2.hasOwnProperty(_2) && "layout" !== _2 && "paint" !== _2 && "filter" !== _2 && "metadata" !== _2 && "minzoom" !== _2 && "maxzoom" !== _2 && (0 === _2.indexOf("paint.") ? Cp(p2[_2], d2[_2], i4, h2, _2.slice(6), wp.setPaintProperty) : m(p2[_2], d2[_2]) || i4.push({ command: wp.setLayerProperty, args: [h2, _2, d2[_2]] }));
                    } else
                      i4.push({ command: wp.removeLayer, args: [h2] }), f2 = a2[a2.lastIndexOf(h2) + 1], i4.push({ command: wp.addLayer, args: [d2, f2] });
              }(o2, t3.layers, i3);
            } catch (e4) {
              console.warn("Unable to compute style diff:", e4), i3 = [{ command: wp.setStyle, args: [t3] }];
            }
            return i3;
          }(this.serialize(), e2).filter((e3) => !(e3.command in ud));
          if (0 === t2.length)
            return false;
          const i2 = t2.filter((e3) => !(e3.command in cd));
          if (i2.length > 0)
            throw new Error(`Unimplemented: ${i2.map((e3) => e3.command).join(", ")}.`);
          return t2.forEach((e3) => {
            "setTransition" !== e3.command && "setProjection" !== e3.command && this[e3.command].apply(this, e3.args);
          }), this.stylesheet = e2, this._updateMapProjection(), true;
        }
        addImage(e2, t2) {
          return this.getImage(e2) ? this.fire(new ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(e2, t2), this._afterImageUpdated(e2), this);
        }
        updateImage(e2, t2) {
          this.imageManager.updateImage(e2, t2);
        }
        getImage(e2) {
          return this.imageManager.getImage(e2);
        }
        removeImage(e2) {
          return this.getImage(e2) ? (this.imageManager.removeImage(e2), this._afterImageUpdated(e2), this) : this.fire(new ErrorEvent(new Error("No image with this name exists.")));
        }
        _afterImageUpdated(e2) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[e2] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new Event("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this._availableImages.slice();
        }
        addSource(e2, t2, i2 = {}) {
          if (this._checkLoaded(), void 0 !== this.getSource(e2))
            throw new Error("There is already a source with this ID");
          if (!t2.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(t2).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(t2.type) >= 0 && this._validate(vn, `sources.${e2}`, t2, null, i2))
            return;
          this.map && this.map._collectResourceTiming && (t2.collectResourceTiming = true);
          const r2 = up(e2, t2, this.dispatcher, this);
          r2.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(e2), source: r2.serialize(), sourceId: e2 }));
          const n2 = (t3) => {
            const i3 = (t3 ? "symbol:" : "other:") + e2, n3 = this._sourceCaches[i3] = new SourceCache(i3, r2, t3);
            (t3 ? this._symbolSourceCaches : this._otherSourceCaches)[e2] = n3, n3.style = this, n3.onAdd(this.map);
          };
          n2(false), "vector" !== t2.type && "geojson" !== t2.type || n2(true), r2.onAdd && r2.onAdd(this.map), this._changed = true;
        }
        removeSource(e2) {
          this._checkLoaded();
          const t2 = this.getSource(e2);
          if (!t2)
            throw new Error("There is no source with this ID");
          for (const t3 in this._layers)
            if (this._layers[t3].source === e2)
              return this.fire(new ErrorEvent(new Error(`Source "${e2}" cannot be removed while layer "${t3}" is using it.`)));
          if (this.terrain && this.terrain.get().source === e2)
            return this.fire(new ErrorEvent(new Error(`Source "${e2}" cannot be removed while terrain is using it.`)));
          const i2 = this._getSourceCaches(e2);
          for (const e3 of i2)
            delete this._sourceCaches[e3.id], delete this._updatedSources[e3.id], e3.fire(new Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e3.getSource().id })), e3.setEventedParent(null), e3.clearTiles();
          return delete this._otherSourceCaches[e2], delete this._symbolSourceCaches[e2], t2.setEventedParent(null), t2.onRemove && t2.onRemove(this.map), this._changed = true, this;
        }
        setGeoJSONSourceData(e2, t2) {
          this._checkLoaded(), this.getSource(e2).setData(t2), this._changed = true;
        }
        getSource(e2) {
          const t2 = this._getSourceCache(e2);
          return t2 && t2.getSource();
        }
        _getSources() {
          const e2 = [];
          for (const t2 in this._otherSourceCaches) {
            const i2 = this._getSourceCache(t2);
            i2 && e2.push(i2.getSource());
          }
          return e2;
        }
        addLayer(e2, t2, i2 = {}) {
          this._checkLoaded();
          const r2 = e2.id;
          if (this.getLayer(r2))
            return void this.fire(new ErrorEvent(new Error(`Layer with id "${r2}" already exists on this map`)));
          let n2;
          if ("custom" === e2.type) {
            if (ld(this, function(e3) {
              const t3 = [], i3 = e3.id;
              return void 0 === i3 && t3.push({ message: `layers.${i3}: missing required property "id"` }), void 0 === e3.render && t3.push({ message: `layers.${i3}: missing required method "render"` }), e3.renderingMode && "2d" !== e3.renderingMode && "3d" !== e3.renderingMode && t3.push({ message: `layers.${i3}: property "renderingMode" must be either "2d" or "3d"` }), t3;
            }(e2)))
              return;
            n2 = xh(e2);
          } else {
            if ("object" == typeof e2.source && (this.addSource(r2, e2.source), e2 = P(e2 = N(e2), { source: r2 })), this._validate(En, `layers.${r2}`, e2, { arrayIndex: -1 }, i2))
              return;
            n2 = xh(e2), this._validateLayer(n2), n2.setEventedParent(this, { layer: { id: r2 } }), this._serializedLayers[n2.id] = n2.serialize(), this._updateLayerCount(n2, true);
          }
          const o2 = t2 ? this._order.indexOf(t2) : this._order.length;
          if (t2 && -1 === o2)
            return void this.fire(new ErrorEvent(new Error(`Layer with id "${t2}" does not exist on this map.`)));
          this._order.splice(o2, 0, r2), this._layerOrderChanged = true, this._layers[r2] = n2;
          const s2 = this._getLayerSourceCache(n2);
          if (this._removedLayers[r2] && n2.source && s2 && "custom" !== n2.type) {
            const e3 = this._removedLayers[r2];
            delete this._removedLayers[r2], e3.type !== n2.type ? this._updatedSources[n2.source] = "clear" : (this._updatedSources[n2.source] = "reload", s2.pause());
          }
          this._updateLayer(n2), n2.onAdd && n2.onAdd(this.map), this._updateDrapeFirstLayers();
        }
        moveLayer(e2, t2) {
          if (this._checkLoaded(), this._changed = true, !this._layers[e2])
            return void this.fire(new ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot be moved.`)));
          if (e2 === t2)
            return;
          const i2 = this._order.indexOf(e2);
          this._order.splice(i2, 1);
          const r2 = t2 ? this._order.indexOf(t2) : this._order.length;
          t2 && -1 === r2 ? this.fire(new ErrorEvent(new Error(`Layer with id "${t2}" does not exist on this map.`))) : (this._order.splice(r2, 0, e2), this._layerOrderChanged = true, this._updateDrapeFirstLayers());
        }
        removeLayer(e2) {
          this._checkLoaded();
          const t2 = this._layers[e2];
          if (!t2)
            return void this.fire(new ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot be removed.`)));
          t2.setEventedParent(null), this._updateLayerCount(t2, false);
          const i2 = this._order.indexOf(e2);
          this._order.splice(i2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e2] = t2, delete this._layers[e2], delete this._serializedLayers[e2], delete this._updatedLayers[e2], delete this._updatedPaintProps[e2], t2.onRemove && t2.onRemove(this.map), this._updateDrapeFirstLayers();
        }
        getLayer(e2) {
          return this._layers[e2];
        }
        hasLayer(e2) {
          return e2 in this._layers;
        }
        hasLayerType(e2) {
          for (const t2 in this._layers)
            if (this._layers[t2].type === e2)
              return true;
          return false;
        }
        setLayerZoomRange(e2, t2, i2) {
          this._checkLoaded();
          const r2 = this.getLayer(e2);
          r2 ? r2.minzoom === t2 && r2.maxzoom === i2 || (null != t2 && (r2.minzoom = t2), null != i2 && (r2.maxzoom = i2), this._updateLayer(r2)) : this.fire(new ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot have zoom extent.`)));
        }
        setFilter(e2, t2, i2 = {}) {
          this._checkLoaded();
          const r2 = this.getLayer(e2);
          if (r2) {
            if (!m(r2.filter, t2))
              return null == t2 ? (r2.filter = void 0, void this._updateLayer(r2)) : void (this._validate(Sn, `layers.${r2.id}.filter`, t2, { layerType: r2.type }, i2) || (r2.filter = N(t2), this._updateLayer(r2)));
          } else
            this.fire(new ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot be filtered.`)));
        }
        getFilter(e2) {
          const t2 = this.getLayer(e2);
          return t2 && N(t2.filter);
        }
        setLayoutProperty(e2, t2, i2, r2 = {}) {
          this._checkLoaded();
          const n2 = this.getLayer(e2);
          n2 ? m(n2.getLayoutProperty(t2), i2) || (n2.setLayoutProperty(t2, i2, r2), this._updateLayer(n2)) : this.fire(new ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot be styled.`)));
        }
        getLayoutProperty(e2, t2) {
          const i2 = this.getLayer(e2);
          if (i2)
            return i2.getLayoutProperty(t2);
          this.fire(new ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style.`)));
        }
        setPaintProperty(e2, t2, i2, r2 = {}) {
          this._checkLoaded();
          const n2 = this.getLayer(e2);
          n2 ? m(n2.getPaintProperty(t2), i2) || (n2.setPaintProperty(t2, i2, r2) && this._updateLayer(n2), this._changed = true, this._updatedPaintProps[e2] = true) : this.fire(new ErrorEvent(new Error(`The layer '${e2}' does not exist in the map's style and cannot be styled.`)));
        }
        getPaintProperty(e2, t2) {
          const i2 = this.getLayer(e2);
          return i2 && i2.getPaintProperty(t2);
        }
        setFeatureState(e2, t2) {
          this._checkLoaded();
          const i2 = e2.source, r2 = e2.sourceLayer, n2 = this.getSource(i2);
          if (!n2)
            return void this.fire(new ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
          const o2 = n2.type;
          if ("geojson" === o2 && r2)
            return void this.fire(new ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
          if ("vector" === o2 && !r2)
            return void this.fire(new ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          void 0 === e2.id && this.fire(new ErrorEvent(new Error("The feature id parameter must be provided.")));
          const s2 = this._getSourceCaches(i2);
          for (const i3 of s2)
            i3.setFeatureState(r2, e2.id, t2);
        }
        removeFeatureState(e2, t2) {
          this._checkLoaded();
          const i2 = e2.source, r2 = this.getSource(i2);
          if (!r2)
            return void this.fire(new ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
          const n2 = r2.type, o2 = "vector" === n2 ? e2.sourceLayer : void 0;
          if ("vector" === n2 && !o2)
            return void this.fire(new ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          if (t2 && "string" != typeof e2.id && "number" != typeof e2.id)
            return void this.fire(new ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
          const s2 = this._getSourceCaches(i2);
          for (const i3 of s2)
            i3.removeFeatureState(o2, e2.id, t2);
        }
        getFeatureState(e2) {
          this._checkLoaded();
          const t2 = e2.source, i2 = e2.sourceLayer, r2 = this.getSource(t2);
          if (r2) {
            if ("vector" !== r2.type || i2)
              return void 0 === e2.id && this.fire(new ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(t2)[0].getFeatureState(i2, e2.id);
            this.fire(new ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new ErrorEvent(new Error(`The source '${t2}' does not exist in the map's style.`)));
        }
        getTransition() {
          return P({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          const e2 = {};
          for (const t2 in this._sourceCaches) {
            const i2 = this._sourceCaches[t2].getSource();
            e2[i2.id] || (e2[i2.id] = i2.serialize());
          }
          return j({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.getTerrain() || void 0, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: e2, layers: this._serializeLayers(this._order) }, (e3) => void 0 !== e3);
        }
        _updateLayer(e2) {
          this._updatedLayers[e2.id] = true;
          const t2 = this._getLayerSourceCache(e2);
          e2.source && !this._updatedSources[e2.source] && t2 && "raster" !== t2.getSource().type && (this._updatedSources[e2.source] = "reload", t2.pause()), this._changed = true, e2.invalidateCompiledFilter();
        }
        _flattenAndSortRenderedFeatures(e2) {
          const t2 = (e3) => "fill-extrusion" === this._layers[e3].type, i2 = {}, r2 = [];
          for (let n3 = this._order.length - 1; n3 >= 0; n3--) {
            const o2 = this._order[n3];
            if (t2(o2)) {
              i2[o2] = n3;
              for (const t3 of e2) {
                const e3 = t3[o2];
                if (e3)
                  for (const t4 of e3)
                    r2.push(t4);
              }
            }
          }
          r2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
          const n2 = [];
          for (let o2 = this._order.length - 1; o2 >= 0; o2--) {
            const s2 = this._order[o2];
            if (t2(s2))
              for (let e3 = r2.length - 1; e3 >= 0; e3--) {
                const t3 = r2[e3].feature;
                if (i2[t3.layer.id] < o2)
                  break;
                n2.push(t3), r2.pop();
              }
            else
              for (const t3 of e2) {
                const e3 = t3[s2];
                if (e3)
                  for (const t4 of e3)
                    n2.push(t4.feature);
              }
          }
          return n2;
        }
        queryRenderedFeatures(e2, t2, i2) {
          t2 && t2.filter && this._validate(Sn, "queryRenderedFeatures.filter", t2.filter, null, t2);
          const r2 = {};
          if (t2 && t2.layers) {
            if (!Array.isArray(t2.layers))
              return this.fire(new ErrorEvent(new Error("parameters.layers must be an Array."))), [];
            for (const e3 of t2.layers) {
              const t3 = this._layers[e3];
              if (!t3)
                return this.fire(new ErrorEvent(new Error(`The layer '${e3}' does not exist in the map's style and cannot be queried for features.`))), [];
              r2[t3.source] = true;
            }
          }
          const n2 = [];
          t2.availableImages = this._availableImages;
          const o2 = t2 && t2.layers ? t2.layers.some((e3) => {
            const t3 = this.getLayer(e3);
            return t3 && t3.is3D();
          }) : this.has3DLayers(), s2 = QueryGeometry.createFromScreenPoints(e2, i2);
          for (const e3 in this._sourceCaches) {
            const a2 = this._sourceCaches[e3].getSource().id;
            t2.layers && !r2[a2] || n2.push(pp(this._sourceCaches[e3], this._layers, this._serializedLayers, s2, t2, i2, o2, !!this.map._showQueryGeometry));
          }
          return this.placement && n2.push(function(e3, t3, i3, r3, n3, o3, s3) {
            const a2 = {}, l2 = o3.queryRenderedSymbols(r3), c2 = [];
            for (const e4 of Object.keys(l2).map(Number))
              c2.push(s3[e4]);
            c2.sort(fp);
            for (const i4 of c2) {
              const r4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], t3, i4.bucketIndex, i4.sourceLayerIndex, n3.filter, n3.layers, n3.availableImages, e3);
              for (const e4 in r4) {
                const t4 = a2[e4] = a2[e4] || [], n4 = r4[e4];
                n4.sort((e5, t5) => {
                  const r5 = i4.featureSortOrder;
                  if (r5) {
                    const i5 = r5.indexOf(e5.featureIndex);
                    return r5.indexOf(t5.featureIndex) - i5;
                  }
                  return t5.featureIndex - e5.featureIndex;
                });
                for (const e5 of n4)
                  t4.push(e5);
              }
            }
            for (const t4 in a2)
              a2[t4].forEach((r4) => {
                const n4 = r4.feature, o4 = i3(e3[t4]).getFeatureState(n4.layer["source-layer"], n4.id);
                n4.source = n4.layer.source, n4.layer["source-layer"] && (n4.sourceLayer = n4.layer["source-layer"]), n4.state = o4;
              });
            return a2;
          }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), s2.screenGeometry, t2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n2);
        }
        querySourceFeatures(e2, t2) {
          t2 && t2.filter && this._validate(Sn, "querySourceFeatures.filter", t2.filter, null, t2);
          const i2 = this._getSourceCaches(e2);
          let r2 = [];
          for (const e3 of i2)
            r2 = r2.concat(dp(e3, t2));
          return r2;
        }
        addSourceType(e2, t2, i2) {
          return Style.getSourceType(e2) ? i2(new Error(`A source type called "${e2}" already exists.`)) : (Style.setSourceType(e2, t2), t2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e2, url: t2.workerSourceURL }, i2) : i2(null, null));
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(e2, t2 = {}) {
          this._checkLoaded();
          const i2 = this.light.getLight();
          let r2 = false;
          for (const t3 in e2)
            if (!m(e2[t3], i2[t3])) {
              r2 = true;
              break;
            }
          if (!r2)
            return;
          const n2 = this._setTransitionParameters({ duration: 300, delay: 0 });
          this.light.setLight(e2, t2), this.light.updateTransitions(n2);
        }
        getTerrain() {
          return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
        }
        setTerrainForDraping() {
          this.setTerrain({ source: "", exaggeration: 0 }, 0);
        }
        setTerrain(e2, t2 = 1) {
          if (this._checkLoaded(), !e2)
            return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", false), this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
          if (1 === t2) {
            if ("object" == typeof e2.source) {
              const t3 = "terrain-dem-src";
              this.addSource(t3, e2.source), e2 = P(e2 = N(e2), { source: t3 });
            }
            if (this._validate(wn, "terrain", e2))
              return;
          }
          if (!this.terrain || this.terrain && t2 !== this.terrain.drapeRenderMode)
            this._createTerrain(e2, t2);
          else {
            const t3 = this.terrain, i2 = t3.get();
            for (const t4 of Object.keys(ft.terrain))
              !e2.hasOwnProperty(t4) && ft.terrain[t4].default && (e2[t4] = ft.terrain[t4].default);
            for (const r2 in e2)
              if (!m(e2[r2], i2[r2])) {
                t3.set(e2), this.stylesheet.terrain = e2;
                const i3 = this._setTransitionParameters({ duration: 0 });
                t3.updateTransitions(i3);
                break;
              }
          }
          this._updateDrapeFirstLayers(), this._markersNeedUpdate = true;
        }
        _createFog(e2) {
          const t2 = this.fog = new Fog(e2, this.map.transform);
          this.stylesheet.fog = e2;
          const i2 = this._setTransitionParameters({ duration: 0 });
          t2.updateTransitions(i2);
        }
        _updateMarkersOpacity() {
          0 !== this.map._markers.length && this.map._requestDomTask(() => {
            for (const e2 of this.map._markers)
              e2._evaluateOpacity();
          });
        }
        getFog() {
          return this.fog ? this.fog.get() : null;
        }
        setFog(e2) {
          if (this._checkLoaded(), !e2)
            return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
          if (this.fog) {
            const t2 = this.fog, i2 = t2.get();
            0 === Object.keys(e2).length && t2.set(e2);
            for (const r2 in e2)
              if (!m(e2[r2], i2[r2])) {
                t2.set(e2), this.stylesheet.fog = e2;
                const i3 = this._setTransitionParameters({ duration: 0 });
                t2.updateTransitions(i3);
                break;
              }
          } else
            this._createFog(e2);
          this._markersNeedUpdate = true;
        }
        _setTransitionParameters(e2) {
          return { now: Je.now(), transition: P(e2, this.stylesheet.transition) };
        }
        _updateDrapeFirstLayers() {
          if (!this.map._optimizeForTerrain || !this.terrain)
            return;
          const e2 = this._order.filter((e3) => this.isLayerDraped(this._layers[e3])), t2 = this._order.filter((e3) => !this.isLayerDraped(this._layers[e3]));
          this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e2), this._drapedFirstOrder.push(...t2);
        }
        _createTerrain(e2, t2) {
          const i2 = this.terrain = new Terrain$1(e2, t2);
          this.stylesheet.terrain = e2, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
          const r2 = this._setTransitionParameters({ duration: 0 });
          i2.updateTransitions(r2);
        }
        _force3DLayerUpdate() {
          for (const e2 in this._layers) {
            const t2 = this._layers[e2];
            "fill-extrusion" === t2.type && this._updateLayer(t2);
          }
        }
        _forceSymbolLayerUpdate() {
          for (const e2 in this._layers) {
            const t2 = this._layers[e2];
            "symbol" === t2.type && this._updateLayer(t2);
          }
        }
        _validate(e2, t2, i2, r2, n2 = {}) {
          return (!n2 || false !== n2.validate) && ld(this, e2.call(xn, P({ key: t2, style: this.serialize(), value: i2, styleSpec: ft }, r2)));
        }
        _remove() {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), ro.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const e2 in this._layers)
            this._layers[e2].setEventedParent(null);
          for (const e2 in this._sourceCaches)
            this._sourceCaches[e2].clearTiles(), this._sourceCaches[e2].setEventedParent(null);
          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
        }
        _clearSource(e2) {
          const t2 = this._getSourceCaches(e2);
          for (const e3 of t2)
            e3.clearTiles();
        }
        _reloadSource(e2) {
          const t2 = this._getSourceCaches(e2);
          for (const e3 of t2)
            e3.resume(), e3.reload();
        }
        _reloadSources() {
          for (const e2 of this._getSources())
            e2.reload && e2.reload();
        }
        _updateSources(e2) {
          for (const t2 in this._sourceCaches)
            this._sourceCaches[t2].update(e2);
        }
        _generateCollisionBoxes() {
          for (const e2 in this._sourceCaches) {
            const t2 = this._sourceCaches[e2];
            t2.resume(), t2.reload();
          }
        }
        _updatePlacement(e2, t2, i2, r2, n2 = false) {
          let o2 = false, s2 = false;
          const a2 = {};
          for (const t3 of this._order) {
            const i3 = this._layers[t3];
            if ("symbol" !== i3.type)
              continue;
            if (!a2[i3.source]) {
              const e3 = this._getLayerSourceCache(i3);
              if (!e3)
                continue;
              a2[i3.source] = e3.getRenderableIds(true).map((t4) => e3.getTileByID(t4)).sort((e4, t4) => t4.tileID.overscaledZ - e4.tileID.overscaledZ || (e4.tileID.isLessThan(t4.tileID) ? -1 : 1));
            }
            const r3 = this.crossTileSymbolIndex.addLayer(i3, a2[i3.source], e2.center.lng, e2.projection);
            o2 = o2 || r3;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n2 = n2 || this._layerOrderChanged || 0 === i2, this._layerOrderChanged && this.fire(new Event("neworder")), (n2 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(Je.now(), e2.zoom)) && (this.pauseablePlacement = new PauseablePlacement(e2, this._order, n2, t2, i2, r2, this.placement, this.fog && e2.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, a2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(Je.now()), s2 = true), o2 && this.pauseablePlacement.placement.setStale()), s2 || o2)
            for (const e3 of this._order) {
              const t3 = this._layers[e3];
              "symbol" === t3.type && this.placement.updateLayerOpacities(t3, a2[t3.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(Je.now());
        }
        _releaseSymbolFadeTiles() {
          for (const e2 in this._sourceCaches)
            this._sourceCaches[e2].releaseSymbolFadeTiles();
        }
        getImages(e2, t2, i2) {
          this.imageManager.getImages(t2.icons, i2), this._updateTilesForChangedImages();
          const r2 = (e3) => {
            e3 && e3.setDependencies(t2.tileID.key, t2.type, t2.icons);
          };
          r2(this._otherSourceCaches[t2.source]), r2(this._symbolSourceCaches[t2.source]);
        }
        getGlyphs(e2, t2, i2) {
          this.glyphManager.getGlyphs(t2.stacks, i2);
        }
        getResource(e2, t2, i2) {
          return fe(t2, i2);
        }
        _getSourceCache(e2) {
          return this._otherSourceCaches[e2];
        }
        _getLayerSourceCache(e2) {
          return "symbol" === e2.type ? this._symbolSourceCaches[e2.source] : this._otherSourceCaches[e2.source];
        }
        _getSourceCaches(e2) {
          const t2 = [];
          return this._otherSourceCaches[e2] && t2.push(this._otherSourceCaches[e2]), this._symbolSourceCaches[e2] && t2.push(this._symbolSourceCaches[e2]), t2;
        }
        _isSourceCacheLoaded(e2) {
          const t2 = this._getSourceCaches(e2);
          return 0 === t2.length ? (this.fire(new ErrorEvent(new Error(`There is no source with ID '${e2}'`))), false) : t2.every((e3) => e3.loaded());
        }
        has3DLayers() {
          return this._num3DLayers > 0;
        }
        hasSymbolLayers() {
          return this._numSymbolLayers > 0;
        }
        hasCircleLayers() {
          return this._numCircleLayers > 0;
        }
        _clearWorkerCaches() {
          this.dispatcher.broadcast("clearCaches");
        }
        destroy() {
          this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
        }
      }
      Style.getSourceType = function(e2) {
        return cp[e2];
      }, Style.setSourceType = function(e2, t2) {
        cp[e2] = t2;
      }, Style.registerForPluginStateChange = function(e2) {
        return e2({ pluginStatus: Qn, pluginURL: eo }), ro.on("pluginStateChange", e2), e2;
      };
      var dd = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0", fd = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", md = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", _d = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", gd = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
      let yd = {}, xd = {};
      const vd = [];
      Sd(dd, vd), Sd(md, vd), Sd(_d, vd), Sd(gd, vd), yd = Ad("", md), xd = Ad(gd, _d);
      const bd = Ad("\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), wd = dd, Td = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
      var Ed = { background: Ad("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), backgroundPattern: Ad("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), circle: Ad("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"), clippingMask: Ad("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Ad("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), heatmapTexture: Ad("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: Ad("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Ad("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Ad("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"), fill: Ad("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutline: Ad("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutlinePattern: Ad("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillPattern: Ad("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillExtrusion: Ad("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), fillExtrusionPattern: Ad("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"), hillshadePrepare: Ad("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ad("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), line: Ad("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), linePattern: Ad("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), raster: Ad("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), symbolIcon: Ad("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"), symbolSDF: Ad("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"), symbolTextAndIcon: Ad("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"), terrainRaster: Ad("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float skirtOffset=24575.0;const float wireframeOffset=0.00015;void main() {v_pos0=a_texture_pos/8192.0;float skirt=float(a_pos.x >=skirtOffset);float elevation=elevation(a_texture_pos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=u_skirt_height*u_skirt_height*wireframeOffset;\n#endif\nvec2 decodedPos=a_pos-vec2(skirt*skirtOffset,0.0);gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"), terrainDepth: Ad("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying float v_depth;void main() {float elevation=elevation(a_texture_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"), skybox: Ad("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", fd), skyboxGradient: Ad("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", fd), skyboxCapture: Ad("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: Ad("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 latLng=u_grid_matrix*vec3(a_pos,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;\n#ifdef GLOBE_POLES\nvec3 up_vector=normalize(globe_pos)*u_tile_up_scale;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"), globeAtmosphere: Ad("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}") };
      function Sd(e2, t2) {
        const i2 = e2.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
        for (let e3 of i2)
          if (e3 = e3.trim(), "#" === e3[0] && e3.includes("if") && !e3.includes("endif")) {
            e3 = e3.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
            const i3 = e3.split(" ");
            for (const e4 of i3)
              t2.includes(e4) || t2.push(e4);
          }
      }
      function Ad(e2, t2) {
        const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, r2 = t2.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), n2 = {}, o2 = [...vd];
        return Sd(e2, o2), Sd(t2, o2), { fragmentSource: e2 = e2.replace(i2, (e3, t3, i3, r3, o3) => (n2[o3] = true, "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${o3}
varying ${i3} ${r3} ${o3};
#else
uniform ${i3} ${r3} u_${o3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${o3}
    ${i3} ${r3} ${o3} = u_${o3};
#endif
`)), vertexSource: t2 = t2.replace(i2, (e3, t3, i3, r3, o3) => {
          const s2 = "float" === r3 ? "vec2" : "vec4", a2 = o3.match(/color/) ? "color" : s2;
          return n2[o3] ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${o3}
uniform lowp float u_${o3}_t;
attribute ${i3} ${s2} a_${o3};
varying ${i3} ${r3} ${o3};
#else
uniform ${i3} ${r3} u_${o3};
#endif
` : "vec4" === a2 ? `
#ifndef HAS_UNIFORM_u_${o3}
    ${o3} = a_${o3};
#else
    ${i3} ${r3} ${o3} = u_${o3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${o3}
    ${o3} = unpack_mix_${a2}(a_${o3}, u_${o3}_t);
#else
    ${i3} ${r3} ${o3} = u_${o3};
#endif
` : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${o3}
uniform lowp float u_${o3}_t;
attribute ${i3} ${s2} a_${o3};
#else
uniform ${i3} ${r3} u_${o3};
#endif
` : "vec4" === a2 ? `
#ifndef HAS_UNIFORM_u_${o3}
    ${i3} ${r3} ${o3} = a_${o3};
#else
    ${i3} ${r3} ${o3} = u_${o3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${o3}
    ${i3} ${r3} ${o3} = unpack_mix_${a2}(a_${o3}, u_${o3}_t);
#else
    ${i3} ${r3} ${o3} = u_${o3};
#endif
`;
        }), staticAttributes: r2, usedDefines: o2 };
      }
      class VertexArrayObject {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
        }
        bind(e2, t2, i2, r2, n2, o2, s2) {
          this.context = e2;
          let a2 = this.boundPaintVertexBuffers.length !== r2.length;
          for (let e3 = 0; !a2 && e3 < r2.length; e3++)
            this.boundPaintVertexBuffers[e3] !== r2[e3] && (a2 = true);
          let l2 = this.boundDynamicVertexBuffers.length !== s2.length;
          for (let e3 = 0; !l2 && e3 < s2.length; e3++)
            this.boundDynamicVertexBuffers[e3] !== s2[e3] && (l2 = true);
          if (!e2.extVertexArrayObject || !this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || a2 || l2 || this.boundIndexBuffer !== n2 || this.boundVertexOffset !== o2)
            this.freshBind(t2, i2, r2, n2, o2, s2);
          else {
            e2.bindVertexArrayOES.set(this.vao);
            for (const e3 of s2)
              e3 && e3.bind();
            n2 && n2.dynamicDraw && n2.bind();
          }
        }
        freshBind(e2, t2, i2, r2, n2, o2) {
          let s2;
          const a2 = e2.numAttributes, l2 = this.context, c2 = l2.gl;
          if (l2.extVertexArrayObject)
            this.vao && this.destroy(), this.vao = l2.extVertexArrayObject.createVertexArrayOES(), l2.bindVertexArrayOES.set(this.vao), s2 = 0, this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = r2, this.boundVertexOffset = n2, this.boundDynamicVertexBuffers = o2;
          else {
            s2 = l2.currentNumAttributes || 0;
            for (let e3 = a2; e3 < s2; e3++)
              c2.disableVertexAttribArray(e3);
          }
          t2.enableAttributes(c2, e2), t2.bind(), t2.setVertexAttribPointers(c2, e2, n2);
          for (const t3 of i2)
            t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, n2);
          for (const t3 of o2)
            t3 && (t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, n2));
          r2 && r2.bind(), l2.currentNumAttributes = a2;
        }
        destroy() {
          this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
        }
      }
      function Cd(e2, t2) {
        const i2 = Math.pow(2, t2.canonical.z), r2 = t2.canonical.y;
        return [new MercatorCoordinate(0, r2 / i2).toLngLat().lat, new MercatorCoordinate(0, (r2 + 1) / i2).toLngLat().lat];
      }
      function Id(e2, t2, i2, r2, n2, o2, s2) {
        const a2 = e2.context, l2 = a2.gl, c2 = i2.fbo;
        if (!c2)
          return;
        e2.prepareDrawTile();
        const u2 = e2.useProgram("hillshade");
        a2.activeTexture.set(l2.TEXTURE0), l2.bindTexture(l2.TEXTURE_2D, c2.colorAttachment.get());
        const h2 = ((e3, t3, i3, r3) => {
          const n3 = i3.paint.get("hillshade-shadow-color"), o3 = i3.paint.get("hillshade-highlight-color"), s3 = i3.paint.get("hillshade-accent-color");
          let a3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          "viewport" === i3.paint.get("hillshade-illumination-anchor") && (a3 -= e3.transform.angle);
          const l3 = !e3.options.moving;
          return { u_matrix: r3 || e3.transform.calculateProjMatrix(t3.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: Cd(0, t3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), a3], u_shadow: n3, u_highlight: o3, u_accent: s3 };
        })(e2, i2, r2, e2.terrain ? t2.projMatrix : null);
        e2.prepareDrawProgram(a2, u2, t2.toUnwrapped());
        const { tileBoundsBuffer: p2, tileBoundsIndexBuffer: d2, tileBoundsSegments: f2 } = e2.getTileBoundsBuffers(i2);
        u2.draw(a2, l2.TRIANGLES, n2, o2, s2, CullFaceMode.disabled, h2, r2.id, p2, d2, f2);
      }
      function Md(e2, t2, i2) {
        if (!t2.needsDEMTextureUpload)
          return;
        const r2 = e2.context, n2 = r2.gl;
        r2.pixelStoreUnpackPremultiplyAlpha.set(false), t2.demTexture = t2.demTexture || e2.getTileTexture(i2.stride);
        const o2 = i2.getPixels();
        t2.demTexture ? t2.demTexture.update(o2, { premultiply: false }) : t2.demTexture = new Texture(r2, o2, n2.RGBA, { premultiply: false }), t2.needsDEMTextureUpload = false;
      }
      function Dd(e2, t2, i2, r2, n2, o2) {
        const s2 = e2.context, a2 = s2.gl;
        if (!t2.dem)
          return;
        const l2 = t2.dem;
        if (s2.activeTexture.set(a2.TEXTURE1), Md(e2, t2, l2), !t2.demTexture)
          return;
        t2.demTexture.bind(a2.NEAREST, a2.CLAMP_TO_EDGE);
        const c2 = l2.dim;
        s2.activeTexture.set(a2.TEXTURE0);
        let u2 = t2.fbo;
        if (!u2) {
          const e3 = new Texture(s2, { width: c2, height: c2, data: null }, a2.RGBA);
          e3.bind(a2.LINEAR, a2.CLAMP_TO_EDGE), u2 = t2.fbo = s2.createFramebuffer(c2, c2, true), u2.colorAttachment.set(e3.texture);
        }
        s2.bindFramebuffer.set(u2.framebuffer), s2.viewport.set([0, 0, c2, c2]);
        const { tileBoundsBuffer: h2, tileBoundsIndexBuffer: p2, tileBoundsSegments: d2 } = e2.getMercatorTileBoundsBuffers();
        e2.useProgram("hillshadePrepare").draw(s2, a2.TRIANGLES, r2, n2, o2, CullFaceMode.disabled, ((e3, t3) => {
          const i3 = t3.stride, r3 = Cs();
          return Vs(r3, 0, ko, -8192, 0, 0, 1), Ps(r3, r3, [0, -8192, 0]), { u_matrix: r3, u_image: 1, u_dimension: [i3, i3], u_zoom: e3.overscaledZ, u_unpack: t3.unpackVector };
        })(t2.tileID, l2), i2.id, h2, p2, d2), t2.needsHillshadePrepare = false;
      }
      const Pd = (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_image0: new Uniform1i(e2), u_skirt_height: new Uniform1f(e2) }), zd = (e2, t2) => ({ u_matrix: e2, u_image0: 0, u_skirt_height: t2 }), Ld = (e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2) => ({ u_proj_matrix: Float32Array.from(e2), u_globe_matrix: t2, u_normalize_matrix: Float32Array.from(r2), u_merc_matrix: i2, u_zoom_transition: n2, u_merc_center: o2, u_image0: 0, u_frustum_tl: s2, u_frustum_tr: a2, u_frustum_br: l2, u_frustum_bl: c2, u_globe_pos: u2, u_globe_radius: h2, u_viewport: p2, u_grid_matrix: d2 ? Float32Array.from(d2) : new Float32Array(9) });
      function kd(e2, t2) {
        return null != e2 && null != t2 && !(!e2.hasData() || !t2.hasData()) && null != e2.demTexture && null != t2.demTexture && e2.tileID.key !== t2.tileID.key;
      }
      const Bd = new class VertexMorphing {
        constructor() {
          this.operations = {};
        }
        newMorphing(e2, t2, i2, r2, n2) {
          if (e2 in this.operations) {
            const t3 = this.operations[e2];
            t3.to.tileID.key !== i2.tileID.key && (t3.queued = i2);
          } else
            this.operations[e2] = { startTime: r2, phase: 0, duration: n2, from: t2, to: i2, queued: null };
        }
        getMorphValuesForProxy(e2) {
          if (!(e2 in this.operations))
            return null;
          const t2 = this.operations[e2];
          return { from: t2.from, to: t2.to, phase: t2.phase };
        }
        update(e2) {
          for (const t2 in this.operations) {
            const i2 = this.operations[t2];
            for (i2.phase = (e2 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); )
              if (!this._nextOp(i2, e2)) {
                delete this.operations[t2];
                break;
              }
          }
        }
        _nextOp(e2, t2) {
          return !!e2.queued && (e2.from = e2.to, e2.to = e2.queued, e2.queued = null, e2.phase = 0, e2.startTime = t2, true);
        }
        _validOp(e2) {
          return e2.from.hasData() && e2.to.hasData();
        }
      }(), Rd = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" };
      function Fd(e2, t2) {
        const i2 = 1 << e2.z;
        return !t2 && (0 === e2.x || e2.x === i2 - 1) || 0 === e2.y || e2.y === i2 - 1;
      }
      const Od = (e2) => ({ u_matrix: e2 });
      function Ud(e2, t2, i2, r2, n2) {
        if (n2 > 0) {
          const o2 = Je.now(), s2 = (o2 - e2.timeAdded) / n2, a2 = t2 ? (o2 - t2.timeAdded) / n2 : -1, l2 = i2.getSource(), c2 = r2.coveringZoomLevel({ tileSize: l2.tileSize, roundZoom: l2.roundZoom }), u2 = !t2 || Math.abs(t2.tileID.overscaledZ - c2) > Math.abs(e2.tileID.overscaledZ - c2), h2 = u2 && e2.refreshedUponExpiration ? 1 : A(u2 ? s2 : 1 - a2, 0, 1);
          return e2.refreshedUponExpiration && s2 >= 1 && (e2.refreshedUponExpiration = false), t2 ? { opacity: 1, mix: 1 - h2 } : { opacity: h2, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      class MockSourceCache extends SourceCache {
        constructor(e2) {
          const t2 = { type: "raster-dem", maxzoom: e2.transform.maxZoom }, i2 = new Dispatcher(yp(), null), r2 = up("mock-dem", t2, i2, e2.style);
          super("mock-dem", r2, false), r2.setEventedParent(this), this._sourceLoaded = true;
        }
        _loadTile(e2, t2) {
          e2.state = "loaded", t2(null);
        }
      }
      class ProxySourceCache extends SourceCache {
        constructor(e2) {
          const t2 = up("proxy", { type: "geojson", maxzoom: e2.transform.maxZoom }, new Dispatcher(yp(), null), e2.style);
          super("proxy", t2, false), t2.setEventedParent(this), this.map = this.getSource().map = e2, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
        update(e2, t2, i2) {
          if (e2.freezeTileCoverage)
            return;
          this.transform = e2;
          const r2 = e2.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((t3, i3) => {
            if (t3[i3.key] = "", !this._tiles[i3.key]) {
              const t4 = new Tile(i3, this._source.tileSize * i3.overscaleFactor(), e2.tileZoom);
              t4.state = "loaded", this._tiles[i3.key] = t4;
            }
            return t3;
          }, {});
          for (const e3 in this._tiles)
            e3 in r2 || (this.freeFBO(e3), this._tiles[e3].unloadVectorData(), delete this._tiles[e3]);
        }
        freeFBO(e2) {
          const t2 = this.proxyCachedFBO[e2];
          if (void 0 !== t2) {
            const i2 = Object.values(t2);
            this.renderCachePool.push(...i2), delete this.proxyCachedFBO[e2];
          }
        }
        deallocRenderCache() {
          this.renderCache.forEach((e2) => e2.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
      }
      class ProxiedTileID extends OverscaledTileID {
        constructor(e2, t2, i2) {
          super(e2.overscaledZ, e2.wrap, e2.canonical.z, e2.canonical.x, e2.canonical.y), this.proxyTileKey = t2, this.projMatrix = i2;
        }
      }
      class Terrain extends class Elevation {
        isDataAvailableAtPoint(e2) {
          const t2 = this._source();
          if (this.isUsingMockSource() || !t2 || e2.y < 0 || e2.y > 1)
            return false;
          const i2 = t2.getSource().maxzoom, r2 = 1 << i2, n2 = Math.floor(e2.x), o2 = Math.floor((e2.x - n2) * r2), s2 = Math.floor(e2.y * r2), a2 = this.findDEMTileFor(new OverscaledTileID(i2, n2, i2, o2, s2));
          return !(!a2 || !a2.dem);
        }
        getAtPointOrZero(e2, t2 = 0) {
          return this.getAtPoint(e2, t2) || 0;
        }
        getAtPoint(e2, t2, i2 = true) {
          if (this.isUsingMockSource())
            return null;
          null == t2 && (t2 = null);
          const r2 = this._source();
          if (!r2)
            return t2;
          if (e2.y < 0 || e2.y > 1)
            return t2;
          const n2 = r2.getSource().maxzoom, o2 = 1 << n2, s2 = Math.floor(e2.x), a2 = e2.x - s2, l2 = new OverscaledTileID(n2, s2, n2, Math.floor(a2 * o2), Math.floor(e2.y * o2)), c2 = this.findDEMTileFor(l2);
          if (!c2 || !c2.dem)
            return t2;
          const u2 = c2.dem, h2 = 1 << c2.tileID.canonical.z, p2 = (a2 * h2 - c2.tileID.canonical.x) * u2.dim, d2 = (e2.y * h2 - c2.tileID.canonical.y) * u2.dim, f2 = Math.floor(p2), m2 = Math.floor(d2);
          return (i2 ? this.exaggeration() : 1) * Ii(Ii(u2.get(f2, m2), u2.get(f2, m2 + 1), d2 - m2), Ii(u2.get(f2 + 1, m2), u2.get(f2 + 1, m2 + 1), d2 - m2), p2 - f2);
        }
        getAtTileOffset(e2, t2, i2) {
          const r2 = 1 << e2.canonical.z;
          return this.getAtPointOrZero(new MercatorCoordinate(e2.wrap + (e2.canonical.x + t2 / ko) / r2, (e2.canonical.y + i2 / ko) / r2));
        }
        getAtTileOffsetFunc(e2, t2, i2, r2) {
          return (n2) => {
            const o2 = this.getAtTileOffset(e2, n2.x, n2.y), s2 = r2.upVector(e2.canonical, n2.x, n2.y);
            return Ys(s2, s2, o2 * r2.upVectorScale(e2.canonical, t2, i2).metersToTile), s2;
          };
        }
        getForTilePoints(e2, t2, i2, r2) {
          if (this.isUsingMockSource())
            return false;
          const n2 = DEMSampler.create(this, e2, r2);
          return !!n2 && (t2.forEach((e3) => {
            e3[2] = this.exaggeration() * n2.getElevationAt(e3[0], e3[1], i2);
          }), true);
        }
        getMinMaxForTile(e2) {
          if (this.isUsingMockSource())
            return null;
          const t2 = this.findDEMTileFor(e2);
          if (!t2 || !t2.dem)
            return null;
          const i2 = t2.dem.tree, r2 = t2.tileID, n2 = 1 << e2.canonical.z - r2.canonical.z;
          let o2 = e2.canonical.x / n2 - r2.canonical.x, s2 = e2.canonical.y / n2 - r2.canonical.y, a2 = 0;
          for (let t3 = 0; t3 < e2.canonical.z - r2.canonical.z && !i2.leaves[a2]; t3++) {
            o2 *= 2, s2 *= 2;
            const e3 = 2 * Math.floor(s2) + Math.floor(o2);
            a2 = i2.childOffsets[a2] + e3, o2 %= 1, s2 %= 1;
          }
          return { min: this.exaggeration() * i2.minimums[a2], max: this.exaggeration() * i2.maximums[a2] };
        }
        getMinElevationBelowMSL() {
          throw new Error("Pure virtual method called.");
        }
        raycast(e2, t2, i2) {
          throw new Error("Pure virtual method called.");
        }
        pointCoordinate(e2) {
          throw new Error("Pure virtual method called.");
        }
        _source() {
          throw new Error("Pure virtual method called.");
        }
        isUsingMockSource() {
          throw new Error("Pure virtual method called.");
        }
        exaggeration() {
          throw new Error("Pure virtual method called.");
        }
        findDEMTileFor(e2) {
          throw new Error("Pure virtual method called.");
        }
        get visibleDemTiles() {
          throw new Error("Getter must be implemented in subclass.");
        }
      } {
        constructor(e2, t2) {
          super(), this.painter = e2, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
          const [i2, r2, n2] = function(e3) {
            const t3 = new StructArrayLayout4i8(), i3 = new StructArrayLayout3ui6(), r3 = 131;
            t3.reserve(17161), i3.reserve(33800);
            for (let e4 = -64; e4 < 8288; e4 += 64)
              for (let i4 = -64; i4 < 8288; i4 += 64) {
                const r4 = i4 < 0 || i4 > 8224 || e4 < 0 || e4 > 8224 ? 24575 : 0, n4 = A(Math.round(i4), 0, ko), o3 = A(Math.round(e4), 0, ko);
                t3.emplaceBack(n4 + r4, o3, n4, o3);
              }
            const n3 = (e4, t4) => {
              const n4 = t4 * r3 + e4;
              i3.emplaceBack(n4 + 1, n4, n4 + r3), i3.emplaceBack(n4 + r3, n4 + r3 + 1, n4 + 1);
            };
            for (let e4 = 1; e4 < 129; e4++)
              for (let t4 = 1; t4 < 129; t4++)
                n3(t4, e4);
            return [0, 129].forEach((e4) => {
              for (let t4 = 0; t4 < 130; t4++)
                n3(t4, e4), n3(e4, t4);
            }), [t3, i3, 32768];
          }(), o2 = e2.context;
          this.gridBuffer = o2.createVertexBuffer(i2, Nh.members), this.gridIndexBuffer = o2.createIndexBuffer(r2), this.gridSegments = SegmentVector.simpleSegment(0, 0, i2.length, r2.length), this.gridNoSkirtSegments = SegmentVector.simpleSegment(0, 0, i2.length, n2), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new ProxySourceCache(t2.map), this.orthoMatrix = Cs(), Vs(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, ko, 0, ko, 0, 1);
          const s2 = o2.gl;
          this._overlapStencilMode = new StencilMode({ func: s2.GEQUAL, mask: 255 }, 0, 255, s2.KEEP, s2.KEEP, s2.REPLACE), this._previousZoom = e2.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = t2, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new MockSourceCache(t2.map);
        }
        set style(e2) {
          e2.on("data", this._onStyleDataEvent.bind(this)), e2.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e2, this._checkRenderCacheEfficiency();
        }
        update(e2, t2, i2) {
          if (e2 && e2.terrain) {
            this._style !== e2 && (this.style = e2), this.enabled = true;
            const r2 = e2.terrain.properties;
            this.sourceCache = 0 === e2.terrain.drapeRenderMode ? this._mockSourceCache : e2._getSourceCache(r2.get("source")), this._exaggeration = r2.get("exaggeration");
            const n2 = () => {
              this.sourceCache.used && Z(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
              const e3 = this.getScaledDemTileSize();
              this.sourceCache.update(t2, e3, true), this.resetTileLookupCache(this.sourceCache.id);
            };
            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, n2(), this._initializing = true), n2(), t2.updateElevation(true, i2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(t2), this._emptyDEMTextureDirty = true;
          } else
            this._disable();
        }
        resetTileLookupCache(e2) {
          this._findCoveringTileCache[e2] = {};
        }
        getScaledDemTileSize() {
          return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
        }
        _checkRenderCacheEfficiency() {
          const e2 = this.renderCacheEfficiency(this._style);
          this._style.map._optimizeForTerrain || 100 !== e2.efficiency && Z(`Terrain render cache efficiency is not optimal (${e2.efficiency}%) and performance
                may be affected negatively, consider placing all background, fill and line layers before layer
                with id '${e2.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
        }
        _onStyleDataEvent(e2) {
          e2.coord && "source" === e2.dataType ? this._clearRenderCacheForTile(e2.sourceCacheId, e2.coord) : "style" === e2.dataType && (this._invalidateRenderCache = true);
        }
        _disable() {
          if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
            for (const e2 in this._style._sourceCaches)
              this._style._sourceCaches[e2].usedForTerrain = false;
        }
        destroy() {
          this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e2) => e2.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
        }
        _source() {
          return this.enabled ? this.sourceCache : null;
        }
        isUsingMockSource() {
          return this.sourceCache === this._mockSourceCache;
        }
        exaggeration() {
          return this._exaggeration;
        }
        get visibleDemTiles() {
          return this._visibleDemTiles;
        }
        get drapeBufferSize() {
          const e2 = 2 * this.proxySourceCache.getSource().tileSize;
          return [e2, e2];
        }
        set useVertexMorphing(e2) {
          this._useVertexMorphing = e2;
        }
        updateTileBinding(e2) {
          if (!this.enabled)
            return;
          this.prevTerrainTileForTile = this.terrainTileForTile;
          const t2 = this.proxySourceCache, i2 = this.painter.transform;
          this._initializing && (this._initializing = 0 === i2._centerAltitude && -1 === this.getAtPointOrZero(MercatorCoordinate.fromLngLat(i2.center), -1), this._emptyDEMTextureDirty = !this._initializing);
          const r2 = this.proxyCoords = t2.getIds().map((e3) => {
            const r3 = t2.getTileByID(e3).tileID;
            return r3.projMatrix = i2.calculateProjMatrix(r3.toUnwrapped()), r3;
          });
          !function(e3, t3) {
            const i3 = t3.transform.pointCoordinate(t3.transform.getCameraPoint()), r3 = new d(i3.x, i3.y);
            e3.sort((e4, t4) => {
              if (t4.overscaledZ - e4.overscaledZ)
                return t4.overscaledZ - e4.overscaledZ;
              const i4 = new d(e4.canonical.x + (1 << e4.canonical.z) * e4.wrap, e4.canonical.y), n3 = new d(t4.canonical.x + (1 << t4.canonical.z) * t4.wrap, t4.canonical.y), o3 = r3.mult(1 << e4.canonical.z);
              return o3.x -= 0.5, o3.y -= 0.5, o3.distSqr(i4) - o3.distSqr(n3);
            });
          }(r2, this.painter), this._previousZoom = i2.zoom;
          const n2 = this.proxyToSource || {};
          this.proxyToSource = {}, r2.forEach((e3) => {
            this.proxyToSource[e3.key] = {};
          }), this.terrainTileForTile = {};
          const o2 = this._style._sourceCaches;
          for (const t3 in o2) {
            const i3 = o2[t3];
            if (!i3.used)
              continue;
            if (i3 !== this.sourceCache && this.resetTileLookupCache(i3.id), this._setupProxiedCoordsForOrtho(i3, e2[t3], n2), i3.usedForTerrain)
              continue;
            const r3 = e2[t3];
            i3.getSource().reparseOverscaled && this._assignTerrainTiles(r3);
          }
          this.proxiedCoords[t2.id] = r2.map((e3) => new ProxiedTileID(e3, e3.key, this.orthoMatrix)), this._assignTerrainTiles(r2), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n2), this.renderingToTexture = false, this._updateTimestamp = Je.now();
          const s2 = {};
          this._visibleDemTiles = [];
          for (const e3 of this.proxyCoords) {
            const t3 = this.terrainTileForTile[e3.key];
            if (!t3)
              continue;
            const i3 = t3.tileID.key;
            i3 in s2 || (this._visibleDemTiles.push(t3), s2[i3] = i3);
          }
        }
        _assignTerrainTiles(e2) {
          this._initializing || e2.forEach((e3) => {
            if (this.terrainTileForTile[e3.key])
              return;
            const t2 = this._findTileCoveringTileID(e3, this.sourceCache);
            t2 && (this.terrainTileForTile[e3.key] = t2);
          });
        }
        _prepareDEMTextures() {
          const e2 = this.painter.context, t2 = e2.gl;
          for (const i2 in this.terrainTileForTile) {
            const r2 = this.terrainTileForTile[i2], n2 = r2.dem;
            !n2 || r2.demTexture && !r2.needsDEMTextureUpload || (e2.activeTexture.set(t2.TEXTURE1), Md(this.painter, r2, n2));
          }
        }
        _prepareDemTileUniforms(e2, t2, i2, r2) {
          if (!t2 || null == t2.demTexture)
            return false;
          const n2 = e2.tileID.canonical, o2 = Math.pow(2, t2.tileID.canonical.z - n2.z), s2 = r2 || "";
          return i2[`u_dem_tl${s2}`] = [n2.x * o2 % 1, n2.y * o2 % 1], i2[`u_dem_scale${s2}`] = o2, true;
        }
        get emptyDEMTexture() {
          return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
        }
        get emptyDepthBufferTexture() {
          const e2 = this.painter.context, t2 = e2.gl;
          if (!this._emptyDepthBufferTexture) {
            const i2 = new RGBAImage({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
            this._emptyDepthBufferTexture = new Texture(e2, i2, t2.RGBA, { premultiply: false });
          }
          return this._emptyDepthBufferTexture;
        }
        _getLoadedAreaMinimum() {
          let e2 = 0;
          const t2 = this._visibleDemTiles.reduce((t3, i2) => {
            if (!i2.dem)
              return t3;
            const r2 = i2.dem.tree.minimums[0];
            return r2 > 0 && e2++, t3 + r2;
          }, 0);
          return e2 ? t2 / e2 : 0;
        }
        _updateEmptyDEMTexture() {
          const e2 = this.painter.context, t2 = e2.gl;
          e2.activeTexture.set(t2.TEXTURE2);
          const i2 = this._getLoadedAreaMinimum(), r2 = new RGBAImage({ width: 1, height: 1 }, new Uint8Array(DEMData.pack(i2, this.sourceCache.getSource().encoding)));
          this._emptyDEMTextureDirty = false;
          let n2 = this._emptyDEMTexture;
          return n2 ? n2.update(r2, { premultiply: false }) : n2 = this._emptyDEMTexture = new Texture(e2, r2, t2.RGBA, { premultiply: false }), n2;
        }
        setupElevationDraw(e2, t2, i2) {
          const r2 = this.painter.context, n2 = r2.gl, o2 = (s2 = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: DEMData.getUnpackVector(s2), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 });
          var s2;
          o2.u_dem_size = this.sourceCache.getSource().tileSize, o2.u_exaggeration = this.exaggeration();
          let a2 = null, l2 = null, c2 = 1;
          if (i2 && i2.morphing && this._useVertexMorphing) {
            const t3 = i2.morphing.srcDemTile, r3 = i2.morphing.dstDemTile;
            c2 = i2.morphing.phase, t3 && r3 && (this._prepareDemTileUniforms(e2, t3, o2, "_prev") && (l2 = t3), this._prepareDemTileUniforms(e2, r3, o2) && (a2 = r3));
          }
          if (l2 && a2 ? (r2.activeTexture.set(n2.TEXTURE2), a2.demTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), r2.activeTexture.set(n2.TEXTURE4), l2.demTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), o2.u_dem_lerp = c2) : (a2 = this.terrainTileForTile[e2.tileID.key], r2.activeTexture.set(n2.TEXTURE2), (this._prepareDemTileUniforms(e2, a2, o2) ? a2.demTexture : this.emptyDEMTexture).bind(n2.NEAREST, n2.CLAMP_TO_EDGE)), r2.activeTexture.set(n2.TEXTURE3), i2 && i2.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE), this._depthFBO && (o2.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE), o2.u_depth_size_inv = [1, 1]), i2 && i2.useMeterToDem && a2) {
            const e3 = (1 << a2.tileID.canonical.z) * Vo(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
            o2.u_meter_to_dem = e3;
          }
          if (i2 && i2.labelPlaneMatrixInv && (o2.u_label_plane_matrix_inv = i2.labelPlaneMatrixInv), t2.setTerrainUniformValues(r2, o2), "globe" === this.painter.transform.projection.name) {
            const n3 = this.globeUniformValues(this.painter.transform, e2.tileID.canonical, i2 && i2.useDenormalizedUpVectorScale);
            t2.setGlobeUniformValues(r2, n3);
          }
        }
        globeUniformValues(e2, t2, i2) {
          const r2 = e2.projection;
          return { u_tile_tl_up: r2.upVector(t2, 0, 0), u_tile_tr_up: r2.upVector(t2, ko, 0), u_tile_br_up: r2.upVector(t2, ko, ko), u_tile_bl_up: r2.upVector(t2, 0, ko), u_tile_up_scale: i2 ? lu : r2.upVectorScale(t2, e2.center.lat, e2.worldSize).metersToTile };
        }
        renderToBackBuffer(e2) {
          const t2 = this.painter, i2 = this.painter.context;
          0 !== e2.length && (i2.bindFramebuffer.set(null), i2.viewport.set([0, 0, t2.width, t2.height]), t2.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(e3, t3, i3, r2, n2) {
            if ("globe" === e3.transform.projection.name)
              !function(e4, t4, i4, r3, n3) {
                const o2 = e4.context, s2 = o2.gl;
                let a2, l2;
                const c2 = e4.options.showTerrainWireframe ? 2 : 0, u2 = e4.transform, h2 = ku(e4, o2, u2), p2 = (t5, i5) => {
                  if (l2 === t5)
                    return;
                  const r4 = [Rd[t5], "PROJECTION_GLOBE_VIEW"];
                  h2 && r4.push("CUSTOM_ANTIALIASING"), i5 && r4.push(Rd[c2]), a2 = e4.useProgram("globeRaster", null, r4), l2 = t5;
                }, d2 = e4.colorModeForRenderPass(), f2 = new DepthMode(s2.LEQUAL, DepthMode.ReadWrite, e4.depthRangeFor3D);
                Bd.update(n3);
                const m2 = function(e5) {
                  const t5 = e5.pixelsPerMeter, i5 = t5 / Vo(1, e5.center.lat), r4 = Is(new Float64Array(16));
                  return Ps(r4, r4, [e5.point.x, e5.point.y, 0]), zs(r4, r4, [i5, i5, t5]), Float32Array.from(r4);
                }(u2), _2 = [Oo(u2.center.lng), Uo(u2.center.lat)], g2 = c2 ? [false, true] : [false], y2 = e4.globeSharedBuffers, x2 = [u2.width * Je.devicePixelRatio, u2.height * Je.devicePixelRatio], v2 = Float32Array.from(u2.globeMatrix), w2 = { useDenormalizedUpVectorScale: true };
                if (g2.forEach((c3) => {
                  l2 = -1;
                  const h3 = c3 ? s2.LINES : s2.TRIANGLES;
                  for (const l3 of r3) {
                    const r4 = i4.getTile(l3), g3 = StencilMode.disabled, T2 = t4.prevTerrainTileForTile[l3.key], E2 = t4.terrainTileForTile[l3.key];
                    kd(T2, E2) && Bd.newMorphing(l3.key, T2, E2, n3, 250), o2.activeTexture.set(s2.TEXTURE0), r4.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE);
                    const S2 = Bd.getMorphValuesForProxy(l3.key), A2 = S2 ? 1 : 0;
                    S2 && mt(w2, { morphing: { srcDemTile: S2.from, dstDemTile: S2.to, phase: b(S2.phase) } });
                    const C2 = bu(l3.canonical), I2 = Ru(C2.getCenter().lat), M2 = Bu(l3.canonical, C2, I2, u2.worldSize / u2._pixelsPerMercatorPixel), D2 = Iu(_u(l3.canonical)), P2 = Ld(u2.projMatrix, v2, m2, D2, zu(u2.zoom), _2, u2.frustumCorners.TL, u2.frustumCorners.TR, u2.frustumCorners.BR, u2.frustumCorners.BL, u2.globeCenterInViewSpace, u2.globeRadius, x2, M2);
                    if (p2(A2, c3), t4.setupElevationDraw(r4, a2, w2), e4.prepareDrawProgram(o2, a2, l3.toUnwrapped()), y2) {
                      const [t5, i5, r5] = c3 ? y2.getWirefameBuffers(e4.context, I2) : y2.getGridBuffers(I2);
                      a2.draw(o2, h3, f2, g3, d2, CullFaceMode.backCCW, P2, "globe_raster", t5, i5, r5);
                    }
                  }
                }), y2) {
                  const n4 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  h2 && n4.push("CUSTOM_ANTIALIASING"), a2 = e4.useProgram("globeRaster", null, n4);
                  for (const n5 of r3) {
                    const { x: r4, y: l3, z: c3 } = n5.canonical, h3 = 0 === l3, p3 = l3 === (1 << c3) - 1, [m3, g3, v3, b2] = y2.getPoleBuffers(c3);
                    if (b2 && (h3 || p3)) {
                      const l4 = i4.getTile(n5);
                      o2.activeTexture.set(s2.TEXTURE0), l4.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE);
                      let y3 = Lu(c3, r4, u2);
                      const T2 = Iu(_u(n5.canonical)), E2 = (e5, t5) => e5.draw(o2, s2.TRIANGLES, f2, StencilMode.disabled, d2, CullFaceMode.disabled, Ld(u2.projMatrix, y3, y3, T2, 0, _2, u2.frustumCorners.TL, u2.frustumCorners.TR, u2.frustumCorners.BR, u2.frustumCorners.BL, u2.globeCenterInViewSpace, u2.globeRadius, x2), "globe_pole_raster", t5, v3, b2);
                      t4.setupElevationDraw(l4, a2, w2), e4.prepareDrawProgram(o2, a2, n5.toUnwrapped()), h3 && E2(a2, m3), p3 && (y3 = zs(Cs(), y3, [1, -1, 1]), E2(a2, g3));
                    }
                  }
                }
              }(e3, t3, i3, r2, n2);
            else {
              const o2 = e3.context, s2 = o2.gl;
              let a2, l2;
              const c2 = e3.options.showTerrainWireframe ? 2 : 0, u2 = (t4, i4) => {
                if (l2 === t4)
                  return;
                const r3 = [Rd[t4]];
                i4 && r3.push(Rd[c2]), a2 = e3.useProgram("terrainRaster", null, r3), l2 = t4;
              }, h2 = e3.colorModeForRenderPass(), p2 = new DepthMode(s2.LEQUAL, DepthMode.ReadWrite, e3.depthRangeFor3D);
              Bd.update(n2);
              const d2 = e3.transform, f2 = 6 * Math.pow(1.5, 22 - d2.zoom) * t3.exaggeration();
              (c2 ? [false, true] : [false]).forEach((c3) => {
                l2 = -1;
                const m2 = c3 ? s2.LINES : s2.TRIANGLES, [_2, g2] = c3 ? t3.getWirefameBuffer() : [t3.gridIndexBuffer, t3.gridSegments];
                for (const l3 of r2) {
                  const r3 = i3.getTile(l3), y2 = StencilMode.disabled, x2 = t3.prevTerrainTileForTile[l3.key], v2 = t3.terrainTileForTile[l3.key];
                  kd(x2, v2) && Bd.newMorphing(l3.key, x2, v2, n2, 250), o2.activeTexture.set(s2.TEXTURE0), r3.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST);
                  const w2 = Bd.getMorphValuesForProxy(l3.key), T2 = w2 ? 1 : 0;
                  let E2;
                  w2 && (E2 = { morphing: { srcDemTile: w2.from, dstDemTile: w2.to, phase: b(w2.phase) } });
                  const S2 = zd(l3.projMatrix, Fd(l3.canonical, d2.renderWorldCopies) ? f2 / 10 : f2);
                  u2(T2, c3), t3.setupElevationDraw(r3, a2, E2), e3.prepareDrawProgram(o2, a2, l3.toUnwrapped()), a2.draw(o2, m2, p2, y2, h2, CullFaceMode.backCCW, S2, "terrain_raster", t3.gridBuffer, _2, g2);
                }
              });
            }
          }(t2, this, this.proxySourceCache, e2, this._updateTimestamp), this.renderingToTexture = true, t2.gpuTimingDeferredRenderEnd(), e2.splice(0, e2.length));
        }
        renderBatch(e2) {
          if (0 === this._drapedRenderBatches.length)
            return e2 + 1;
          this.renderingToTexture = true;
          const t2 = this.painter, i2 = this.painter.context, r2 = this.proxySourceCache, n2 = this.proxiedCoords[r2.id], o2 = this._drapedRenderBatches.shift(), s2 = [], a2 = t2.style.order;
          let l2 = 0;
          for (const c2 of n2) {
            const n3 = r2.getTileByID(c2.proxyTileKey), u2 = r2.proxyCachedFBO[c2.key] ? r2.proxyCachedFBO[c2.key][e2] : void 0, h2 = void 0 !== u2 ? r2.renderCache[u2] : this.pool[l2++], p2 = void 0 !== u2;
            if (n3.texture = h2.tex, p2 && !h2.dirty) {
              s2.push(n3.tileID);
              continue;
            }
            let d2;
            i2.bindFramebuffer.set(h2.fb.framebuffer), this.renderedToTile = false, h2.dirty && (i2.clear({ color: Gt.transparent, stencil: 0 }), h2.dirty = false);
            for (let e3 = o2.start; e3 <= o2.end; ++e3) {
              const r3 = t2.style._layers[a2[e3]];
              if (r3.isHidden(t2.transform.zoom))
                continue;
              const n4 = t2.style._getLayerSourceCache(r3), o3 = n4 ? this.proxyToSource[c2.key][n4.id] : [c2];
              if (!o3)
                continue;
              const s3 = o3;
              i2.viewport.set([0, 0, h2.fb.width, h2.fb.height]), d2 !== (n4 ? n4.id : null) && (this._setupStencil(h2, o3, r3, n4), d2 = n4 ? n4.id : null), t2.renderLayer(t2, n4, r3, s3);
            }
            this.renderedToTile ? (h2.dirty = true, s2.push(n3.tileID)) : p2 || --l2, 5 === l2 && (l2 = 0, this.renderToBackBuffer(s2));
          }
          return this.renderToBackBuffer(s2), this.renderingToTexture = false, i2.bindFramebuffer.set(null), i2.viewport.set([0, 0, t2.width, t2.height]), o2.end + 1;
        }
        postRender() {
        }
        renderCacheEfficiency(e2) {
          const t2 = e2.order.length;
          if (0 === t2)
            return { efficiency: 100 };
          let i2, r2 = 0, n2 = 0, o2 = false;
          for (let s2 = 0; s2 < t2; ++s2) {
            const t3 = e2._layers[e2.order[s2]];
            this._style.isLayerDraped(t3) ? (o2 && ++r2, ++n2) : o2 || (o2 = true, i2 = t3.id);
          }
          return 0 === n2 ? { efficiency: 100 } : { efficiency: 100 * (1 - r2 / n2), firstUndrapedLayer: i2 };
        }
        getMinElevationBelowMSL() {
          let e2 = 0;
          return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t2) => {
            e2 = Math.min(e2, t2.dem.tree.minimums[0]);
          }), 0 === e2 ? e2 : (e2 - 30) * this._exaggeration;
        }
        raycast(e2, t2, i2) {
          if (!this._visibleDemTiles)
            return null;
          const r2 = this._visibleDemTiles.filter((e3) => e3.dem).map((r3) => {
            const n2 = r3.tileID, o2 = 1 << n2.overscaledZ, { x: s2, y: a2 } = n2.canonical, l2 = s2 / o2, c2 = (s2 + 1) / o2, u2 = a2 / o2, h2 = (a2 + 1) / o2;
            return { minx: l2, miny: u2, maxx: c2, maxy: h2, t: r3.dem.tree.raycastRoot(l2, u2, c2, h2, e2, t2, i2), tile: r3 };
          });
          r2.sort((e3, t3) => (null !== e3.t ? e3.t : Number.MAX_VALUE) - (null !== t3.t ? t3.t : Number.MAX_VALUE));
          for (const n2 of r2) {
            if (null == n2.t)
              return null;
            const r3 = n2.tile.dem.tree.raycast(n2.minx, n2.miny, n2.maxx, n2.maxy, e2, t2, i2);
            if (null != r3)
              return r3;
          }
          return null;
        }
        _createFBO() {
          const e2 = this.painter.context, t2 = e2.gl, i2 = this.drapeBufferSize;
          e2.activeTexture.set(t2.TEXTURE0);
          const r2 = new Texture(e2, { width: i2[0], height: i2[1], data: null }, t2.RGBA);
          r2.bind(t2.LINEAR, t2.CLAMP_TO_EDGE);
          const n2 = e2.createFramebuffer(i2[0], i2[1], false);
          return n2.colorAttachment.set(r2.texture), n2.depthAttachment = new DepthStencilAttachment(e2, n2.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = e2.createRenderbuffer(e2.gl.DEPTH_STENCIL, i2[0], i2[1]), this._stencilRef = 0, n2.depthAttachment.set(this._sharedDepthStencil), e2.clear({ stencil: 0 })) : n2.depthAttachment.set(this._sharedDepthStencil), e2.extTextureFilterAnisotropic && !e2.extTextureFilterAnisotropicForceOff && t2.texParameterf(t2.TEXTURE_2D, e2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e2.extTextureFilterAnisotropicMax), { fb: n2, tex: r2, dirty: false };
        }
        _initFBOPool() {
          for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
            this.pool.push(this._createFBO());
        }
        _shouldDisableRenderCache() {
          if (this._style.light && this._style.light.hasTransition())
            return true;
          for (const e2 in this._style._sourceCaches)
            if (this._style._sourceCaches[e2].hasTransition())
              return true;
          return this._style.order.some((e2) => {
            const t2 = this._style._layers[e2], i2 = t2.isHidden(this.painter.transform.zoom);
            return "custom" !== t2.type && !i2 && t2.hasTransition();
          });
        }
        _clearRasterFadeFromRenderCache() {
          let e2 = false;
          for (const t2 in this._style._sourceCaches)
            if (this._style._sourceCaches[t2]._source instanceof RasterTileSource) {
              e2 = true;
              break;
            }
          if (e2)
            for (let e3 = 0; e3 < this._style.order.length; ++e3) {
              const t2 = this._style._layers[this._style.order[e3]], i2 = t2.isHidden(this.painter.transform.zoom), r2 = this._style._getLayerSourceCache(t2);
              if ("raster" !== t2.type || i2 || !r2)
                continue;
              const n2 = t2.paint.get("raster-fade-duration");
              for (const e4 of this.proxyCoords) {
                const t3 = this.proxyToSource[e4.key][r2.id];
                if (t3)
                  for (const e5 of t3) {
                    const t4 = Ud(r2.getTile(e5), r2.findLoadedParent(e5, 0), r2, this.painter.transform, n2);
                    (1 !== t4.opacity || 0 !== t4.mix) && this._clearRenderCacheForTile(r2.id, e5);
                  }
              }
            }
        }
        _setupDrapedRenderBatches() {
          const e2 = this._style.order, t2 = e2.length;
          if (0 === t2)
            return;
          const i2 = [];
          let r2, n2 = 0, o2 = this._style._layers[e2[n2]];
          for (; !this._style.isLayerDraped(o2) && o2.isHidden(this.painter.transform.zoom) && ++n2 < t2; )
            o2 = this._style._layers[e2[n2]];
          for (; n2 < t2; ++n2) {
            const t3 = this._style._layers[e2[n2]];
            t3.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t3) ? void 0 === r2 && (r2 = n2) : void 0 !== r2 && (i2.push({ start: r2, end: n2 - 1 }), r2 = void 0));
          }
          void 0 !== r2 && i2.push({ start: r2, end: n2 - 1 }), this._drapedRenderBatches = i2;
        }
        _setupRenderCache(e2) {
          const t2 = this.proxySourceCache;
          if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
            if (this._invalidateRenderCache = false, t2.renderCache.length > t2.renderCachePool.length) {
              const e3 = Object.values(t2.proxyCachedFBO);
              t2.proxyCachedFBO = {};
              for (let i3 = 0; i3 < e3.length; ++i3) {
                const r3 = Object.values(e3[i3]);
                t2.renderCachePool.push(...r3);
              }
            }
            return;
          }
          this._clearRasterFadeFromRenderCache();
          const i2 = this.proxyCoords, r2 = this._tilesDirty;
          for (let n3 = i2.length - 1; n3 >= 0; n3--) {
            const o2 = i2[n3];
            if (t2.getTileByID(o2.key), void 0 !== t2.proxyCachedFBO[o2.key]) {
              const i3 = e2[o2.key], n4 = this.proxyToSource[o2.key];
              let s2 = 0;
              for (const e3 in n4) {
                const t3 = n4[e3], o3 = i3[e3];
                if (!o3 || o3.length !== t3.length || t3.some((t4, i4) => t4 !== o3[i4] || r2[e3] && r2[e3].hasOwnProperty(t4.key))) {
                  s2 = -1;
                  break;
                }
                ++s2;
              }
              for (const e3 in t2.proxyCachedFBO[o2.key])
                t2.renderCache[t2.proxyCachedFBO[o2.key][e3]].dirty = s2 < 0 || s2 !== Object.values(i3).length;
            }
          }
          const n2 = [...this._drapedRenderBatches];
          n2.sort((e3, t3) => t3.end - t3.start - (e3.end - e3.start));
          for (const e3 of n2)
            for (const r3 of i2) {
              if (t2.proxyCachedFBO[r3.key])
                continue;
              let i3 = t2.renderCachePool.pop();
              void 0 === i3 && t2.renderCache.length < 50 && (i3 = t2.renderCache.length, t2.renderCache.push(this._createFBO())), void 0 !== i3 && (t2.proxyCachedFBO[r3.key] = {}, t2.proxyCachedFBO[r3.key][e3.start] = i3, t2.renderCache[i3].dirty = true);
            }
          this._tilesDirty = {};
        }
        _setupStencil(e2, t2, i2, r2) {
          if (!r2 || !this._sourceTilesOverlap[r2.id])
            return void (this._overlapStencilType && (this._overlapStencilType = false));
          const n2 = this.painter.context, o2 = n2.gl;
          if (t2.length <= 1)
            return void (this._overlapStencilType = false);
          let s2;
          if (i2.isTileClipped())
            s2 = t2.length, this._overlapStencilMode.test = { func: o2.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
          else {
            if (!(t2[0].overscaledZ > t2[t2.length - 1].overscaledZ))
              return void (this._overlapStencilType = false);
            s2 = 1, this._overlapStencilMode.test = { func: o2.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
          }
          this._stencilRef + s2 > 255 && (n2.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += s2, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(t2, this._overlapStencilMode.ref);
        }
        clipOrMaskOverlapStencilType() {
          return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
        }
        stencilModeForRTTOverlap(e2) {
          return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e2.key]), this._overlapStencilMode) : StencilMode.disabled;
        }
        _renderTileClippingMasks(e2, t2) {
          const i2 = this.painter, r2 = this.painter.context, n2 = r2.gl;
          i2._tileClippingMaskIDs = {}, r2.setColorMode(ColorMode.disabled), r2.setDepthMode(DepthMode.disabled);
          const o2 = i2.useProgram("clippingMask");
          for (const s2 of e2) {
            const e3 = i2._tileClippingMaskIDs[s2.key] = --t2;
            o2.draw(r2, n2.TRIANGLES, DepthMode.disabled, new StencilMode({ func: n2.ALWAYS, mask: 0 }, e3, 255, n2.KEEP, n2.KEEP, n2.REPLACE), ColorMode.disabled, CullFaceMode.disabled, Od(s2.projMatrix), "$clipping", i2.tileExtentBuffer, i2.quadTriangleIndexBuffer, i2.tileExtentSegments);
          }
        }
        pointCoordinate(e2) {
          const t2 = this.painter.transform;
          if (e2.x < 0 || e2.x > t2.width || e2.y < 0 || e2.y > t2.height)
            return null;
          const i2 = [e2.x, e2.y, 1, 1];
          da(i2, i2, t2.pixelMatrixInverse), ha(i2, i2, 1 / i2[3]), i2[0] /= t2.worldSize, i2[1] /= t2.worldSize;
          const r2 = t2._camera.position, n2 = Vo(1, t2.center.lat), o2 = [r2[0], r2[1], r2[2] / n2, 0], s2 = Ws([], i2.slice(0, 3), o2);
          ea(s2, s2);
          const a2 = this.raycast(o2, s2, this._exaggeration);
          return null !== a2 && a2 ? (Js(o2, o2, s2, a2), o2[3] = o2[2], o2[2] *= n2, o2) : null;
        }
        drawDepth() {
          const e2 = this.painter, t2 = e2.context, i2 = this.proxySourceCache, r2 = Math.ceil(e2.width), n2 = Math.ceil(e2.height);
          if (!this._depthFBO || this._depthFBO.width === r2 && this._depthFBO.height === n2 || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
            const e3 = t2.gl, i3 = t2.createFramebuffer(r2, n2, true);
            t2.activeTexture.set(e3.TEXTURE0);
            const o2 = new Texture(t2, { width: r2, height: n2, data: null }, e3.RGBA);
            o2.bind(e3.NEAREST, e3.CLAMP_TO_EDGE), i3.colorAttachment.set(o2.texture);
            const s2 = t2.createRenderbuffer(t2.gl.DEPTH_COMPONENT16, r2, n2);
            i3.depthAttachment.set(s2), this._depthFBO = i3, this._depthTexture = o2;
          }
          t2.bindFramebuffer.set(this._depthFBO.framebuffer), t2.viewport.set([0, 0, r2, n2]), function(e3, t3, i3, r3) {
            if ("globe" === e3.transform.projection.name)
              return;
            const n3 = e3.context, o2 = n3.gl;
            n3.clear({ depth: 1 });
            const s2 = e3.useProgram("terrainDepth"), a2 = new DepthMode(o2.LESS, DepthMode.ReadWrite, e3.depthRangeFor3D);
            for (const e4 of r3) {
              const r4 = i3.getTile(e4), l2 = zd(e4.projMatrix, 0);
              t3.setupElevationDraw(r4, s2), s2.draw(n3, o2.TRIANGLES, a2, StencilMode.disabled, ColorMode.unblended, CullFaceMode.backCCW, l2, "terrain_depth", t3.gridBuffer, t3.gridIndexBuffer, t3.gridNoSkirtSegments);
            }
          }(e2, this, i2, this.proxyCoords);
        }
        _setupProxiedCoordsForOrtho(e2, t2, i2) {
          if (e2.getSource() instanceof ImageSource)
            return this._setupProxiedCoordsForImageSource(e2, t2, i2);
          this._findCoveringTileCache[e2.id] = this._findCoveringTileCache[e2.id] || {};
          const r2 = this.proxiedCoords[e2.id] = [], n2 = this.proxyCoords;
          for (let t3 = 0; t3 < n2.length; t3++) {
            const o3 = n2[t3], s2 = this._findTileCoveringTileID(o3, e2);
            if (s2) {
              const t4 = this._createProxiedId(o3, s2, i2[o3.key] && i2[o3.key][e2.id]);
              r2.push(t4), this.proxyToSource[o3.key][e2.id] = [t4];
            }
          }
          let o2 = false;
          for (let n3 = 0; n3 < t2.length; n3++) {
            const s2 = e2.getTile(t2[n3]);
            if (!s2 || !s2.hasData())
              continue;
            const a2 = this._findTileCoveringTileID(s2.tileID, this.proxySourceCache);
            if (a2 && a2.tileID.canonical.z !== s2.tileID.canonical.z) {
              const t3 = this.proxyToSource[a2.tileID.key][e2.id], n4 = this._createProxiedId(a2.tileID, s2, i2[a2.tileID.key] && i2[a2.tileID.key][e2.id]);
              t3 ? t3.splice(t3.length - 1, 0, n4) : this.proxyToSource[a2.tileID.key][e2.id] = [n4], r2.push(n4), o2 = true;
            }
          }
          this._sourceTilesOverlap[e2.id] = o2;
        }
        _setupProxiedCoordsForImageSource(e2, t2, i2) {
          if (!e2.getSource().loaded())
            return;
          const r2 = this.proxiedCoords[e2.id] = [], n2 = this.proxyCoords, o2 = e2.getSource(), s2 = new d(o2.tileID.x, o2.tileID.y)._div(1 << o2.tileID.z), a2 = o2.coordinates.map(MercatorCoordinate.fromLngLat).reduce((e3, t3) => (e3.min.x = Math.min(e3.min.x, t3.x - s2.x), e3.min.y = Math.min(e3.min.y, t3.y - s2.y), e3.max.x = Math.max(e3.max.x, t3.x - s2.x), e3.max.y = Math.max(e3.max.y, t3.y - s2.y), e3), { min: new d(Number.MAX_VALUE, Number.MAX_VALUE), max: new d(-Number.MAX_VALUE, -Number.MAX_VALUE) }), l2 = (e3, t3) => {
            const i3 = e3.wrap + e3.canonical.x / (1 << e3.canonical.z), r3 = e3.canonical.y / (1 << e3.canonical.z), n3 = ko / (1 << e3.canonical.z), o3 = t3.wrap + t3.canonical.x / (1 << t3.canonical.z), s3 = t3.canonical.y / (1 << t3.canonical.z);
            return i3 + n3 < o3 + a2.min.x || i3 > o3 + a2.max.x || r3 + n3 < s3 + a2.min.y || r3 > s3 + a2.max.y;
          };
          for (let o3 = 0; o3 < n2.length; o3++) {
            const s3 = n2[o3];
            for (let n3 = 0; n3 < t2.length; n3++) {
              const o4 = e2.getTile(t2[n3]);
              if (!o4 || !o4.hasData())
                continue;
              if (l2(s3, o4.tileID))
                continue;
              const a3 = this._createProxiedId(s3, o4, i2[s3.key] && i2[s3.key][e2.id]), c2 = this.proxyToSource[s3.key][e2.id];
              c2 ? c2.push(a3) : this.proxyToSource[s3.key][e2.id] = [a3], r2.push(a3);
            }
          }
        }
        _createProxiedId(e2, t2, i2) {
          let r2 = this.orthoMatrix;
          if (i2) {
            const e3 = i2.find((e4) => e4.key === t2.tileID.key);
            if (e3)
              return e3;
          }
          if (t2.tileID.key !== e2.key) {
            const i3 = e2.canonical.z - t2.tileID.canonical.z;
            let n2, o2, s2;
            r2 = Cs();
            const a2 = t2.tileID.wrap - e2.wrap << e2.overscaledZ;
            i3 > 0 ? (n2 = ko >> i3, o2 = n2 * ((t2.tileID.canonical.x << i3) - e2.canonical.x + a2), s2 = n2 * ((t2.tileID.canonical.y << i3) - e2.canonical.y)) : (n2 = ko << -i3, o2 = ko * (t2.tileID.canonical.x - (e2.canonical.x + a2 << -i3)), s2 = ko * (t2.tileID.canonical.y - (e2.canonical.y << -i3))), Vs(r2, 0, n2, 0, n2, 0, 1), Ps(r2, r2, [o2, s2, 0]);
          }
          return new ProxiedTileID(t2.tileID, e2.key, r2);
        }
        _findTileCoveringTileID(e2, t2) {
          let i2 = t2.getTile(e2);
          if (i2 && i2.hasData())
            return i2;
          const r2 = this._findCoveringTileCache[t2.id], n2 = r2[e2.key];
          if (i2 = n2 ? t2.getTileByID(n2) : null, i2 && i2.hasData() || null === n2)
            return i2;
          let o2 = i2 ? i2.tileID : e2, s2 = o2.overscaledZ;
          const a2 = t2.getSource().minzoom, l2 = [];
          if (!n2) {
            const r3 = t2.getSource().maxzoom;
            if (e2.canonical.z >= r3) {
              const i3 = e2.canonical.z - r3;
              t2.getSource().reparseOverscaled ? (s2 = Math.max(e2.canonical.z + 2, t2.transform.tileZoom), o2 = new OverscaledTileID(s2, e2.wrap, r3, e2.canonical.x >> i3, e2.canonical.y >> i3)) : 0 !== i3 && (s2 = r3, o2 = new OverscaledTileID(s2, e2.wrap, r3, e2.canonical.x >> i3, e2.canonical.y >> i3));
            }
            o2.key !== e2.key && (l2.push(o2.key), i2 = t2.getTile(o2));
          }
          const c2 = (e3) => {
            l2.forEach((t3) => {
              r2[t3] = e3;
            }), l2.length = 0;
          };
          for (s2 -= 1; s2 >= a2 && (!i2 || !i2.hasData()); s2--) {
            i2 && c2(i2.tileID.key);
            const e3 = o2.calculateScaledKey(s2);
            if (i2 = t2.getTileByID(e3), i2 && i2.hasData())
              break;
            const n3 = r2[e3];
            if (null === n3)
              break;
            void 0 === n3 ? l2.push(e3) : i2 = t2.getTileByID(n3);
          }
          return c2(i2 ? i2.tileID.key : null), i2 && i2.hasData() ? i2 : null;
        }
        findDEMTileFor(e2) {
          return this.enabled ? this._findTileCoveringTileID(e2, this.sourceCache) : null;
        }
        prepareDrawTile() {
          this.renderedToTile = true;
        }
        _clearRenderCacheForTile(e2, t2) {
          let i2 = this._tilesDirty[e2];
          i2 || (i2 = this._tilesDirty[e2] = {}), i2[t2.key] = true;
        }
        getWirefameBuffer() {
          if (!this.wireframeSegments) {
            const e2 = function(e3) {
              let t2 = 0;
              const i2 = new StructArrayLayout2ui4(), r2 = 131;
              for (let e4 = 1; e4 < 129; e4++) {
                for (let n2 = 1; n2 < 129; n2++)
                  t2 = e4 * r2 + n2, i2.emplaceBack(t2, t2 + 1), i2.emplaceBack(t2, t2 + r2), i2.emplaceBack(t2 + 1, t2 + r2), 128 === e4 && i2.emplaceBack(t2 + r2, t2 + r2 + 1);
                i2.emplaceBack(t2 + 1, t2 + 1 + r2);
              }
              return i2;
            }();
            this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(e2), this.wireframeSegments = SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, e2.length);
          }
          return [this.wireframeIndexBuffer, this.wireframeSegments];
        }
      }
      class Program {
        static cacheKey(e2, t2, i2, r2) {
          let n2 = `${t2}${r2 ? r2.cacheKey : ""}`;
          for (const t3 of i2)
            e2.usedDefines.includes(t3) && (n2 += `/${t3}`);
          return n2;
        }
        constructor(e2, t2, i2, r2, n2, o2) {
          const s2 = e2.gl;
          this.program = s2.createProgram();
          const a2 = function(e3) {
            const t3 = [];
            for (let i3 = 0; i3 < e3.length; i3++) {
              if (null === e3[i3])
                continue;
              const r3 = e3[i3].split(" ");
              t3.push(r3.pop());
            }
            return t3;
          }(i2.staticAttributes), l2 = r2 ? r2.getBinderAttributes() : [], c2 = a2.concat(l2);
          let u2 = r2 ? r2.defines() : [];
          u2 = u2.concat(o2.map((e3) => `#define ${e3}`));
          const h2 = u2.concat(e2.extStandardDerivatives ? "#extension GL_OES_standard_derivatives : enable\n".concat(Td) : Td, Td, wd, bd.fragmentSource, xd.fragmentSource, i2.fragmentSource).join("\n"), p2 = u2.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", wd, bd.vertexSource, xd.vertexSource, yd.vertexSource, i2.vertexSource).join("\n"), d2 = s2.createShader(s2.FRAGMENT_SHADER);
          if (s2.isContextLost())
            return void (this.failedToCreate = true);
          s2.shaderSource(d2, h2), s2.compileShader(d2), s2.attachShader(this.program, d2);
          const f2 = s2.createShader(s2.VERTEX_SHADER);
          if (s2.isContextLost())
            this.failedToCreate = true;
          else {
            s2.shaderSource(f2, p2), s2.compileShader(f2), s2.attachShader(this.program, f2), this.attributes = {}, this.numAttributes = c2.length;
            for (let e3 = 0; e3 < this.numAttributes; e3++)
              c2[e3] && (s2.bindAttribLocation(this.program, e3, c2[e3]), this.attributes[c2[e3]] = e3);
            s2.linkProgram(this.program), s2.deleteShader(f2), s2.deleteShader(d2), this.fixedUniforms = n2(e2), this.binderUniforms = r2 ? r2.getUniforms(e2) : [], o2.includes("TERRAIN") && (this.terrainUniforms = ((e3) => ({ u_dem: new Uniform1i(e3), u_dem_prev: new Uniform1i(e3), u_dem_unpack: new Uniform4f(e3), u_dem_tl: new Uniform2f(e3), u_dem_scale: new Uniform1f(e3), u_dem_tl_prev: new Uniform2f(e3), u_dem_scale_prev: new Uniform1f(e3), u_dem_size: new Uniform1f(e3), u_dem_lerp: new Uniform1f(e3), u_exaggeration: new Uniform1f(e3), u_depth: new Uniform1i(e3), u_depth_size_inv: new Uniform2f(e3), u_meter_to_dem: new Uniform1f(e3), u_label_plane_matrix_inv: new UniformMatrix4f(e3) }))(e2)), o2.includes("GLOBE") && (this.globeUniforms = ((e3) => ({ u_tile_tl_up: new Uniform3f(e3), u_tile_tr_up: new Uniform3f(e3), u_tile_br_up: new Uniform3f(e3), u_tile_bl_up: new Uniform3f(e3), u_tile_up_scale: new Uniform1f(e3) }))(e2)), o2.includes("FOG") && (this.fogUniforms = ((e3) => ({ u_fog_matrix: new UniformMatrix4f(e3), u_fog_range: new Uniform2f(e3), u_fog_color: new Uniform4f(e3), u_fog_horizon_blend: new Uniform1f(e3), u_fog_temporal_offset: new Uniform1f(e3), u_frustum_tl: new Uniform3f(e3), u_frustum_tr: new Uniform3f(e3), u_frustum_br: new Uniform3f(e3), u_frustum_bl: new Uniform3f(e3), u_globe_pos: new Uniform3f(e3), u_globe_radius: new Uniform1f(e3), u_globe_transition: new Uniform1f(e3), u_is_globe: new Uniform1i(e3), u_viewport: new Uniform2f(e3) }))(e2));
          }
        }
        setTerrainUniformValues(e2, t2) {
          if (!this.terrainUniforms)
            return;
          const i2 = this.terrainUniforms;
          if (!this.failedToCreate) {
            e2.program.set(this.program);
            for (const e3 in t2)
              i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
          }
        }
        setGlobeUniformValues(e2, t2) {
          if (!this.globeUniforms)
            return;
          const i2 = this.globeUniforms;
          if (!this.failedToCreate) {
            e2.program.set(this.program);
            for (const e3 in t2)
              i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
          }
        }
        setFogUniformValues(e2, t2) {
          if (!this.fogUniforms)
            return;
          const i2 = this.fogUniforms;
          if (!this.failedToCreate) {
            e2.program.set(this.program);
            for (const e3 in t2)
              i2[e3].set(this.program, e3, t2[e3]);
          }
        }
        draw(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2) {
          const m2 = e2.gl;
          if (this.failedToCreate)
            return;
          e2.program.set(this.program), e2.setDepthMode(i2), e2.setStencilMode(r2), e2.setColorMode(n2), e2.setCullFace(o2);
          for (const e3 of Object.keys(this.fixedUniforms))
            this.fixedUniforms[e3].set(this.program, e3, s2[e3]);
          d2 && d2.setUniforms(this.program, e2, this.binderUniforms, h2, { zoom: p2 });
          const _2 = { [m2.LINES]: 2, [m2.TRIANGLES]: 3, [m2.LINE_STRIP]: 1 }[t2];
          for (const i3 of u2.get()) {
            const r3 = i3.vaos || (i3.vaos = {});
            (r3[a2] || (r3[a2] = new VertexArrayObject())).bind(e2, this, l2, d2 ? d2.getPaintVertexBuffers() : [], c2, i3.vertexOffset, f2 || []), m2.drawElements(t2, i3.primitiveLength * _2, m2.UNSIGNED_SHORT, i3.primitiveOffset * _2 * 2);
          }
        }
      }
      function Vd(e2, t2) {
        const i2 = Math.pow(2, t2.tileID.overscaledZ), r2 = t2.tileSize * Math.pow(2, e2.transform.tileZoom) / i2, n2 = r2 * (t2.tileID.canonical.x + t2.tileID.wrap * i2), o2 = r2 * t2.tileID.canonical.y;
        return { u_image: 0, u_texsize: t2.imageAtlasTexture.size, u_tile_units_to_pixels: 1 / Mh(t2, 1, e2.transform.tileZoom), u_pixel_coord_upper: [n2 >> 16, o2 >> 16], u_pixel_coord_lower: [65535 & n2, 65535 & o2] };
      }
      const jd = Cs(), Nd = (e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2) => {
        const h2 = t2.style.light, p2 = h2.properties.get("position"), d2 = [p2.x, p2.y, p2.z], f2 = Es();
        var m2, _2, g2, y2;
        "viewport" === h2.properties.get("anchor") && (m2 = f2, _2 = -t2.transform.angle, g2 = Math.sin(_2), y2 = Math.cos(_2), m2[0] = y2, m2[1] = g2, m2[2] = 0, m2[3] = -g2, m2[4] = y2, m2[5] = 0, m2[6] = 0, m2[7] = 0, m2[8] = 1, na(d2, d2, f2));
        const x2 = h2.properties.get("color"), v2 = t2.transform, b2 = { u_matrix: e2, u_lightpos: d2, u_lightintensity: h2.properties.get("intensity"), u_lightcolor: [x2.r, x2.g, x2.b], u_vertical_gradient: +i2, u_opacity: r2, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: jd, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: n2, u_edge_radius: o2 };
        return "globe" === v2.projection.name && (b2.u_tile_id = [s2.canonical.x, s2.canonical.y, 1 << s2.canonical.z], b2.u_zoom_transition = l2, b2.u_inv_rot_matrix = u2, b2.u_merc_center = c2, b2.u_up_dir = v2.projection.upVector(new CanonicalTileID(0, 0, 0), c2[0] * ko, c2[1] * ko), b2.u_height_lift = a2), b2;
      }, Gd = (e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2) => {
        const p2 = Nd(e2, t2, i2, r2, n2, o2, s2, l2, c2, u2, h2), d2 = { u_height_factor: -Math.pow(2, s2.overscaledZ) / a2.tileSize / 8 };
        return P(p2, Vd(t2, a2), d2);
      }, qd = (e2) => ({ u_matrix: e2 }), Zd = (e2, t2, i2) => P(qd(e2), Vd(t2, i2)), $d = (e2, t2) => ({ u_matrix: e2, u_world: t2 }), Wd = (e2, t2, i2, r2) => P(Zd(e2, t2, i2), { u_world: r2 }), Hd = Cs(), Xd = (e2, t2, i2, r2, n2, o2) => {
        const s2 = e2.transform, a2 = "globe" === s2.projection.name;
        let l2;
        if ("map" === o2.paint.get("circle-pitch-alignment"))
          if (a2) {
            const e3 = Du(s2.zoom, t2.canonical) * s2._pixelsPerMercatorPixel;
            l2 = Float32Array.from([e3, 0, 0, e3]);
          } else
            l2 = s2.calculatePixelsToTileUnitsMatrix(i2);
        else
          l2 = new Float32Array([s2.pixelsToGLUnits[0], 0, 0, s2.pixelsToGLUnits[1]]);
        const c2 = { u_camera_to_center_distance: s2.cameraToCenterDistance, u_matrix: e2.translatePosMatrix(t2.projMatrix, i2, o2.paint.get("circle-translate"), o2.paint.get("circle-translate-anchor")), u_device_pixel_ratio: Je.devicePixelRatio, u_extrude_scale: l2, u_inv_rot_matrix: Hd, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (a2) {
          c2.u_inv_rot_matrix = r2, c2.u_merc_center = n2, c2.u_tile_id = [t2.canonical.x, t2.canonical.y, 1 << t2.canonical.z], c2.u_zoom_transition = zu(s2.zoom);
          const e3 = n2[0] * ko, i3 = n2[1] * ko;
          c2.u_up_dir = s2.projection.upVector(new CanonicalTileID(0, 0, 0), e3, i3);
        }
        return c2;
      }, Kd = (e2) => {
        const t2 = [];
        return "map" === e2.paint.get("circle-pitch-alignment") && t2.push("PITCH_WITH_MAP"), "map" === e2.paint.get("circle-pitch-scale") && t2.push("SCALE_WITH_MAP"), t2;
      }, Yd = (e2, t2, i2, r2) => {
        const n2 = ko / i2.tileSize;
        return { u_matrix: e2, u_camera_to_center_distance: t2.getCameraToCenterDistance(r2), u_extrude_scale: [t2.pixelsToGLUnits[0] / n2, t2.pixelsToGLUnits[1] / n2] };
      }, Jd = (e2, t2, i2 = 1) => ({ u_matrix: e2, u_color: t2, u_overlay: 0, u_overlay_scale: i2 }), Qd = Cs(), ef = (e2, t2, i2, r2, n2, o2, s2) => {
        const a2 = e2.transform, l2 = "globe" === a2.projection.name, c2 = l2 ? Du(a2.zoom, t2.canonical) * a2._pixelsPerMercatorPixel : Mh(i2, 1, o2), u2 = { u_matrix: t2.projMatrix, u_extrude_scale: c2, u_intensity: s2, u_inv_rot_matrix: Qd, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (l2) {
          u2.u_inv_rot_matrix = r2, u2.u_merc_center = n2, u2.u_tile_id = [t2.canonical.x, t2.canonical.y, 1 << t2.canonical.z], u2.u_zoom_transition = zu(a2.zoom);
          const e3 = n2[0] * ko, i3 = n2[1] * ko;
          u2.u_up_dir = a2.projection.upVector(new CanonicalTileID(0, 0, 0), e3, i3);
        }
        return u2;
      }, tf = (e2, t2, i2, r2, n2, o2, s2) => {
        const a2 = e2.transform, l2 = a2.calculatePixelsToTileUnitsMatrix(t2);
        return { u_matrix: of(e2, t2, i2, r2), u_pixels_to_tile_units: l2, u_device_pixel_ratio: o2, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: n2, u_texsize: sf(i2) ? t2.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: nf(t2, e2.transform), u_alpha_discard_threshold: 0, u_trim_offset: s2 };
      }, rf = (e2, t2, i2, r2, n2) => {
        const o2 = e2.transform;
        return { u_matrix: of(e2, t2, i2, r2), u_texsize: t2.imageAtlasTexture.size, u_pixels_to_tile_units: o2.calculatePixelsToTileUnitsMatrix(t2), u_device_pixel_ratio: n2, u_image: 0, u_tile_units_to_pixels: nf(t2, o2), u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
      };
      function nf(e2, t2) {
        return 1 / Mh(e2, 1, t2.tileZoom);
      }
      function of(e2, t2, i2, r2) {
        return e2.translatePosMatrix(r2 || t2.tileID.projMatrix, t2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
      }
      function sf(e2) {
        const t2 = e2.paint.get("line-dasharray").value;
        return t2.value || "constant" !== t2.kind;
      }
      const af = (e2, t2, i2, r2, n2, o2) => {
        return { u_matrix: e2, u_tl_parent: t2, u_scale_parent: i2, u_fade_t: r2.mix, u_opacity: r2.opacity * n2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: n2.paint.get("raster-brightness-min"), u_brightness_high: n2.paint.get("raster-brightness-max"), u_saturation_factor: (a2 = n2.paint.get("raster-saturation"), a2 > 0 ? 1 - 1 / (1.001 - a2) : -a2), u_contrast_factor: (s2 = n2.paint.get("raster-contrast"), s2 > 0 ? 1 / (1 - s2) : 1 + s2), u_spin_weights: lf(n2.paint.get("raster-hue-rotate")), u_perspective_transform: o2 };
        var s2, a2;
      };
      function lf(e2) {
        e2 *= Math.PI / 180;
        const t2 = Math.sin(e2), i2 = Math.cos(e2);
        return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
      }
      const cf = Cs(), uf = (e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2, m2) => {
        const _2 = n2.transform, g2 = { u_is_size_zoom_constant: +("constant" === e2 || "source" === e2), u_is_size_feature_constant: +("constant" === e2 || "camera" === e2), u_size_t: t2 ? t2.uSizeT : 0, u_size: t2 ? t2.uSize : 0, u_camera_to_center_distance: _2.cameraToCenterDistance, u_rotate_symbol: +i2, u_aspect_ratio: _2.width / _2.height, u_fade_change: n2.options.fadeDuration ? n2.symbolFadeChange : 1, u_matrix: o2, u_label_plane_matrix: s2, u_coord_matrix: a2, u_is_text: +l2, u_pitch_with_map: +r2, u_texsize: c2, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: cf, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: cf, u_up_vector: [0, -1, 0] };
        return "globe" === m2.name && (g2.u_tile_id = [u2.canonical.x, u2.canonical.y, 1 << u2.canonical.z], g2.u_zoom_transition = h2, g2.u_inv_rot_matrix = d2, g2.u_merc_center = p2, g2.u_camera_forward = _2._camera.forward(), g2.u_ecef_origin = function(e3, t3) {
          const i3 = [0, 0, 0];
          return ra(i3, i3, Iu(_u(t3.canonical))), ra(i3, i3, e3), i3;
        }(_2.globeMatrix, u2.toUnwrapped()), g2.u_tile_matrix = Float32Array.from(_2.globeMatrix), g2.u_up_vector = f2), g2;
      }, hf = (e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2, m2, _2) => P(uf(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, h2, p2, d2, f2, m2, _2), { u_gamma_scale: r2 ? n2.transform.cameraToCenterDistance * Math.cos(n2.terrain ? 0 : n2.transform._pitch) : 1, u_device_pixel_ratio: Je.devicePixelRatio, u_is_halo: +u2 }), pf = (e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2, p2, d2, f2, m2) => P(hf(e2, t2, i2, r2, n2, o2, s2, a2, true, l2, true, u2, h2, p2, d2, f2, m2), { u_texsize_icon: c2, u_texture_icon: 1 }), df = (e2, t2, i2) => ({ u_matrix: e2, u_opacity: t2, u_color: i2 }), ff = (e2, t2, i2, r2, n2) => P(function(e3, t3, i3) {
        const r3 = t3.imageManager.getPattern(e3.toString()), { width: n3, height: o2 } = t3.imageManager.getPixelSize(), s2 = Math.pow(2, i3.tileID.overscaledZ), a2 = i3.tileSize * Math.pow(2, t3.transform.tileZoom) / s2, l2 = a2 * (i3.tileID.canonical.x + i3.tileID.wrap * s2), c2 = a2 * i3.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl: r3.tl, u_pattern_br: r3.br, u_texsize: [n3, o2], u_pattern_size: r3.displaySize, u_tile_units_to_pixels: 1 / Mh(i3, 1, t3.transform.tileZoom), u_pixel_coord_upper: [l2 >> 16, c2 >> 16], u_pixel_coord_lower: [65535 & l2, 65535 & c2] };
      }(r2, i2, n2), { u_matrix: e2, u_opacity: t2 }), mf = { fillExtrusion: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_lightpos: new Uniform3f(e2), u_lightintensity: new Uniform1f(e2), u_lightcolor: new Uniform3f(e2), u_vertical_gradient: new Uniform1f(e2), u_opacity: new Uniform1f(e2), u_edge_radius: new Uniform1f(e2), u_ao: new Uniform2f(e2), u_tile_id: new Uniform3f(e2), u_zoom_transition: new Uniform1f(e2), u_inv_rot_matrix: new UniformMatrix4f(e2), u_merc_center: new Uniform2f(e2), u_up_dir: new Uniform3f(e2), u_height_lift: new Uniform1f(e2) }), fillExtrusionPattern: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_lightpos: new Uniform3f(e2), u_lightintensity: new Uniform1f(e2), u_lightcolor: new Uniform3f(e2), u_vertical_gradient: new Uniform1f(e2), u_height_factor: new Uniform1f(e2), u_edge_radius: new Uniform1f(e2), u_ao: new Uniform2f(e2), u_tile_id: new Uniform3f(e2), u_zoom_transition: new Uniform1f(e2), u_inv_rot_matrix: new UniformMatrix4f(e2), u_merc_center: new Uniform2f(e2), u_up_dir: new Uniform3f(e2), u_height_lift: new Uniform1f(e2), u_image: new Uniform1i(e2), u_texsize: new Uniform2f(e2), u_pixel_coord_upper: new Uniform2f(e2), u_pixel_coord_lower: new Uniform2f(e2), u_tile_units_to_pixels: new Uniform1f(e2), u_opacity: new Uniform1f(e2) }), fill: (e2) => ({ u_matrix: new UniformMatrix4f(e2) }), fillPattern: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_image: new Uniform1i(e2), u_texsize: new Uniform2f(e2), u_pixel_coord_upper: new Uniform2f(e2), u_pixel_coord_lower: new Uniform2f(e2), u_tile_units_to_pixels: new Uniform1f(e2) }), fillOutline: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_world: new Uniform2f(e2) }), fillOutlinePattern: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_world: new Uniform2f(e2), u_image: new Uniform1i(e2), u_texsize: new Uniform2f(e2), u_pixel_coord_upper: new Uniform2f(e2), u_pixel_coord_lower: new Uniform2f(e2), u_tile_units_to_pixels: new Uniform1f(e2) }), circle: (e2) => ({ u_camera_to_center_distance: new Uniform1f(e2), u_extrude_scale: new UniformMatrix2f(e2), u_device_pixel_ratio: new Uniform1f(e2), u_matrix: new UniformMatrix4f(e2), u_inv_rot_matrix: new UniformMatrix4f(e2), u_merc_center: new Uniform2f(e2), u_tile_id: new Uniform3f(e2), u_zoom_transition: new Uniform1f(e2), u_up_dir: new Uniform3f(e2) }), collisionBox: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_camera_to_center_distance: new Uniform1f(e2), u_extrude_scale: new Uniform2f(e2) }), collisionCircle: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_inv_matrix: new UniformMatrix4f(e2), u_camera_to_center_distance: new Uniform1f(e2), u_viewport_size: new Uniform2f(e2) }), debug: (e2) => ({ u_color: new UniformColor(e2), u_matrix: new UniformMatrix4f(e2), u_overlay: new Uniform1i(e2), u_overlay_scale: new Uniform1f(e2) }), clippingMask: (e2) => ({ u_matrix: new UniformMatrix4f(e2) }), heatmap: (e2) => ({ u_extrude_scale: new Uniform1f(e2), u_intensity: new Uniform1f(e2), u_matrix: new UniformMatrix4f(e2), u_inv_rot_matrix: new UniformMatrix4f(e2), u_merc_center: new Uniform2f(e2), u_tile_id: new Uniform3f(e2), u_zoom_transition: new Uniform1f(e2), u_up_dir: new Uniform3f(e2) }), heatmapTexture: (e2) => ({ u_image: new Uniform1i(e2), u_color_ramp: new Uniform1i(e2), u_opacity: new Uniform1f(e2) }), hillshade: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_image: new Uniform1i(e2), u_latrange: new Uniform2f(e2), u_light: new Uniform2f(e2), u_shadow: new UniformColor(e2), u_highlight: new UniformColor(e2), u_accent: new UniformColor(e2) }), hillshadePrepare: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_image: new Uniform1i(e2), u_dimension: new Uniform2f(e2), u_zoom: new Uniform1f(e2), u_unpack: new Uniform4f(e2) }), line: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_pixels_to_tile_units: new UniformMatrix2f(e2), u_device_pixel_ratio: new Uniform1f(e2), u_units_to_pixels: new Uniform2f(e2), u_dash_image: new Uniform1i(e2), u_gradient_image: new Uniform1i(e2), u_image_height: new Uniform1f(e2), u_texsize: new Uniform2f(e2), u_tile_units_to_pixels: new Uniform1f(e2), u_alpha_discard_threshold: new Uniform1f(e2), u_trim_offset: new Uniform2f(e2) }), linePattern: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_texsize: new Uniform2f(e2), u_pixels_to_tile_units: new UniformMatrix2f(e2), u_device_pixel_ratio: new Uniform1f(e2), u_image: new Uniform1i(e2), u_units_to_pixels: new Uniform2f(e2), u_tile_units_to_pixels: new Uniform1f(e2), u_alpha_discard_threshold: new Uniform1f(e2) }), raster: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_tl_parent: new Uniform2f(e2), u_scale_parent: new Uniform1f(e2), u_fade_t: new Uniform1f(e2), u_opacity: new Uniform1f(e2), u_image0: new Uniform1i(e2), u_image1: new Uniform1i(e2), u_brightness_low: new Uniform1f(e2), u_brightness_high: new Uniform1f(e2), u_saturation_factor: new Uniform1f(e2), u_contrast_factor: new Uniform1f(e2), u_spin_weights: new Uniform3f(e2), u_perspective_transform: new Uniform2f(e2) }), symbolIcon: (e2) => ({ u_is_size_zoom_constant: new Uniform1i(e2), u_is_size_feature_constant: new Uniform1i(e2), u_size_t: new Uniform1f(e2), u_size: new Uniform1f(e2), u_camera_to_center_distance: new Uniform1f(e2), u_rotate_symbol: new Uniform1i(e2), u_aspect_ratio: new Uniform1f(e2), u_fade_change: new Uniform1f(e2), u_matrix: new UniformMatrix4f(e2), u_label_plane_matrix: new UniformMatrix4f(e2), u_coord_matrix: new UniformMatrix4f(e2), u_is_text: new Uniform1i(e2), u_pitch_with_map: new Uniform1i(e2), u_texsize: new Uniform2f(e2), u_tile_id: new Uniform3f(e2), u_zoom_transition: new Uniform1f(e2), u_inv_rot_matrix: new UniformMatrix4f(e2), u_merc_center: new Uniform2f(e2), u_camera_forward: new Uniform3f(e2), u_tile_matrix: new UniformMatrix4f(e2), u_up_vector: new Uniform3f(e2), u_ecef_origin: new Uniform3f(e2), u_texture: new Uniform1i(e2) }), symbolSDF: (e2) => ({ u_is_size_zoom_constant: new Uniform1i(e2), u_is_size_feature_constant: new Uniform1i(e2), u_size_t: new Uniform1f(e2), u_size: new Uniform1f(e2), u_camera_to_center_distance: new Uniform1f(e2), u_rotate_symbol: new Uniform1i(e2), u_aspect_ratio: new Uniform1f(e2), u_fade_change: new Uniform1f(e2), u_matrix: new UniformMatrix4f(e2), u_label_plane_matrix: new UniformMatrix4f(e2), u_coord_matrix: new UniformMatrix4f(e2), u_is_text: new Uniform1i(e2), u_pitch_with_map: new Uniform1i(e2), u_texsize: new Uniform2f(e2), u_texture: new Uniform1i(e2), u_gamma_scale: new Uniform1f(e2), u_device_pixel_ratio: new Uniform1f(e2), u_tile_id: new Uniform3f(e2), u_zoom_transition: new Uniform1f(e2), u_inv_rot_matrix: new UniformMatrix4f(e2), u_merc_center: new Uniform2f(e2), u_camera_forward: new Uniform3f(e2), u_tile_matrix: new UniformMatrix4f(e2), u_up_vector: new Uniform3f(e2), u_ecef_origin: new Uniform3f(e2), u_is_halo: new Uniform1i(e2) }), symbolTextAndIcon: (e2) => ({ u_is_size_zoom_constant: new Uniform1i(e2), u_is_size_feature_constant: new Uniform1i(e2), u_size_t: new Uniform1f(e2), u_size: new Uniform1f(e2), u_camera_to_center_distance: new Uniform1f(e2), u_rotate_symbol: new Uniform1i(e2), u_aspect_ratio: new Uniform1f(e2), u_fade_change: new Uniform1f(e2), u_matrix: new UniformMatrix4f(e2), u_label_plane_matrix: new UniformMatrix4f(e2), u_coord_matrix: new UniformMatrix4f(e2), u_is_text: new Uniform1i(e2), u_pitch_with_map: new Uniform1i(e2), u_texsize: new Uniform2f(e2), u_texsize_icon: new Uniform2f(e2), u_texture: new Uniform1i(e2), u_texture_icon: new Uniform1i(e2), u_gamma_scale: new Uniform1f(e2), u_device_pixel_ratio: new Uniform1f(e2), u_is_halo: new Uniform1i(e2) }), background: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_opacity: new Uniform1f(e2), u_color: new UniformColor(e2) }), backgroundPattern: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_opacity: new Uniform1f(e2), u_image: new Uniform1i(e2), u_pattern_tl: new Uniform2f(e2), u_pattern_br: new Uniform2f(e2), u_texsize: new Uniform2f(e2), u_pattern_size: new Uniform2f(e2), u_pixel_coord_upper: new Uniform2f(e2), u_pixel_coord_lower: new Uniform2f(e2), u_tile_units_to_pixels: new Uniform1f(e2) }), terrainRaster: Pd, terrainDepth: Pd, skybox: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_sun_direction: new Uniform3f(e2), u_cubemap: new Uniform1i(e2), u_opacity: new Uniform1f(e2), u_temporal_offset: new Uniform1f(e2) }), skyboxGradient: (e2) => ({ u_matrix: new UniformMatrix4f(e2), u_color_ramp: new Uniform1i(e2), u_center_direction: new Uniform3f(e2), u_radius: new Uniform1f(e2), u_opacity: new Uniform1f(e2), u_temporal_offset: new Uniform1f(e2) }), skyboxCapture: (e2) => ({ u_matrix_3f: new UniformMatrix3f(e2), u_sun_direction: new Uniform3f(e2), u_sun_intensity: new Uniform1f(e2), u_color_tint_r: new Uniform4f(e2), u_color_tint_m: new Uniform4f(e2), u_luminance: new Uniform1f(e2) }), globeRaster: (e2) => ({ u_proj_matrix: new UniformMatrix4f(e2), u_globe_matrix: new UniformMatrix4f(e2), u_normalize_matrix: new UniformMatrix4f(e2), u_merc_matrix: new UniformMatrix4f(e2), u_zoom_transition: new Uniform1f(e2), u_merc_center: new Uniform2f(e2), u_image0: new Uniform1i(e2), u_grid_matrix: new UniformMatrix3f(e2), u_frustum_tl: new Uniform3f(e2), u_frustum_tr: new Uniform3f(e2), u_frustum_br: new Uniform3f(e2), u_frustum_bl: new Uniform3f(e2), u_globe_pos: new Uniform3f(e2), u_globe_radius: new Uniform1f(e2), u_viewport: new Uniform2f(e2) }), globeAtmosphere: (e2) => ({ u_frustum_tl: new Uniform3f(e2), u_frustum_tr: new Uniform3f(e2), u_frustum_br: new Uniform3f(e2), u_frustum_bl: new Uniform3f(e2), u_horizon: new Uniform1f(e2), u_transition: new Uniform1f(e2), u_fadeout_range: new Uniform1f(e2), u_color: new Uniform4f(e2), u_high_color: new Uniform4f(e2), u_space_color: new Uniform4f(e2), u_star_intensity: new Uniform1f(e2), u_star_density: new Uniform1f(e2), u_star_size: new Uniform1f(e2), u_temporal_offset: new Uniform1f(e2), u_horizon_angle: new Uniform1f(e2), u_rotation_matrix: new UniformMatrix4f(e2) }) };
      let _f;
      function gf(e2, t2, i2, r2, n2, o2, s2) {
        const a2 = e2.context, l2 = a2.gl, c2 = e2.transform, u2 = e2.useProgram("collisionBox"), h2 = [];
        let p2 = 0, d2 = 0;
        for (let f3 = 0; f3 < r2.length; f3++) {
          const m3 = r2[f3], _3 = t2.getTile(m3), g3 = _3.getBucket(i2);
          if (!g3)
            continue;
          const y3 = Hp(m3, g3, c2);
          let x3 = y3;
          0 === n2[0] && 0 === n2[1] || (x3 = e2.translatePosMatrix(y3, _3, n2, o2));
          const v2 = s2 ? g3.textCollisionBox : g3.iconCollisionBox, b2 = g3.collisionCircleArray;
          if (b2.length > 0) {
            const e3 = Cs(), t3 = x3;
            js(e3, g3.placementInvProjMatrix, c2.glCoordMatrix), js(e3, e3, g3.placementViewportMatrix), h2.push({ circleArray: b2, circleOffset: d2, transform: t3, invTransform: e3, projection: g3.getProjection() }), p2 += b2.length / 4, d2 = p2;
          }
          v2 && (e2.terrain && e2.terrain.setupElevationDraw(_3, u2), u2.draw(a2, l2.LINES, DepthMode.disabled, StencilMode.disabled, e2.colorModeForRenderPass(), CullFaceMode.disabled, Yd(x3, c2, _3, g3.getProjection()), i2.id, v2.layoutVertexBuffer, v2.indexBuffer, v2.segments, null, c2.zoom, null, [v2.collisionVertexBuffer, v2.collisionVertexBufferExt]));
        }
        if (!s2 || !h2.length)
          return;
        const f2 = e2.useProgram("collisionCircle"), m2 = new StructArrayLayout2f1f2i16();
        m2.resize(4 * p2), m2._trim();
        let _2 = 0;
        for (const e3 of h2)
          for (let t3 = 0; t3 < e3.circleArray.length / 4; t3++) {
            const i3 = 4 * t3, r3 = e3.circleArray[i3 + 0], n3 = e3.circleArray[i3 + 1], o3 = e3.circleArray[i3 + 2], s3 = e3.circleArray[i3 + 3];
            m2.emplace(_2++, r3, n3, o3, s3, 0), m2.emplace(_2++, r3, n3, o3, s3, 1), m2.emplace(_2++, r3, n3, o3, s3, 2), m2.emplace(_2++, r3, n3, o3, s3, 3);
          }
        (!_f || _f.length < 2 * p2) && (_f = function(e3) {
          const t3 = 2 * e3, i3 = new StructArrayLayout3ui6();
          i3.resize(t3), i3._trim();
          for (let e4 = 0; e4 < t3; e4++) {
            const t4 = 6 * e4;
            i3.uint16[t4 + 0] = 4 * e4 + 0, i3.uint16[t4 + 1] = 4 * e4 + 1, i3.uint16[t4 + 2] = 4 * e4 + 2, i3.uint16[t4 + 3] = 4 * e4 + 2, i3.uint16[t4 + 4] = 4 * e4 + 3, i3.uint16[t4 + 5] = 4 * e4 + 0;
          }
          return i3;
        }(p2));
        const g2 = a2.createIndexBuffer(_f, true), y2 = a2.createVertexBuffer(m2, mc.members, true);
        for (const t3 of h2) {
          const r3 = { u_matrix: t3.transform, u_inv_matrix: t3.invTransform, u_camera_to_center_distance: (x2 = c2).getCameraToCenterDistance(t3.projection), u_viewport_size: [x2.width, x2.height] };
          f2.draw(a2, l2.TRIANGLES, DepthMode.disabled, StencilMode.disabled, e2.colorModeForRenderPass(), CullFaceMode.disabled, r3, i2.id, y2, g2, SegmentVector.simpleSegment(0, 2 * t3.circleOffset, t3.circleArray.length, t3.circleArray.length / 2), null, c2.zoom);
        }
        var x2;
        y2.destroy(), g2.destroy();
      }
      const yf = Cs();
      function xf({ width: e2, height: t2, anchor: i2, textOffset: r2, textScale: n2 }, o2) {
        const { horizontalAlign: s2, verticalAlign: a2 } = Kc(i2), l2 = -(s2 - 0.5) * e2, c2 = -(a2 - 0.5) * t2, u2 = iu(i2, r2);
        return new d((l2 / n2 + u2[0]) * o2, (c2 / n2 + u2[1]) * o2);
      }
      function vf(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2) {
        const h2 = e2.text.placedSymbolArray, p2 = e2.text.dynamicLayoutVertexArray, d2 = e2.icon.dynamicLayoutVertexArray, f2 = {}, m2 = e2.getProjection(), _2 = Xp(a2, m2, o2), g2 = o2.elevation, y2 = m2.upVectorScale(a2.canonical, o2.center.lat, o2.worldSize).metersToTile;
        p2.clear();
        for (let d3 = 0; d3 < h2.length; d3++) {
          const x2 = h2.get(d3), { tileAnchorX: v2, tileAnchorY: b2, numGlyphs: w2 } = x2, T2 = e2.allowVerticalPlacement && !x2.placedOrientation, E2 = x2.hidden || !x2.crossTileID || T2 ? null : r2[x2.crossTileID];
          if (E2) {
            let r3 = 0, h3 = 0, d4 = 0;
            if (g2) {
              const e3 = g2 ? g2.getAtTileOffset(a2, v2, b2) : 0, [t3, i3, n3] = m2.upVector(a2.canonical, v2, b2);
              r3 = e3 * t3 * y2, h3 = e3 * i3 * y2, d4 = e3 * n3 * y2;
            }
            let [T3, S2, A2, C2] = kp(x2.projectedAnchorX + r3, x2.projectedAnchorY + h3, x2.projectedAnchorZ + d4, i2 ? _2 : s2);
            const I2 = Bp(o2.getCameraToCenterDistance(m2), C2);
            let M2 = n2.evaluateSizeForFeature(e2.textSizeData, c2, x2) * I2 / 24;
            i2 && (M2 *= e2.tilePixelRatio / l2);
            const D2 = xf(E2, M2);
            i2 ? ({ x: T3, y: S2, z: A2 } = m2.projectTilePoint(v2 + D2.x, b2 + D2.y, a2.canonical), [T3, S2, A2] = kp(T3 + r3, S2 + h3, A2 + d4, s2)) : (t2 && D2._rotate(-o2.angle), T3 += D2.x, S2 += D2.y, A2 = 0);
            const P2 = e2.allowVerticalPlacement && x2.placedOrientation === Xc.vertical ? Math.PI / 2 : 0;
            for (let e3 = 0; e3 < w2; e3++)
              uh(p2, T3, S2, A2, P2);
            u2 && x2.associatedIconIndex >= 0 && (f2[x2.associatedIconIndex] = { x: T3, y: S2, z: A2, angle: P2 });
          } else
            qp(w2, p2);
        }
        if (u2) {
          d2.clear();
          const t3 = e2.icon.placedSymbolArray;
          for (let e3 = 0; e3 < t3.length; e3++) {
            const i3 = t3.get(e3), { numGlyphs: r3 } = i3, n3 = f2[e3];
            if (i3.hidden || !n3)
              qp(r3, d2);
            else {
              const { x: e4, y: t4, z: i4, angle: o3 } = n3;
              for (let n4 = 0; n4 < r3; n4++)
                uh(d2, e4, t4, i4, o3);
            }
          }
          e2.icon.dynamicLayoutVertexBuffer.updateData(d2);
        }
        e2.text.dynamicLayoutVertexBuffer.updateData(p2);
      }
      function bf(e2, t2, i2) {
        return i2.iconsInText && t2 ? "symbolTextAndIcon" : e2 ? "symbolSDF" : "symbolIcon";
      }
      function wf(e2, t2, i2, r2, n2, o2, s2, a2, l2, c2, u2, h2) {
        const p2 = e2.context, d2 = p2.gl, f2 = e2.transform, m2 = "map" === a2, _2 = "map" === l2, g2 = m2 && "point" !== i2.layout.get("symbol-placement"), y2 = m2 && !_2 && !g2, x2 = void 0 !== i2.layout.get("symbol-sort-key").constantOr(1);
        let v2 = false;
        const b2 = e2.depthModeForSublayer(0, DepthMode.ReadOnly), w2 = [Oo(f2.center.lng), Uo(f2.center.lat)], T2 = i2.layout.get("text-variable-anchor"), E2 = "globe" === f2.projection.name, S2 = [], A2 = [0, -1, 0];
        let C2 = A2;
        !E2 && !f2.mercatorFromTransition || m2 || (C2 = function(e3) {
          const t3 = Ds([], e3._camera.getWorldToCamera(e3.worldSize, 1), e3.globeMatrix);
          Ms(t3, t3);
          const i3 = [0, 0, 0], r3 = [0, 1, 0, 0];
          return da(r3, r3, t3), i3[0] = r3[0], i3[1] = r3[1], i3[2] = r3[2], ea(i3, i3), i3;
        }(f2));
        for (const a3 of r2) {
          const r3 = t2.getTile(a3), l3 = r3.getBucket(i2);
          if (!l3)
            continue;
          if ("mercator" === l3.projection.name && E2)
            continue;
          const u3 = n2 ? l3.text : l3.icon;
          if (!u3 || l3.fullyClipped || !u3.segments.get().length)
            continue;
          const h3 = u3.programConfigurations.get(i2.id), p3 = n2 || l3.sdfIcons, b3 = n2 ? l3.textSizeData : l3.iconSizeData, I2 = _2 || 0 !== f2.pitch, M2 = xc(b3, f2.zoom);
          let D2, P2, z2, L2, k2 = [0, 0], B2 = null;
          if (n2) {
            if (P2 = r3.glyphAtlasTexture, z2 = d2.LINEAR, D2 = r3.glyphAtlasTexture.size, l3.iconsInText) {
              k2 = r3.imageAtlasTexture.size, B2 = r3.imageAtlasTexture;
              const t3 = "composite" === b3.kind || "camera" === b3.kind;
              L2 = I2 || e2.options.rotating || e2.options.zooming || t3 ? d2.LINEAR : d2.NEAREST;
            }
          } else {
            const t3 = 1 !== i2.layout.get("icon-size").constantOr(0) || l3.iconsNeedLinear;
            P2 = r3.imageAtlasTexture, z2 = p3 || e2.options.rotating || e2.options.zooming || t3 || I2 ? d2.LINEAR : d2.NEAREST, D2 = r3.imageAtlasTexture.size;
          }
          const R2 = "globe" === l3.projection.name, F2 = R2 ? C2 : A2, O2 = R2 ? zu(f2.zoom) : 0, U2 = Xp(a3, l3.getProjection(), f2), V2 = f2.calculatePixelsToTileUnitsMatrix(r3), j2 = Pp(U2, r3.tileID.canonical, _2, m2, f2, l3.getProjection(), V2), N2 = e2.terrain && _2 && g2 ? Ms(Cs(), j2) : yf, G2 = Lp(U2, r3.tileID.canonical, _2, m2, f2, l3.getProjection(), V2), q2 = T2 && l3.hasTextData(), Z2 = "none" !== i2.layout.get("icon-text-fit") && q2 && l3.hasIconData();
          if (g2) {
            const t3 = f2.elevation, i3 = t3 ? t3.getAtTileOffsetFunc(a3, f2.center.lat, f2.worldSize, l3.getProjection()) : null, o3 = zp(U2, r3.tileID.canonical, _2, m2, f2, l3.getProjection(), V2);
            Fp(l3, U2, e2, n2, o3, G2, _2, c2, i3, a3);
          }
          const $2 = g2 || n2 && T2 || Z2, W2 = e2.translatePosMatrix(U2, r3, o2, s2), H2 = $2 ? yf : j2, X2 = e2.translatePosMatrix(G2, r3, o2, s2, true), K2 = l3.getProjection().createInversionMatrix(f2, a3.canonical), Y2 = [];
          e2.terrainRenderModeElevated() && _2 && Y2.push("PITCH_WITH_MAP_TERRAIN"), R2 && Y2.push("PROJECTION_GLOBE_VIEW"), $2 && Y2.push("PROJECTED_POS_ON_VIEWPORT");
          const J2 = p3 && 0 !== i2.paint.get(n2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
          let Q2;
          Q2 = p3 ? l3.iconsInText ? pf(b3.kind, M2, y2, _2, e2, W2, H2, X2, D2, k2, a3, O2, w2, K2, F2, l3.getProjection()) : hf(b3.kind, M2, y2, _2, e2, W2, H2, X2, n2, D2, true, a3, O2, w2, K2, F2, l3.getProjection()) : uf(b3.kind, M2, y2, _2, e2, W2, H2, X2, n2, D2, a3, O2, w2, K2, F2, l3.getProjection());
          const ee2 = { program: e2.useProgram(bf(p3, n2, l3), h3, Y2), buffers: u3, uniformValues: Q2, atlasTexture: P2, atlasTextureIcon: B2, atlasInterpolation: z2, atlasInterpolationIcon: L2, isSDF: p3, hasHalo: J2, tile: r3, labelPlaneMatrixInv: N2 };
          if (x2 && l3.canOverlap) {
            v2 = true;
            const e3 = u3.segments.get();
            for (const t3 of e3)
              S2.push({ segments: new SegmentVector([t3]), sortKey: t3.sortKey, state: ee2 });
          } else
            S2.push({ segments: u3.segments, sortKey: 0, state: ee2 });
        }
        v2 && S2.sort((e3, t3) => e3.sortKey - t3.sortKey);
        for (const t3 of S2) {
          const r3 = t3.state;
          if (e2.terrain && e2.terrain.setupElevationDraw(r3.tile, r3.program, { useDepthForOcclusion: !E2, labelPlaneMatrixInv: r3.labelPlaneMatrixInv }), p2.activeTexture.set(d2.TEXTURE0), r3.atlasTexture.bind(r3.atlasInterpolation, d2.CLAMP_TO_EDGE), r3.atlasTextureIcon && (p2.activeTexture.set(d2.TEXTURE1), r3.atlasTextureIcon && r3.atlasTextureIcon.bind(r3.atlasInterpolationIcon, d2.CLAMP_TO_EDGE)), r3.isSDF) {
            const n3 = r3.uniformValues;
            r3.hasHalo && (n3.u_is_halo = 1, Tf(r3.buffers, t3.segments, i2, e2, r3.program, b2, u2, h2, n3)), n3.u_is_halo = 0;
          }
          Tf(r3.buffers, t3.segments, i2, e2, r3.program, b2, u2, h2, r3.uniformValues);
        }
      }
      function Tf(e2, t2, i2, r2, n2, o2, s2, a2, l2) {
        const c2 = r2.context, u2 = [e2.dynamicLayoutVertexBuffer, e2.opacityVertexBuffer, e2.globeExtVertexBuffer];
        n2.draw(c2, c2.gl.TRIANGLES, o2, s2, a2, CullFaceMode.disabled, l2, i2.id, e2.layoutVertexBuffer, e2.indexBuffer, t2, i2.paint, r2.transform.zoom, e2.programConfigurations.get(i2.id), u2);
      }
      function Ef(e2, t2, i2, r2, n2, o2, s2) {
        const a2 = e2.context.gl, l2 = i2.paint.get("fill-pattern"), c2 = l2 && l2.constantOr(1);
        let u2, h2, p2, d2, f2;
        s2 ? (h2 = c2 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u2 = a2.LINES) : (h2 = c2 ? "fillPattern" : "fill", u2 = a2.TRIANGLES);
        for (const m2 of r2) {
          const r3 = t2.getTile(m2);
          if (c2 && !r3.patternsLoaded())
            continue;
          const _2 = r3.getBucket(i2);
          if (!_2)
            continue;
          e2.prepareDrawTile();
          const g2 = _2.programConfigurations.get(i2.id), y2 = e2.useProgram(h2, g2);
          c2 && (e2.context.activeTexture.set(a2.TEXTURE0), r3.imageAtlasTexture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE), g2.updatePaintBuffers());
          const x2 = l2.constantOr(null);
          if (x2 && r3.imageAtlas) {
            const e3 = r3.imageAtlas.patternPositions[x2.toString()];
            e3 && g2.setConstantPatternPositions(e3);
          }
          const v2 = e2.translatePosMatrix(m2.projMatrix, r3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor"));
          if (s2) {
            d2 = _2.indexBuffer2, f2 = _2.segments2;
            const t3 = e2.terrain && e2.terrain.renderingToTexture ? e2.terrain.drapeBufferSize : [a2.drawingBufferWidth, a2.drawingBufferHeight];
            p2 = "fillOutlinePattern" === h2 && c2 ? Wd(v2, e2, r3, t3) : $d(v2, t3);
          } else
            d2 = _2.indexBuffer, f2 = _2.segments, p2 = c2 ? Zd(v2, e2, r3) : qd(v2);
          e2.prepareDrawProgram(e2.context, y2, m2.toUnwrapped()), y2.draw(e2.context, u2, n2, e2.stencilModeForClipping(m2), o2, CullFaceMode.disabled, p2, i2.id, _2.layoutVertexBuffer, d2, f2, i2.paint, e2.transform.zoom, g2);
        }
      }
      function Sf(e2, t2, i2, r2, n2, o2, s2) {
        const a2 = e2.context, l2 = a2.gl, c2 = e2.transform, u2 = i2.paint.get("fill-extrusion-pattern"), h2 = u2.constantOr(1), p2 = i2.paint.get("fill-extrusion-opacity"), d2 = [i2.paint.get("fill-extrusion-ambient-occlusion-intensity"), i2.paint.get("fill-extrusion-ambient-occlusion-radius")], f2 = i2.layout.get("fill-extrusion-edge-radius"), m2 = "globe" === c2.projection.name ? ql() : 0, _2 = "globe" === c2.projection.name, g2 = _2 ? zu(c2.zoom) : 0, y2 = [Oo(c2.center.lng), Uo(c2.center.lat)], x2 = [];
        _2 && (x2.push("PROJECTION_GLOBE_VIEW"), e2.style.terrainSetForDrapingOnly() && x2.push("TERRAIN")), d2[0] > 0 && x2.push("FAUX_AO");
        for (const v2 of r2) {
          const r3 = t2.getTile(v2), b2 = r3.getBucket(i2);
          if (!b2 || b2.projection.name !== c2.projection.name)
            continue;
          const w2 = b2.programConfigurations.get(i2.id), T2 = e2.useProgram(h2 ? "fillExtrusionPattern" : "fillExtrusion", w2, x2);
          if (e2.terrain) {
            const n3 = e2.terrain;
            if (e2.style.terrainSetForDrapingOnly())
              n3.setupElevationDraw(r3, T2, { useMeterToDem: true });
            else {
              if (!b2.enableTerrain)
                continue;
              if (n3.setupElevationDraw(r3, T2, { useMeterToDem: true }), Af(a2, t2, v2, b2, i2, n3), !b2.centroidVertexBuffer) {
                const e3 = T2.attributes.a_centroid_pos;
                void 0 !== e3 && l2.vertexAttrib2f(e3, 0, 0);
              }
            }
          }
          h2 && (e2.context.activeTexture.set(l2.TEXTURE0), r3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), w2.updatePaintBuffers());
          const E2 = u2.constantOr(null);
          if (E2 && r3.imageAtlas) {
            const e3 = r3.imageAtlas.patternPositions[E2.toString()];
            e3 && w2.setConstantPatternPositions(e3);
          }
          const S2 = e2.translatePosMatrix(v2.projMatrix, r3, i2.paint.get("fill-extrusion-translate"), i2.paint.get("fill-extrusion-translate-anchor")), A2 = c2.projection.createInversionMatrix(c2, v2.canonical), C2 = i2.paint.get("fill-extrusion-vertical-gradient"), I2 = h2 ? Gd(S2, e2, C2, p2, d2, f2, v2, r3, m2, g2, y2, A2) : Nd(S2, e2, C2, p2, d2, f2, v2, m2, g2, y2, A2);
          e2.prepareDrawProgram(a2, T2, v2.toUnwrapped());
          const M2 = [];
          e2.terrain && M2.push(b2.centroidVertexBuffer), _2 && M2.push(b2.layoutVertexExtBuffer), T2.draw(a2, a2.gl.TRIANGLES, n2, o2, s2, CullFaceMode.backCCW, I2, i2.id, b2.layoutVertexBuffer, b2.indexBuffer, b2.segments, i2.paint, e2.transform.zoom, w2, M2);
        }
      }
      function Af(e2, t2, i2, r2, n2, o2) {
        const s2 = [(e3) => {
          let t3 = e3.canonical.x - 1, i3 = e3.wrap;
          return t3 < 0 && (t3 = (1 << e3.canonical.z) - 1, i3--), new OverscaledTileID(e3.overscaledZ, i3, e3.canonical.z, t3, e3.canonical.y);
        }, (e3) => {
          let t3 = e3.canonical.x + 1, i3 = e3.wrap;
          return t3 === 1 << e3.canonical.z && (t3 = 0, i3++), new OverscaledTileID(e3.overscaledZ, i3, e3.canonical.z, t3, e3.canonical.y);
        }, (e3) => new OverscaledTileID(e3.overscaledZ, e3.wrap, e3.canonical.z, e3.canonical.x, (0 === e3.canonical.y ? 1 << e3.canonical.z : e3.canonical.y) - 1), (e3) => new OverscaledTileID(e3.overscaledZ, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y === (1 << e3.canonical.z) - 1 ? 0 : e3.canonical.y + 1)], a2 = (e3) => {
          const i3 = t2.getSource().minzoom, r3 = (e4) => {
            const i4 = t2.getTileByID(e4);
            if (i4 && i4.hasData())
              return i4.getBucket(n2);
          }, o3 = [0, -1, 1];
          for (const t3 of o3) {
            if (e3.overscaledZ + t3 < i3)
              continue;
            const n3 = r3(e3.calculateScaledKey(e3.overscaledZ + t3));
            if (n3)
              return n3;
          }
        }, l2 = [0, 0, 0], c2 = (e3, t3) => (l2[0] = Math.min(e3.min.y, t3.min.y), l2[1] = Math.max(e3.max.y, t3.max.y), l2[2] = ko - t3.min.x > e3.max.x ? t3.min.x - ko : e3.max.x, l2), u2 = (e3, t3) => (l2[0] = Math.min(e3.min.x, t3.min.x), l2[1] = Math.max(e3.max.x, t3.max.x), l2[2] = ko - t3.min.y > e3.max.y ? t3.min.y - ko : e3.max.y, l2), h2 = [(e3, t3) => c2(e3, t3), (e3, t3) => c2(t3, e3), (e3, t3) => u2(e3, t3), (e3, t3) => u2(t3, e3)], p2 = new d(0, 0);
        let f2, m2, _2;
        const g2 = (e3, t3, r3, n3, s3) => {
          const a3 = [[n3 ? r3 : e3, n3 ? e3 : r3, 0], [n3 ? r3 : t3, n3 ? t3 : r3, 0]], l3 = s3 < 0 ? ko + s3 : s3, c3 = [n3 ? l3 : (e3 + t3) / 2, n3 ? (e3 + t3) / 2 : l3, 0];
          return 0 === r3 && s3 < 0 || 0 !== r3 && s3 > 0 ? o2.getForTilePoints(_2, [c3], true, m2) : a3.push(c3), o2.getForTilePoints(i2, a3, true, f2), Math.max(a3[0][2], a3[1][2], c3[2]) / o2.exaggeration();
        };
        for (let e3 = 0; e3 < 4; e3++) {
          const t3 = (e3 < 2 ? 1 : 5) - e3, n3 = r2.borders[e3];
          if (0 === n3.length)
            continue;
          const l3 = _2 = s2[e3](i2), c3 = a2(l3);
          if (!(c3 && c3 instanceof FillExtrusionBucket && c3.enableTerrain))
            continue;
          if (r2.borderDoneWithNeighborZ[e3] === c3.canonical.z && c3.borderDoneWithNeighborZ[t3] === r2.canonical.z)
            continue;
          if (m2 = o2.findDEMTileFor(l3), !m2 || !m2.dem)
            continue;
          if (!f2) {
            const e4 = o2.findDEMTileFor(i2);
            if (!e4 || !e4.dem)
              return;
            f2 = e4;
          }
          const u3 = c3.borders[t3];
          let d2 = 0;
          const y2 = c3.borderDoneWithNeighborZ[t3] !== r2.canonical.z;
          if (r2.canonical.z === c3.canonical.z) {
            for (let i3 = 0; i3 < n3.length; i3++) {
              const o3 = r2.featuresOnBorder[n3[i3]], s3 = o3.borders[e3];
              let a3;
              for (; d2 < u3.length && (a3 = c3.featuresOnBorder[u3[d2]], !(a3.borders[t3][1] > s3[0] + 3)); )
                y2 && c3.encodeCentroid(void 0, a3, false), d2++;
              if (a3 && d2 < u3.length) {
                const i4 = d2;
                let n4 = 0;
                for (; !(a3.borders[t3][0] > s3[1] - 3) && (n4++, ++d2 !== u3.length); )
                  a3 = c3.featuresOnBorder[u3[d2]];
                if (a3 = c3.featuresOnBorder[u3[i4]], o3.intersectsCount() > 1 || a3.intersectsCount() > 1 || 1 !== n4) {
                  1 !== n4 && (d2 = i4), r2.encodeCentroid(void 0, o3, false), y2 && c3.encodeCentroid(void 0, a3, false);
                  continue;
                }
                const l4 = h2[e3](o3, a3), f3 = e3 % 2 ? 8191 : 0;
                p2.x = g2(l4[0], Math.min(8191, l4[1]), f3, e3 < 2, l4[2]), p2.y = 0, r2.encodeCentroid(p2, o3, false), y2 && c3.encodeCentroid(p2, a3, false);
              } else
                r2.encodeCentroid(void 0, o3, false);
            }
            r2.borderDoneWithNeighborZ[e3] = c3.canonical.z, r2.needsCentroidUpdate = true, y2 && (c3.borderDoneWithNeighborZ[t3] = r2.canonical.z, c3.needsCentroidUpdate = true);
          } else {
            for (const e4 of n3)
              r2.encodeCentroid(void 0, r2.featuresOnBorder[e4], false);
            if (y2) {
              for (const e4 of u3)
                c3.encodeCentroid(void 0, c3.featuresOnBorder[e4], false);
              c3.borderDoneWithNeighborZ[t3] = r2.canonical.z, c3.needsCentroidUpdate = true;
            }
            r2.borderDoneWithNeighborZ[e3] = c3.canonical.z, r2.needsCentroidUpdate = true;
          }
        }
        (r2.needsCentroidUpdate || !r2.centroidVertexBuffer && 0 !== r2.centroidVertexArray.length) && r2.uploadCentroid(e2);
      }
      const Cf = new Gt(1, 0, 0, 1), If = new Gt(0, 1, 0, 1), Mf = new Gt(0, 0, 1, 1), Df = new Gt(1, 0, 1, 1), Pf = new Gt(0, 1, 1, 1);
      function zf(e2, t2, i2) {
        const r2 = e2.context, n2 = e2.transform, o2 = r2.gl, s2 = "globe" === n2.projection.name, a2 = s2 ? ["PROJECTION_GLOBE_VIEW"] : null;
        let l2 = i2.projMatrix;
        if (s2 && zu(n2.zoom) > 0) {
          const e3 = Mu(yu(i2.canonical, n2));
          l2 = Ds(new Float32Array(16), n2.globeMatrix, e3), Ds(l2, n2.projMatrix, l2);
        }
        const c2 = e2.useProgram("debug", null, a2), u2 = t2.getTileByID(i2.key);
        e2.terrain && e2.terrain.setupElevationDraw(u2, c2);
        const h2 = DepthMode.disabled, p2 = StencilMode.disabled, d2 = e2.colorModeForRenderPass(), f2 = "$debug";
        r2.activeTexture.set(o2.TEXTURE0), e2.emptyTexture.bind(o2.LINEAR, o2.CLAMP_TO_EDGE), s2 ? u2._makeGlobeTileDebugBuffers(e2.context, n2) : u2._makeDebugTileBoundsBuffers(e2.context, n2.projection);
        const m2 = u2._tileDebugBuffer || e2.debugBuffer, _2 = u2._tileDebugIndexBuffer || e2.debugIndexBuffer, g2 = u2._tileDebugSegments || e2.debugSegments;
        c2.draw(r2, o2.LINE_STRIP, h2, p2, d2, CullFaceMode.disabled, Jd(l2, Gt.red), f2, m2, _2, g2, null, null, null, [u2._globeTileDebugBorderBuffer]);
        const y2 = u2.latestRawTileData, x2 = Math.floor((y2 && y2.byteLength || 0) / 1024), v2 = t2.getTile(i2).tileSize, b2 = 512 / Math.min(v2, 512) * (i2.overscaledZ / n2.zoom) * 0.5;
        let w2 = i2.canonical.toString();
        i2.overscaledZ !== i2.canonical.z && (w2 += ` => ${i2.overscaledZ}`), w2 += ` ${x2}kb`, function(e3, t3) {
          e3.initDebugOverlayCanvas();
          const i3 = e3.debugOverlayCanvas, r3 = e3.context.gl, n3 = e3.debugOverlayCanvas.getContext("2d");
          n3.clearRect(0, 0, i3.width, i3.height), n3.shadowColor = "white", n3.shadowBlur = 2, n3.lineWidth = 1.5, n3.strokeStyle = "white", n3.textBaseline = "top", n3.font = "bold 36px Open Sans, sans-serif", n3.fillText(t3, 5, 5), n3.strokeText(t3, 5, 5), e3.debugOverlayTexture.update(i3), e3.debugOverlayTexture.bind(r3.LINEAR, r3.CLAMP_TO_EDGE);
        }(e2, w2);
        const T2 = u2._tileDebugTextBuffer || e2.debugBuffer, E2 = u2._tileDebugTextIndexBuffer || e2.quadTriangleIndexBuffer, S2 = u2._tileDebugTextSegments || e2.debugSegments;
        c2.draw(r2, o2.TRIANGLES, h2, p2, ColorMode.alphaBlended, CullFaceMode.disabled, Jd(l2, Gt.transparent, b2), f2, T2, E2, S2, null, null, null, [u2._globeTileDebugTextBuffer]);
      }
      function Lf(e2, t2, i2, r2) {
        Bf(e2, 0, t2 + i2 / 2, e2.transform.width, i2, r2);
      }
      function kf(e2, t2, i2, r2) {
        Bf(e2, t2 - i2 / 2, 0, i2, e2.transform.height, r2);
      }
      function Bf(e2, t2, i2, r2, n2, o2) {
        const s2 = e2.context, a2 = s2.gl;
        a2.enable(a2.SCISSOR_TEST), a2.scissor(t2 * Je.devicePixelRatio, i2 * Je.devicePixelRatio, r2 * Je.devicePixelRatio, n2 * Je.devicePixelRatio), s2.clear({ color: o2 }), a2.disable(a2.SCISSOR_TEST);
      }
      const Rf = co([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Ff } = Rf;
      function Of(e2, t2, i2, r2) {
        e2.emplaceBack(t2, i2, r2);
      }
      class SkyboxGeometry {
        constructor(e2) {
          this.vertexArray = new StructArrayLayout3f12(), this.indices = new StructArrayLayout3ui6(), Of(this.vertexArray, -1, -1, 1), Of(this.vertexArray, 1, -1, 1), Of(this.vertexArray, -1, 1, 1), Of(this.vertexArray, 1, 1, 1), Of(this.vertexArray, -1, -1, -1), Of(this.vertexArray, 1, -1, -1), Of(this.vertexArray, -1, 1, -1), Of(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = e2.createVertexBuffer(this.vertexArray, Ff), this.indexBuffer = e2.createIndexBuffer(this.indices), this.segment = SegmentVector.simpleSegment(0, 0, 36, 12);
        }
      }
      function Uf(e2, t2, i2, r2, n2, o2) {
        const s2 = e2.gl, a2 = t2.paint.get("sky-atmosphere-color"), l2 = t2.paint.get("sky-atmosphere-halo-color"), c2 = t2.paint.get("sky-atmosphere-sun-intensity"), u2 = ((e3, t3, i3, r3, n3) => ({ u_matrix_3f: e3, u_sun_direction: t3, u_sun_intensity: i3, u_color_tint_r: [r3.r, r3.g, r3.b, r3.a], u_color_tint_m: [n3.r, n3.g, n3.b, n3.a], u_luminance: 5e-5 }))(((h2 = Es())[0] = (p2 = r2)[0], h2[1] = p2[1], h2[2] = p2[2], h2[3] = p2[4], h2[4] = p2[5], h2[5] = p2[6], h2[6] = p2[8], h2[7] = p2[9], h2[8] = p2[10], h2), n2, c2, a2, l2);
        var h2, p2;
        s2.framebufferTexture2D(s2.FRAMEBUFFER, s2.COLOR_ATTACHMENT0, s2.TEXTURE_CUBE_MAP_POSITIVE_X + o2, t2.skyboxTexture, 0), i2.draw(e2, s2.TRIANGLES, DepthMode.disabled, StencilMode.disabled, ColorMode.unblended, CullFaceMode.frontCW, u2, "skyboxCapture", t2.skyboxGeometry.vertexBuffer, t2.skyboxGeometry.indexBuffer, t2.skyboxGeometry.segment);
      }
      const Vf = co([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
      class AtmosphereBuffer {
        constructor(e2) {
          const t2 = new StructArrayLayout5f20();
          t2.emplaceBack(-1, 1, 1, 0, 0), t2.emplaceBack(1, 1, 1, 1, 0), t2.emplaceBack(1, -1, 1, 1, 1), t2.emplaceBack(-1, -1, 1, 0, 1);
          const i2 = new StructArrayLayout3ui6();
          i2.emplaceBack(0, 1, 2), i2.emplaceBack(2, 3, 0), this.vertexBuffer = e2.createVertexBuffer(t2, Vf.members), this.indexBuffer = e2.createIndexBuffer(i2), this.segments = SegmentVector.simpleSegment(0, 0, 4, 2);
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
        }
      }
      const jf = { symbol: function(e2, t2, i2, r2, n2) {
        if ("translucent" !== e2.renderPass)
          return;
        const o2 = StencilMode.disabled, s2 = e2.colorModeForRenderPass();
        i2.layout.get("text-variable-anchor") && function(e3, t3, i3, r3, n3, o3, s3) {
          const a2 = t3.transform, l2 = "map" === n3, c2 = "map" === o3;
          for (const t4 of e3) {
            const e4 = r3.getTile(t4), n4 = e4.getBucket(i3);
            if (!n4 || !n4.text || !n4.text.segments.get().length)
              continue;
            const o4 = xc(n4.textSizeData, a2.zoom), u2 = Xp(t4, n4.getProjection(), a2), h2 = a2.calculatePixelsToTileUnitsMatrix(e4), p2 = Pp(u2, e4.tileID.canonical, c2, l2, a2, n4.getProjection(), h2), d2 = "none" !== i3.layout.get("icon-text-fit") && n4.hasIconData();
            if (o4) {
              const i4 = Math.pow(2, a2.zoom - e4.tileID.overscaledZ);
              vf(n4, l2, c2, s3, vc, a2, p2, t4, i4, o4, d2);
            }
          }
        }(r2, e2, i2, t2, i2.layout.get("text-rotation-alignment"), i2.layout.get("text-pitch-alignment"), n2), 0 !== i2.paint.get("icon-opacity").constantOr(1) && wf(e2, t2, i2, r2, false, i2.paint.get("icon-translate"), i2.paint.get("icon-translate-anchor"), i2.layout.get("icon-rotation-alignment"), i2.layout.get("icon-pitch-alignment"), i2.layout.get("icon-keep-upright"), o2, s2), 0 !== i2.paint.get("text-opacity").constantOr(1) && wf(e2, t2, i2, r2, true, i2.paint.get("text-translate"), i2.paint.get("text-translate-anchor"), i2.layout.get("text-rotation-alignment"), i2.layout.get("text-pitch-alignment"), i2.layout.get("text-keep-upright"), o2, s2), t2.map.showCollisionBoxes && (gf(e2, t2, i2, r2, i2.paint.get("text-translate"), i2.paint.get("text-translate-anchor"), true), gf(e2, t2, i2, r2, i2.paint.get("icon-translate"), i2.paint.get("icon-translate-anchor"), false));
      }, circle: function(e2, t2, i2, r2) {
        if ("translucent" !== e2.renderPass)
          return;
        const n2 = i2.paint.get("circle-opacity"), o2 = i2.paint.get("circle-stroke-width"), s2 = i2.paint.get("circle-stroke-opacity"), a2 = void 0 !== i2.layout.get("circle-sort-key").constantOr(1);
        if (0 === n2.constantOr(1) && (0 === o2.constantOr(1) || 0 === s2.constantOr(1)))
          return;
        const l2 = e2.context, c2 = l2.gl, u2 = e2.transform, h2 = e2.depthModeForSublayer(0, DepthMode.ReadOnly), p2 = StencilMode.disabled, d2 = e2.colorModeForRenderPass(), f2 = "globe" === u2.projection.name, m2 = [Oo(u2.center.lng), Uo(u2.center.lat)], _2 = [];
        for (let n3 = 0; n3 < r2.length; n3++) {
          const o3 = r2[n3], s3 = t2.getTile(o3), l3 = s3.getBucket(i2);
          if (!l3 || l3.projection.name !== u2.projection.name)
            continue;
          const c3 = l3.programConfigurations.get(i2.id), h3 = Kd(i2);
          f2 && h3.push("PROJECTION_GLOBE_VIEW");
          const p3 = e2.useProgram("circle", c3, h3), d3 = l3.layoutVertexBuffer, g3 = l3.globeExtVertexBuffer, y2 = l3.indexBuffer, x2 = u2.projection.createInversionMatrix(u2, o3.canonical), v2 = { programConfiguration: c3, program: p3, layoutVertexBuffer: d3, globeExtVertexBuffer: g3, indexBuffer: y2, uniformValues: Xd(e2, o3, s3, x2, m2, i2), tile: s3 };
          if (a2) {
            const e3 = l3.segments.get();
            for (const t3 of e3)
              _2.push({ segments: new SegmentVector([t3]), sortKey: t3.sortKey, state: v2 });
          } else
            _2.push({ segments: l3.segments, sortKey: 0, state: v2 });
        }
        a2 && _2.sort((e3, t3) => e3.sortKey - t3.sortKey);
        const g2 = { useDepthForOcclusion: !f2 };
        for (const t3 of _2) {
          const { programConfiguration: r3, program: n3, layoutVertexBuffer: o3, globeExtVertexBuffer: s3, indexBuffer: a3, uniformValues: f3, tile: m3 } = t3.state, _3 = t3.segments;
          e2.terrain && e2.terrain.setupElevationDraw(m3, n3, g2), e2.prepareDrawProgram(l2, n3, m3.tileID.toUnwrapped()), n3.draw(l2, c2.TRIANGLES, h2, p2, d2, CullFaceMode.disabled, f3, i2.id, o3, a3, _3, i2.paint, u2.zoom, r3, [s3]);
        }
      }, heatmap: function(e2, t2, i2, r2) {
        if (0 !== i2.paint.get("heatmap-opacity"))
          if ("offscreen" === e2.renderPass) {
            const n2 = e2.context, o2 = n2.gl, s2 = StencilMode.disabled, a2 = new ColorMode([o2.ONE, o2.ONE], Gt.transparent, [true, true, true, true]);
            !function(e3, t3, i3, r3) {
              const n3 = e3.gl, o3 = t3.width * r3, s3 = t3.height * r3;
              e3.activeTexture.set(n3.TEXTURE1), e3.viewport.set([0, 0, o3, s3]);
              let a3 = i3.heatmapFbo;
              if (!a3 || a3 && (a3.width !== o3 || a3.height !== s3)) {
                a3 && a3.destroy();
                const t4 = n3.createTexture();
                n3.bindTexture(n3.TEXTURE_2D, t4), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_WRAP_S, n3.CLAMP_TO_EDGE), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_WRAP_T, n3.CLAMP_TO_EDGE), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_MIN_FILTER, n3.LINEAR), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_MAG_FILTER, n3.LINEAR), a3 = i3.heatmapFbo = e3.createFramebuffer(o3, s3, false), function(e4, t5, i4, r4, n4, o4) {
                  const s4 = e4.gl;
                  s4.texImage2D(s4.TEXTURE_2D, 0, s4.RGBA, n4, o4, 0, s4.RGBA, e4.extRenderToTextureHalfFloat ? e4.extTextureHalfFloat.HALF_FLOAT_OES : s4.UNSIGNED_BYTE, null), r4.colorAttachment.set(i4);
                }(e3, 0, t4, a3, o3, s3);
              } else
                n3.bindTexture(n3.TEXTURE_2D, a3.colorAttachment.get()), e3.bindFramebuffer.set(a3.framebuffer);
            }(n2, e2, i2, "globe" === e2.transform.projection.name ? 0.5 : 0.25), n2.clear({ color: Gt.transparent });
            const l2 = e2.transform, c2 = "globe" === l2.projection.name, u2 = c2 ? ["PROJECTION_GLOBE_VIEW"] : null, h2 = c2 ? CullFaceMode.frontCCW : CullFaceMode.disabled, p2 = [Oo(l2.center.lng), Uo(l2.center.lat)];
            for (let d2 = 0; d2 < r2.length; d2++) {
              const f2 = r2[d2];
              if (t2.hasRenderableParent(f2))
                continue;
              const m2 = t2.getTile(f2), _2 = m2.getBucket(i2);
              if (!_2 || _2.projection.name !== l2.projection.name)
                continue;
              const g2 = _2.programConfigurations.get(i2.id), y2 = e2.useProgram("heatmap", g2, u2), { zoom: x2 } = e2.transform;
              e2.terrain && e2.terrain.setupElevationDraw(m2, y2), e2.prepareDrawProgram(n2, y2, f2.toUnwrapped());
              const v2 = l2.projection.createInversionMatrix(l2, f2.canonical);
              y2.draw(n2, o2.TRIANGLES, DepthMode.disabled, s2, a2, h2, ef(e2, f2, m2, v2, p2, x2, i2.paint.get("heatmap-intensity")), i2.id, _2.layoutVertexBuffer, _2.indexBuffer, _2.segments, i2.paint, e2.transform.zoom, g2, c2 ? [_2.globeExtVertexBuffer] : null);
            }
            n2.viewport.set([0, 0, e2.width, e2.height]);
          } else
            "translucent" === e2.renderPass && (e2.context.setColorMode(e2.colorModeForRenderPass()), function(e3, t3) {
              const i3 = e3.context, r3 = i3.gl, n2 = t3.heatmapFbo;
              if (!n2)
                return;
              i3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, n2.colorAttachment.get()), i3.activeTexture.set(r3.TEXTURE1);
              let o2 = t3.colorRampTexture;
              o2 || (o2 = t3.colorRampTexture = new Texture(i3, t3.colorRamp, r3.RGBA)), o2.bind(r3.LINEAR, r3.CLAMP_TO_EDGE), e3.useProgram("heatmapTexture").draw(i3, r3.TRIANGLES, DepthMode.disabled, StencilMode.disabled, e3.colorModeForRenderPass(), CullFaceMode.disabled, ((e4, t4, i4, r4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t4.paint.get("heatmap-opacity") }))(0, t3), t3.id, e3.viewportBuffer, e3.quadTriangleIndexBuffer, e3.viewportSegments, t3.paint, e3.transform.zoom);
            }(e2, i2));
      }, line: function(e2, t2, i2, r2) {
        if ("translucent" !== e2.renderPass)
          return;
        const n2 = i2.paint.get("line-opacity"), o2 = i2.paint.get("line-width");
        if (0 === n2.constantOr(1) || 0 === o2.constantOr(1))
          return;
        const s2 = e2.depthModeForSublayer(0, DepthMode.ReadOnly), a2 = e2.colorModeForRenderPass(), l2 = e2.terrain && e2.terrain.renderingToTexture ? 1 : Je.devicePixelRatio, c2 = i2.paint.get("line-dasharray"), u2 = c2.constantOr(1), h2 = i2.layout.get("line-cap"), p2 = i2.paint.get("line-pattern"), d2 = p2.constantOr(1), f2 = i2.paint.get("line-gradient"), m2 = d2 ? "linePattern" : "line", _2 = e2.context, g2 = _2.gl, y2 = ((e3) => {
          const t3 = [];
          sf(e3) && t3.push("RENDER_LINE_DASH"), e3.paint.get("line-gradient") && t3.push("RENDER_LINE_GRADIENT");
          const i3 = e3.paint.get("line-trim-offset");
          0 === i3[0] && 0 === i3[1] || t3.push("RENDER_LINE_TRIM_OFFSET");
          const r3 = e3.paint.get("line-pattern").constantOr(1), n3 = 1 !== e3.paint.get("line-opacity").constantOr(1);
          return !r3 && n3 && t3.push("RENDER_LINE_ALPHA_DISCARD"), t3;
        })(i2);
        let x2 = y2.includes("RENDER_LINE_ALPHA_DISCARD");
        e2.terrain && e2.terrain.clipOrMaskOverlapStencilType() && (x2 = false);
        for (const n3 of r2) {
          const r3 = t2.getTile(n3);
          if (d2 && !r3.patternsLoaded())
            continue;
          const o3 = r3.getBucket(i2);
          if (!o3)
            continue;
          e2.prepareDrawTile();
          const v2 = o3.programConfigurations.get(i2.id), b2 = e2.useProgram(m2, v2, y2), w2 = p2.constantOr(null);
          if (w2 && r3.imageAtlas) {
            const e3 = r3.imageAtlas.patternPositions[w2.toString()];
            e3 && v2.setConstantPatternPositions(e3);
          }
          const T2 = c2.constantOr(null), E2 = h2.constantOr(null);
          if (!d2 && T2 && E2 && r3.lineAtlas) {
            const e3 = r3.lineAtlas.getDash(T2, E2);
            e3 && v2.setConstantPatternPositions(e3);
          }
          let [S2, C2] = i2.paint.get("line-trim-offset");
          if ("round" === E2 || "square" === E2) {
            const e3 = 1;
            S2 !== C2 && (0 === S2 && (S2 -= e3), 1 === C2 && (C2 += e3));
          }
          const I2 = e2.terrain ? n3.projMatrix : null, M2 = d2 ? rf(e2, r3, i2, I2, l2) : tf(e2, r3, i2, I2, o3.lineClipsArray.length, l2, [S2, C2]);
          if (f2) {
            const r4 = o3.gradients[i2.id];
            let s3 = r4.texture;
            if (i2.gradientVersion !== r4.version) {
              let a3 = 256;
              if (i2.stepInterpolant) {
                const i3 = t2.getSource().maxzoom, r5 = n3.canonical.z === i3 ? Math.ceil(1 << e2.transform.maxZoom - n3.canonical.z) : 1;
                a3 = A(R(o3.maxLineLength / ko * 1024 * r5), 256, _2.maxTextureSize);
              }
              r4.gradient = Ma({ expression: i2.gradientExpression(), evaluationKey: "lineProgress", resolution: a3, image: r4.gradient || void 0, clips: o3.lineClipsArray }), r4.texture ? r4.texture.update(r4.gradient) : r4.texture = new Texture(_2, r4.gradient, g2.RGBA), r4.version = i2.gradientVersion, s3 = r4.texture;
            }
            _2.activeTexture.set(g2.TEXTURE1), s3.bind(i2.stepInterpolant ? g2.NEAREST : g2.LINEAR, g2.CLAMP_TO_EDGE);
          }
          u2 && (_2.activeTexture.set(g2.TEXTURE0), r3.lineAtlasTexture.bind(g2.LINEAR, g2.REPEAT), v2.updatePaintBuffers()), d2 && (_2.activeTexture.set(g2.TEXTURE0), r3.imageAtlasTexture.bind(g2.LINEAR, g2.CLAMP_TO_EDGE), v2.updatePaintBuffers()), e2.prepareDrawProgram(_2, b2, n3.toUnwrapped());
          const D2 = (t3) => {
            b2.draw(_2, g2.TRIANGLES, s2, t3, a2, CullFaceMode.disabled, M2, i2.id, o3.layoutVertexBuffer, o3.indexBuffer, o3.segments, i2.paint, e2.transform.zoom, v2, [o3.layoutVertexBuffer2]);
          };
          if (x2) {
            const t3 = e2.stencilModeForClipping(n3).ref;
            0 === t3 && e2.terrain && _2.clear({ stencil: 0 });
            const i3 = { func: g2.EQUAL, mask: 255 };
            M2.u_alpha_discard_threshold = 0.8, D2(new StencilMode(i3, t3, 255, g2.KEEP, g2.KEEP, g2.INVERT)), M2.u_alpha_discard_threshold = 0, D2(new StencilMode(i3, t3, 255, g2.KEEP, g2.KEEP, g2.KEEP));
          } else
            D2(e2.stencilModeForClipping(n3));
        }
        x2 && (e2.resetStencilClippingMasks(), e2.terrain && _2.clear({ stencil: 0 }));
      }, fill: function(e2, t2, i2, r2) {
        const n2 = i2.paint.get("fill-color"), o2 = i2.paint.get("fill-opacity");
        if (0 === o2.constantOr(1))
          return;
        const s2 = e2.colorModeForRenderPass(), a2 = i2.paint.get("fill-pattern"), l2 = e2.opaquePassEnabledForLayer() && !a2.constantOr(1) && 1 === n2.constantOr(Gt.transparent).a && 1 === o2.constantOr(0) ? "opaque" : "translucent";
        if (e2.renderPass === l2) {
          const n3 = e2.depthModeForSublayer(1, "opaque" === e2.renderPass ? DepthMode.ReadWrite : DepthMode.ReadOnly);
          Ef(e2, t2, i2, r2, n3, s2, false);
        }
        if ("translucent" === e2.renderPass && i2.paint.get("fill-antialias")) {
          const n3 = e2.depthModeForSublayer(i2.getPaintProperty("fill-outline-color") ? 2 : 0, DepthMode.ReadOnly);
          Ef(e2, t2, i2, r2, n3, s2, true);
        }
      }, "fill-extrusion": function(e2, t2, i2, r2) {
        const n2 = i2.paint.get("fill-extrusion-opacity");
        if (0 !== n2 && "translucent" === e2.renderPass) {
          const o2 = new DepthMode(e2.context.gl.LEQUAL, DepthMode.ReadWrite, e2.depthRangeFor3D);
          if (1 !== n2 || i2.paint.get("fill-extrusion-pattern").constantOr(1))
            Sf(e2, t2, i2, r2, o2, StencilMode.disabled, ColorMode.disabled), Sf(e2, t2, i2, r2, o2, e2.stencilModeFor3D(), e2.colorModeForRenderPass()), e2.resetStencilClippingMasks();
          else {
            const n3 = e2.colorModeForRenderPass();
            Sf(e2, t2, i2, r2, o2, StencilMode.disabled, n3);
          }
        }
      }, hillshade: function(e2, t2, i2, r2) {
        if ("offscreen" !== e2.renderPass && "translucent" !== e2.renderPass)
          return;
        const n2 = e2.context, o2 = e2.depthModeForSublayer(0, DepthMode.ReadOnly), s2 = e2.colorModeForRenderPass(), a2 = e2.terrain && e2.terrain.renderingToTexture, [l2, c2] = "translucent" !== e2.renderPass || a2 ? [{}, r2] : e2.stencilConfigForOverlap(r2);
        for (const r3 of c2) {
          const n3 = t2.getTile(r3);
          if (n3.needsHillshadePrepare && "offscreen" === e2.renderPass)
            Dd(e2, n3, i2, o2, StencilMode.disabled, s2);
          else if ("translucent" === e2.renderPass) {
            const t3 = a2 && e2.terrain ? e2.terrain.stencilModeForRTTOverlap(r3) : l2[r3.overscaledZ];
            Id(e2, r3, n3, i2, o2, t3, s2);
          }
        }
        n2.viewport.set([0, 0, e2.width, e2.height]), e2.resetStencilClippingMasks();
      }, raster: function(e2, t2, i2, r2, n2, o2) {
        if ("translucent" !== e2.renderPass)
          return;
        if (0 === i2.paint.get("raster-opacity"))
          return;
        if (!r2.length)
          return;
        const s2 = e2.context, a2 = s2.gl, l2 = t2.getSource(), c2 = e2.useProgram("raster"), u2 = e2.colorModeForRenderPass(), h2 = e2.terrain && e2.terrain.renderingToTexture, [p2, d2] = l2 instanceof ImageSource || h2 ? [{}, r2] : e2.stencilConfigForOverlap(r2), f2 = d2[d2.length - 1].overscaledZ, m2 = !e2.options.moving;
        for (const r3 of d2) {
          const n3 = h2 ? DepthMode.disabled : e2.depthModeForSublayer(r3.overscaledZ - f2, 1 === i2.paint.get("raster-opacity") ? DepthMode.ReadWrite : DepthMode.ReadOnly, a2.LESS), d3 = r3.toUnwrapped(), _2 = t2.getTile(r3);
          if (h2 && (!_2 || !_2.hasData()))
            continue;
          const g2 = h2 ? r3.projMatrix : e2.transform.calculateProjMatrix(d3, m2), y2 = e2.terrain && h2 ? e2.terrain.stencilModeForRTTOverlap(r3) : p2[r3.overscaledZ], x2 = o2 ? 0 : i2.paint.get("raster-fade-duration");
          _2.registerFadeDuration(x2);
          const v2 = t2.findLoadedParent(r3, 0), b2 = Ud(_2, v2, t2, e2.transform, x2);
          let w2, T2;
          e2.terrain && e2.terrain.prepareDrawTile();
          const E2 = "nearest" === i2.paint.get("raster-resampling") ? a2.NEAREST : a2.LINEAR;
          s2.activeTexture.set(a2.TEXTURE0), _2.texture.bind(E2, a2.CLAMP_TO_EDGE), s2.activeTexture.set(a2.TEXTURE1), v2 ? (v2.texture.bind(E2, a2.CLAMP_TO_EDGE), w2 = Math.pow(2, v2.tileID.overscaledZ - _2.tileID.overscaledZ), T2 = [_2.tileID.canonical.x * w2 % 1, _2.tileID.canonical.y * w2 % 1]) : _2.texture.bind(E2, a2.CLAMP_TO_EDGE);
          const S2 = af(g2, T2 || [0, 0], w2 || 1, b2, i2, l2 instanceof ImageSource ? l2.perspectiveTransform : [0, 0]);
          if (e2.prepareDrawProgram(s2, c2, d3), l2 instanceof ImageSource)
            l2.boundsBuffer && l2.boundsSegments && c2.draw(s2, a2.TRIANGLES, n3, StencilMode.disabled, u2, CullFaceMode.disabled, S2, i2.id, l2.boundsBuffer, e2.quadTriangleIndexBuffer, l2.boundsSegments);
          else {
            const { tileBoundsBuffer: t3, tileBoundsIndexBuffer: r4, tileBoundsSegments: o3 } = e2.getTileBoundsBuffers(_2);
            c2.draw(s2, a2.TRIANGLES, n3, y2, u2, CullFaceMode.disabled, S2, i2.id, t3, r4, o3);
          }
        }
        e2.resetStencilClippingMasks();
      }, background: function(e2, t2, i2, r2) {
        const n2 = i2.paint.get("background-color"), o2 = i2.paint.get("background-opacity");
        if (0 === o2)
          return;
        const s2 = e2.context, a2 = s2.gl, l2 = e2.transform, c2 = l2.tileSize, u2 = i2.paint.get("background-pattern");
        if (e2.isPatternMissing(u2))
          return;
        const h2 = !u2 && 1 === n2.a && 1 === o2 && e2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (e2.renderPass !== h2)
          return;
        const p2 = StencilMode.disabled, d2 = e2.depthModeForSublayer(0, "opaque" === h2 ? DepthMode.ReadWrite : DepthMode.ReadOnly), f2 = e2.colorModeForRenderPass(), m2 = e2.useProgram(u2 ? "backgroundPattern" : "background");
        let _2, g2 = r2;
        g2 || (_2 = e2.getBackgroundTiles(), g2 = Object.values(_2).map((e3) => e3.tileID)), u2 && (s2.activeTexture.set(a2.TEXTURE0), e2.imageManager.bind(e2.context));
        for (const h3 of g2) {
          const g3 = h3.toUnwrapped(), y2 = r2 ? h3.projMatrix : e2.transform.calculateProjMatrix(g3);
          e2.prepareDrawTile();
          const x2 = t2 ? t2.getTile(h3) : _2 ? _2[h3.key] : new Tile(h3, c2, l2.zoom, e2), v2 = u2 ? ff(y2, o2, e2, u2, { tileID: h3, tileSize: c2 }) : df(y2, o2, n2);
          e2.prepareDrawProgram(s2, m2, g3);
          const { tileBoundsBuffer: b2, tileBoundsIndexBuffer: w2, tileBoundsSegments: T2 } = e2.getTileBoundsBuffers(x2);
          m2.draw(s2, a2.TRIANGLES, d2, p2, f2, CullFaceMode.disabled, v2, i2.id, b2, w2, T2);
        }
      }, sky: function(e2, t2, i2) {
        const r2 = e2.transform, n2 = "mercator" === r2.projection.name || "globe" === r2.projection.name ? 1 : C(7, 8, r2.zoom), o2 = i2.paint.get("sky-opacity") * n2;
        if (0 === o2)
          return;
        const s2 = e2.context, a2 = i2.paint.get("sky-type"), l2 = new DepthMode(s2.gl.LEQUAL, DepthMode.ReadOnly, [0, 1]), c2 = e2.frameCounter / 1e3 % 1;
        "atmosphere" === a2 ? "offscreen" === e2.renderPass ? i2.needsSkyboxCapture(e2) && (function(e3, t3, i3, r3) {
          const n3 = e3.context, o3 = n3.gl;
          let s3 = t3.skyboxFbo;
          if (!s3) {
            s3 = t3.skyboxFbo = n3.createFramebuffer(32, 32, false), t3.skyboxGeometry = new SkyboxGeometry(n3), t3.skyboxTexture = n3.gl.createTexture(), o3.bindTexture(o3.TEXTURE_CUBE_MAP, t3.skyboxTexture), o3.texParameteri(o3.TEXTURE_CUBE_MAP, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_CUBE_MAP, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_CUBE_MAP, o3.TEXTURE_MIN_FILTER, o3.LINEAR), o3.texParameteri(o3.TEXTURE_CUBE_MAP, o3.TEXTURE_MAG_FILTER, o3.LINEAR);
            for (let e4 = 0; e4 < 6; ++e4)
              o3.texImage2D(o3.TEXTURE_CUBE_MAP_POSITIVE_X + e4, 0, o3.RGBA, 32, 32, 0, o3.RGBA, o3.UNSIGNED_BYTE, null);
          }
          n3.bindFramebuffer.set(s3.framebuffer), n3.viewport.set([0, 0, 32, 32]);
          const a3 = t3.getCenter(e3, true), l3 = e3.useProgram("skyboxCapture"), c3 = new Float64Array(16);
          Is(c3), ks(c3, c3, 0.5 * -Math.PI), Uf(n3, t3, l3, c3, a3, 0), Is(c3), ks(c3, c3, 0.5 * Math.PI), Uf(n3, t3, l3, c3, a3, 1), Is(c3), Ls(c3, c3, 0.5 * -Math.PI), Uf(n3, t3, l3, c3, a3, 2), Is(c3), Ls(c3, c3, 0.5 * Math.PI), Uf(n3, t3, l3, c3, a3, 3), Is(c3), Uf(n3, t3, l3, c3, a3, 4), Is(c3), ks(c3, c3, Math.PI), Uf(n3, t3, l3, c3, a3, 5), n3.viewport.set([0, 0, e3.width, e3.height]);
        }(e2, i2), i2.markSkyboxValid(e2)) : "sky" === e2.renderPass && function(e3, t3, i3, r3, n3) {
          const o3 = e3.context, s3 = o3.gl, a3 = e3.transform, l3 = e3.useProgram("skybox");
          o3.activeTexture.set(s3.TEXTURE0), s3.bindTexture(s3.TEXTURE_CUBE_MAP, t3.skyboxTexture);
          const c3 = ((e4, t4, i4, r4, n4) => ({ u_matrix: e4, u_sun_direction: t4, u_cubemap: 0, u_opacity: r4, u_temporal_offset: n4 }))(a3.skyboxMatrix, t3.getCenter(e3, false), 0, r3, n3);
          e3.prepareDrawProgram(o3, l3), l3.draw(o3, s3.TRIANGLES, i3, StencilMode.disabled, e3.colorModeForRenderPass(), CullFaceMode.backCW, c3, "skybox", t3.skyboxGeometry.vertexBuffer, t3.skyboxGeometry.indexBuffer, t3.skyboxGeometry.segment);
        }(e2, i2, l2, o2, c2) : "gradient" === a2 && "sky" === e2.renderPass && function(e3, t3, i3, r3, n3) {
          const o3 = e3.context, s3 = o3.gl, a3 = e3.transform, l3 = e3.useProgram("skyboxGradient");
          t3.skyboxGeometry || (t3.skyboxGeometry = new SkyboxGeometry(o3)), o3.activeTexture.set(s3.TEXTURE0);
          let c3 = t3.colorRampTexture;
          c3 || (c3 = t3.colorRampTexture = new Texture(o3, t3.colorRamp, s3.RGBA)), c3.bind(s3.LINEAR, s3.CLAMP_TO_EDGE);
          const u2 = ((e4, t4, i4, r4, n4) => ({ u_matrix: e4, u_color_ramp: 0, u_center_direction: t4, u_radius: y(i4), u_opacity: r4, u_temporal_offset: n4 }))(a3.skyboxMatrix, t3.getCenter(e3, false), t3.paint.get("sky-gradient-radius"), r3, n3);
          e3.prepareDrawProgram(o3, l3), l3.draw(o3, s3.TRIANGLES, i3, StencilMode.disabled, e3.colorModeForRenderPass(), CullFaceMode.backCW, u2, "skyboxGradient", t3.skyboxGeometry.vertexBuffer, t3.skyboxGeometry.indexBuffer, t3.skyboxGeometry.segment);
        }(e2, i2, l2, o2, c2);
      }, debug: function(e2, t2, i2) {
        for (let r2 = 0; r2 < i2.length; r2++)
          zf(e2, t2, i2[r2]);
      }, custom: function(e2, t2, i2) {
        const r2 = e2.context, n2 = i2.implementation;
        if (e2.transform.projection.unsupportedLayers && e2.transform.projection.unsupportedLayers.includes("custom"))
          Z("Custom layers are not yet supported with non-mercator projections. Use mercator to enable custom layers.");
        else if ("offscreen" === e2.renderPass) {
          const t3 = n2.prerender;
          t3 && (e2.setCustomLayerDefaults(), r2.setColorMode(e2.colorModeForRenderPass()), t3.call(n2, r2.gl, e2.transform.customLayerMatrix()), r2.setDirty(), e2.setBaseState());
        } else if ("translucent" === e2.renderPass) {
          e2.setCustomLayerDefaults(), r2.setColorMode(e2.colorModeForRenderPass()), r2.setStencilMode(StencilMode.disabled);
          const t3 = "3d" === n2.renderingMode ? new DepthMode(e2.context.gl.LEQUAL, DepthMode.ReadWrite, e2.depthRangeFor3D) : e2.depthModeForSublayer(0, DepthMode.ReadOnly);
          r2.setDepthMode(t3), n2.render(r2.gl, e2.transform.customLayerMatrix()), r2.setDirty(), e2.setBaseState(), r2.bindFramebuffer.set(null);
        }
      } };
      class Painter {
        constructor(e2, t2) {
          this.context = new Context(e2), this.transform = t2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = SourceCache.maxUnderzooming + SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new CrossTileSymbolIndex(), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
        }
        updateTerrain(e2, t2) {
          const i2 = !!e2 && !!e2.terrain && this.transform.projection.supportsTerrain;
          if (!(i2 || this._terrain && this._terrain.enabled))
            return;
          this._terrain || (this._terrain = new Terrain(this, e2));
          const r2 = this._terrain;
          this.transform.elevation = i2 ? r2 : null, r2.update(e2, this.transform, t2);
        }
        _updateFog(e2) {
          const t2 = e2.fog;
          if (!t2 || "globe" === this.transform.projection.name || t2.getOpacity(this.transform.pitch) < 1 || t2.properties.get("horizon-blend") < 0.03)
            return void (this.transform.fogCullDistSq = null);
          const [i2, r2] = t2.getFovAdjustedRange(this.transform._fov);
          if (i2 > r2)
            return void (this.transform.fogCullDistSq = null);
          const n2 = i2 + 0.78 * (r2 - i2);
          this.transform.fogCullDistSq = n2 * n2;
        }
        get terrain() {
          return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
        }
        resize(e2, t2) {
          if (this.width = e2 * Je.devicePixelRatio, this.height = t2 * Je.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const e3 of this.style.order)
              this.style._layers[e3].resize();
        }
        setup() {
          const t2 = this.context, i2 = new StructArrayLayout2i4();
          i2.emplaceBack(0, 0), i2.emplaceBack(ko, 0), i2.emplaceBack(0, ko), i2.emplaceBack(ko, ko), this.tileExtentBuffer = t2.createVertexBuffer(i2, su.members), this.tileExtentSegments = SegmentVector.simpleSegment(0, 0, 4, 2);
          const r2 = new StructArrayLayout2i4();
          r2.emplaceBack(0, 0), r2.emplaceBack(ko, 0), r2.emplaceBack(0, ko), r2.emplaceBack(ko, ko), this.debugBuffer = t2.createVertexBuffer(r2, su.members), this.debugSegments = SegmentVector.simpleSegment(0, 0, 4, 5);
          const n2 = new StructArrayLayout2i4();
          n2.emplaceBack(-1, -1), n2.emplaceBack(1, -1), n2.emplaceBack(-1, 1), n2.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(n2, su.members), this.viewportSegments = SegmentVector.simpleSegment(0, 0, 4, 2);
          const o2 = new StructArrayLayout4i8();
          o2.emplaceBack(0, 0, 0, 0), o2.emplaceBack(ko, 0, ko, 0), o2.emplaceBack(0, ko, 0, ko), o2.emplaceBack(ko, ko, ko, ko), this.mercatorBoundsBuffer = t2.createVertexBuffer(o2, Nh.members), this.mercatorBoundsSegments = SegmentVector.simpleSegment(0, 0, 4, 2);
          const s2 = new StructArrayLayout3ui6();
          s2.emplaceBack(0, 1, 2), s2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(s2);
          const a2 = new StructArrayLayout1ui2();
          for (const e2 of [0, 1, 3, 2, 0])
            a2.emplaceBack(e2);
          this.debugIndexBuffer = t2.createIndexBuffer(a2), this.emptyTexture = new Texture(t2, new RGBAImage({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t2.gl.RGBA), this.identityMat = Cs();
          const l2 = this.context.gl;
          this.stencilClearMode = new StencilMode({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO), this.loadTimeStamps.push(e.performance.now()), this.atmosphereBuffer = new AtmosphereBuffer(this.context);
        }
        getMercatorTileBoundsBuffers() {
          return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
        }
        getTileBoundsBuffers(e2) {
          return e2._makeTileBoundsBuffers(this.context, this.transform.projection), e2._tileBoundsBuffer ? { tileBoundsBuffer: e2._tileBoundsBuffer, tileBoundsIndexBuffer: e2._tileBoundsIndexBuffer, tileBoundsSegments: e2._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
        }
        clearStencil() {
          const e2 = this.context, t2 = e2.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(e2, t2.TRIANGLES, DepthMode.disabled, this.stencilClearMode, ColorMode.disabled, CullFaceMode.disabled, Od(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        resetStencilClippingMasks() {
          this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
        }
        _renderTileClippingMasks(e2, t2, i2) {
          if (!t2 || this.currentStencilSource === t2.id || !e2.isTileClipped() || !i2 || 0 === i2.length)
            return;
          if (this._tileClippingMaskIDs && !this.terrain) {
            let e3 = false;
            for (const t3 of i2)
              if (void 0 === this._tileClippingMaskIDs[t3.key]) {
                e3 = true;
                break;
              }
            if (!e3)
              return;
          }
          this.currentStencilSource = t2.id;
          const r2 = this.context, n2 = r2.gl;
          this.nextStencilID + i2.length > 256 && this.clearStencil(), r2.setColorMode(ColorMode.disabled), r2.setDepthMode(DepthMode.disabled);
          const o2 = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const e3 of i2) {
            const i3 = t2.getTile(e3), s2 = this._tileClippingMaskIDs[e3.key] = this.nextStencilID++, { tileBoundsBuffer: a2, tileBoundsIndexBuffer: l2, tileBoundsSegments: c2 } = this.getTileBoundsBuffers(i3);
            o2.draw(r2, n2.TRIANGLES, DepthMode.disabled, new StencilMode({ func: n2.ALWAYS, mask: 0 }, s2, 255, n2.KEEP, n2.KEEP, n2.REPLACE), ColorMode.disabled, CullFaceMode.disabled, Od(e3.projMatrix), "$clipping", a2, l2, c2);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const e2 = this.nextStencilID++, t2 = this.context.gl;
          return new StencilMode({ func: t2.NOTEQUAL, mask: 255 }, e2, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
        }
        stencilModeForClipping(e2) {
          if (this.terrain)
            return this.terrain.stencilModeForRTTOverlap(e2);
          const t2 = this.context.gl;
          return new StencilMode({ func: t2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e2.key], 0, t2.KEEP, t2.KEEP, t2.REPLACE);
        }
        stencilConfigForOverlap(e2) {
          const t2 = this.context.gl, i2 = e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ), r2 = i2[i2.length - 1].overscaledZ, n2 = i2[0].overscaledZ - r2 + 1;
          if (n2 > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + n2 > 256 && this.clearStencil();
            const e3 = {};
            for (let i3 = 0; i3 < n2; i3++)
              e3[i3 + r2] = new StencilMode({ func: t2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
            return this.nextStencilID += n2, [e3, i2];
          }
          return [{ [r2]: StencilMode.disabled }, i2];
        }
        colorModeForRenderPass() {
          const e2 = this.context.gl;
          if (this._showOverdrawInspector) {
            const t2 = 1 / 8;
            return new ColorMode([e2.CONSTANT_COLOR, e2.ONE], new Gt(t2, t2, t2, 0), [true, true, true, true]);
          }
          return "opaque" === this.renderPass ? ColorMode.unblended : ColorMode.alphaBlended;
        }
        depthModeForSublayer(e2, t2, i2) {
          if (!this.opaquePassEnabledForLayer())
            return DepthMode.disabled;
          const r2 = 1 - ((1 + this.currentLayer) * this.numSublayers + e2) * this.depthEpsilon;
          return new DepthMode(i2 || this.context.gl.LEQUAL, t2, [r2, r2]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(t2, i2) {
          this.style = t2, this.options = i2, this.imageManager = t2.imageManager, this.glyphManager = t2.glyphManager, this.symbolFadeChange = t2.placement.symbolFadeChange(Je.now()), this.imageManager.beginFrame();
          const r2 = this.style.order, n2 = this.style._sourceCaches;
          for (const e2 in n2) {
            const t3 = n2[e2];
            t3.used && t3.prepare(this.context);
          }
          const o2 = {}, s2 = {}, a2 = {};
          for (const e2 in n2) {
            const t3 = n2[e2];
            o2[e2] = t3.getVisibleCoordinates(), s2[e2] = o2[e2].slice().reverse(), a2[e2] = t3.getVisibleCoordinates(true).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let e2 = 0; e2 < r2.length; e2++)
            if (this.style._layers[r2[e2]].is3D()) {
              this.opaquePassCutoff = e2;
              break;
            }
          if (this.terrain && (this.terrain.updateTileBinding(a2), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new GlobeSharedBuffers(this.context)), Ve.has(this.context.gl)) {
            this.renderPass = "offscreen";
            for (const e2 of r2) {
              const i3 = this.style._layers[e2], r3 = t2._getLayerSourceCache(i3);
              if (!i3.hasOffscreenPass() || i3.isHidden(this.transform.zoom))
                continue;
              const n3 = r3 ? s2[r3.id] : void 0;
              ("custom" === i3.type || i3.isSky() || n3 && n3.length) && this.renderLayer(this, r3, i3, n3);
            }
            if (this.depthRangeFor3D = [0, 1 - (t2.order.length + 2) * this.numSublayers * this.depthEpsilon], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]), this.context.clear({ color: i2.showOverdrawInspector ? Gt.black : Gt.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", !this.terrain)
              for (this.currentLayer = r2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const e2 = this.style._layers[r2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
                if (e2.isSky())
                  continue;
                const n3 = i3 ? s2[i3.id] : void 0;
                this._renderTileClippingMasks(e2, i3, n3), this.renderLayer(this, i3, e2, n3);
              }
            if (this.style.fog && this.transform.projection.supportsFog && function(e2, t3) {
              const i3 = e2.context, r3 = i3.gl, n3 = e2.transform, o3 = new DepthMode(r3.LEQUAL, DepthMode.ReadOnly, [0, 1]), s3 = e2.useProgram("globeAtmosphere", null, "globe" === n3.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"]), a3 = zu(n3.zoom), l2 = t3.properties.get("color").toArray01(), c2 = t3.properties.get("high-color").toArray01(), u2 = t3.properties.get("space-color").toArray01PremultipliedAlpha(), h2 = ma([]);
              ga(h2, h2, -y(n3._center.lng)), _a(h2, h2, y(n3._center.lat)), ya(h2, h2, n3.angle), _a(h2, h2, -n3._pitch);
              const p2 = Os(new Float32Array(16), h2), d2 = G(t3.properties.get("star-intensity"), 0, 1, 0, 0.25), f2 = 5e-4, m2 = G(t3.properties.get("horizon-blend"), 0, 1, f2, 0.25), _2 = ku(e2, i3, n3) && m2 === f2 ? n3.worldSize / (2 * Math.PI * 1.025) - 1 : n3.globeRadius, g2 = e2.frameCounter / 1e3 % 1, x2 = qs(n3.globeCenterInViewSpace), v2 = Math.sqrt(Math.pow(x2, 2) - Math.pow(_2, 2)), b2 = Math.acos(v2 / x2), w2 = ((e3, t4, i4, r4, n4, o4, s4, a4, l3, c3, u3, h3, p3, d3) => ({ u_frustum_tl: e3, u_frustum_tr: t4, u_frustum_br: i4, u_frustum_bl: r4, u_horizon: n4, u_transition: o4, u_fadeout_range: s4, u_color: a4, u_high_color: l3, u_space_color: c3, u_star_intensity: u3, u_star_size: 5 * Je.devicePixelRatio, u_star_density: 0, u_temporal_offset: h3, u_horizon_angle: p3, u_rotation_matrix: d3 }))(n3.frustumCorners.TL, n3.frustumCorners.TR, n3.frustumCorners.BR, n3.frustumCorners.BL, n3.frustumCorners.horizon, a3, m2, l2, c2, u2, d2, g2, b2, p2);
              e2.prepareDrawProgram(i3, s3);
              const T2 = e2.atmosphereBuffer;
              T2 && s3.draw(i3, r3.TRIANGLES, o3, StencilMode.disabled, ColorMode.alphaBlended, CullFaceMode.backCW, w2, "skybox", T2.vertexBuffer, T2.indexBuffer, T2.segments);
            }(this, this.style.fog), this.renderPass = "sky", (zu(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible())
              for (this.currentLayer = 0; this.currentLayer < r2.length; this.currentLayer++) {
                const e2 = this.style._layers[r2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
                e2.isSky() && this.renderLayer(this, i3, e2, i3 ? s2[i3.id] : void 0);
              }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < r2.length; ) {
              const e2 = this.style._layers[r2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
              if (e2.isSky()) {
                ++this.currentLayer;
                continue;
              }
              if (this.terrain && this.style.isLayerDraped(e2)) {
                if (e2.isHidden(this.transform.zoom)) {
                  ++this.currentLayer;
                  continue;
                }
                this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                continue;
              }
              const n3 = i3 ? ("symbol" === e2.type ? a2 : s2)[i3.id] : void 0;
              this._renderTileClippingMasks(e2, i3, i3 ? o2[i3.id] : void 0), this.renderLayer(this, i3, e2, n3), ++this.currentLayer;
            }
            if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
              let e2 = null;
              D(this.style._layers).forEach((i3) => {
                const r3 = t2._getLayerSourceCache(i3);
                r3 && !i3.isHidden(this.transform.zoom) && (!e2 || e2.getSource().maxzoom < r3.getSource().maxzoom) && (e2 = r3);
              }), e2 && this.options.showTileBoundaries && jf.debug(this, e2, e2.getVisibleCoordinates());
            }
            this.options.showPadding && function(e2) {
              const t3 = e2.transform.padding;
              Lf(e2, e2.transform.height - (t3.top || 0), 3, Cf), Lf(e2, t3.bottom || 0, 3, If), kf(e2, t3.left || 0, 3, Mf), kf(e2, e2.transform.width - (t3.right || 0), 3, Df);
              const i3 = e2.transform.centerPoint;
              !function(e3, t4, i4, r3) {
                Bf(e3, t4 - 1, i4 - 10, 2, 20, r3), Bf(e3, t4 - 10, i4 - 1, 20, 2, r3);
              }(e2, i3.x, e2.transform.height - i3.y, Pf);
            }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.performance.now()), this.saveCanvasCopy());
          }
        }
        renderLayer(e2, t2, i2, r2) {
          i2.isHidden(this.transform.zoom) || ("background" === i2.type || "sky" === i2.type || "custom" === i2.type || r2 && r2.length) && (this.id = i2.id, this.gpuTimingStart(i2), e2.transform.projection.unsupportedLayers && e2.transform.projection.unsupportedLayers.includes(i2.type) || jf[i2.type](e2, t2, i2, r2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
        }
        gpuTimingStart(e2) {
          if (!this.options.gpuTiming)
            return;
          const t2 = this.context.extTimerQuery;
          let i2 = this.gpuTimers[e2.id];
          i2 || (i2 = this.gpuTimers[e2.id] = { calls: 0, cpuTime: 0, query: t2.createQueryEXT() }), i2.calls++, t2.beginQueryEXT(t2.TIME_ELAPSED_EXT, i2.query);
        }
        gpuTimingDeferredRenderStart() {
          if (this.options.gpuTimingDeferredRender) {
            const e2 = this.context.extTimerQuery, t2 = e2.createQueryEXT();
            this.deferredRenderGpuTimeQueries.push(t2), e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, t2);
          }
        }
        gpuTimingDeferredRenderEnd() {
          if (!this.options.gpuTimingDeferredRender)
            return;
          const e2 = this.context.extTimerQuery;
          e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
        }
        gpuTimingEnd() {
          if (!this.options.gpuTiming)
            return;
          const e2 = this.context.extTimerQuery;
          e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const e2 = this.gpuTimers;
          return this.gpuTimers = {}, e2;
        }
        collectDeferredRenderGpuQueries() {
          const e2 = this.deferredRenderGpuTimeQueries;
          return this.deferredRenderGpuTimeQueries = [], e2;
        }
        queryGpuTimers(e2) {
          const t2 = {};
          for (const i2 in e2) {
            const r2 = e2[i2], n2 = this.context.extTimerQuery, o2 = n2.getQueryObjectEXT(r2.query, n2.QUERY_RESULT_EXT) / 1e6;
            n2.deleteQueryEXT(r2.query), t2[i2] = o2;
          }
          return t2;
        }
        queryGpuTimeDeferredRender(e2) {
          if (!this.options.gpuTimingDeferredRender)
            return 0;
          const t2 = this.context.extTimerQuery;
          let i2 = 0;
          for (const r2 of e2)
            i2 += t2.getQueryObjectEXT(r2, t2.QUERY_RESULT_EXT) / 1e6, t2.deleteQueryEXT(r2);
          return i2;
        }
        translatePosMatrix(e2, t2, i2, r2, n2) {
          if (!i2[0] && !i2[1])
            return e2;
          const o2 = n2 ? "map" === r2 ? this.transform.angle : 0 : "viewport" === r2 ? -this.transform.angle : 0;
          if (o2) {
            const e3 = Math.sin(o2), t3 = Math.cos(o2);
            i2 = [i2[0] * t3 - i2[1] * e3, i2[0] * e3 + i2[1] * t3];
          }
          const s2 = [n2 ? i2[0] : Mh(t2, i2[0], this.transform.zoom), n2 ? i2[1] : Mh(t2, i2[1], this.transform.zoom), 0], a2 = new Float32Array(16);
          return Ps(a2, e2, s2), a2;
        }
        saveTileTexture(e2) {
          const t2 = this._tileTextures[e2.size[0]];
          t2 ? t2.push(e2) : this._tileTextures[e2.size[0]] = [e2];
        }
        getTileTexture(e2) {
          const t2 = this._tileTextures[e2];
          return t2 && t2.length > 0 ? t2.pop() : null;
        }
        isPatternMissing(e2) {
          return null === e2 || void 0 !== e2 && !this.imageManager.getPattern(e2.toString());
        }
        terrainRenderModeElevated() {
          return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
        }
        currentGlobalDefines() {
          const e2 = this.terrain && this.terrain.renderingToTexture, t2 = this.terrain && 0 === this.terrain.exaggeration(), i2 = this.style && this.style.fog, r2 = [];
          return this.terrainRenderModeElevated() && r2.push("TERRAIN"), "globe" === this.transform.projection.name && r2.push("GLOBE"), t2 && r2.push("ZERO_EXAGGERATION"), i2 && !e2 && 0 !== i2.getOpacity(this.transform.pitch) && r2.push("FOG"), e2 && r2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && r2.push("OVERDRAW_INSPECTOR"), r2;
        }
        useProgram(e2, t2, i2) {
          this.cache = this.cache || {};
          const r2 = i2 || [], n2 = this.currentGlobalDefines().concat(r2), o2 = Program.cacheKey(Ed[e2], e2, n2, t2);
          return this.cache[o2] || (this.cache[o2] = new Program(this.context, e2, Ed[e2], t2, mf[e2], n2)), this.cache[o2];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const e2 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
        }
        prepareDrawTile() {
          this.terrain && this.terrain.prepareDrawTile();
        }
        prepareDrawProgram(e2, t2, i2) {
          if (this.terrain && this.terrain.renderingToTexture)
            return;
          const r2 = this.style.fog;
          if (r2) {
            const n2 = r2.getOpacity(this.transform.pitch), o2 = ((e3, t3, i3, r3, n3, o3, s2, a2, l2, c2, u2) => {
              const h2 = e3.transform, p2 = t3.properties.get("color").toArray01();
              p2[3] = r3;
              const d2 = e3.frameCounter / 1e3 % 1;
              return { u_fog_matrix: i3 ? h2.calculateFogTileMatrix(i3) : e3.identityMat, u_fog_range: t3.getFovAdjustedRange(h2._fov), u_fog_color: p2, u_fog_horizon_blend: t3.properties.get("horizon-blend"), u_fog_temporal_offset: d2, u_frustum_tl: n3, u_frustum_tr: o3, u_frustum_br: s2, u_frustum_bl: a2, u_globe_pos: l2, u_globe_radius: c2, u_viewport: u2, u_globe_transition: zu(h2.zoom), u_is_globe: +("globe" === h2.projection.name) };
            })(this, r2, i2, n2, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * Je.devicePixelRatio, this.transform.height * Je.devicePixelRatio]);
            t2.setFogUniformValues(e2, o2);
          }
        }
        setTileLoadedFlag(e2) {
          this.tileLoaded = e2;
        }
        saveCanvasCopy() {
          this.frameCopies.push(this.canvasCopy()), this.tileLoaded = false;
        }
        canvasCopy() {
          const e2 = this.context.gl, t2 = e2.createTexture();
          return e2.bindTexture(e2.TEXTURE_2D, t2), e2.copyTexImage2D(e2.TEXTURE_2D, 0, e2.RGBA, 0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight, 0), t2;
        }
        getCanvasCopiesAndTimestamps() {
          return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
        }
        averageElevationNeedsEasing() {
          if (!this.transform._elevation)
            return false;
          const e2 = this.style && this.style.fog;
          return !!e2 && 0 !== e2.getOpacity(this.transform.pitch);
        }
        getBackgroundTiles() {
          const e2 = this._backgroundTiles, t2 = this._backgroundTiles = {}, i2 = this.transform.coveringTiles({ tileSize: 512 });
          for (const r2 of i2)
            t2[r2.key] = e2[r2.key] || new Tile(r2, 512, this.transform.tileZoom, this);
          return t2;
        }
        clearBackgroundTiles() {
          this._backgroundTiles = {};
        }
      }
      class EdgeInsets {
        constructor(e2 = 0, t2 = 0, i2 = 0, r2 = 0) {
          if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(r2) || r2 < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = e2, this.bottom = t2, this.left = i2, this.right = r2;
        }
        interpolate(e2, t2, i2) {
          return null != t2.top && null != e2.top && (this.top = Ii(e2.top, t2.top, i2)), null != t2.bottom && null != e2.bottom && (this.bottom = Ii(e2.bottom, t2.bottom, i2)), null != t2.left && null != e2.left && (this.left = Ii(e2.left, t2.left, i2)), null != t2.right && null != e2.right && (this.right = Ii(e2.right, t2.right, i2)), this;
        }
        getCenter(e2, t2) {
          const i2 = A((this.left + e2 - this.right) / 2, 0, e2), r2 = A((this.top + t2 - this.bottom) / 2, 0, t2);
          return new d(i2, r2);
        }
        equals(e2) {
          return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
        }
        clone() {
          return new EdgeInsets(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      function Nf(e2, t2) {
        const i2 = ee(e2, 3);
        Os(e2, t2), te(e2, 3, i2);
      }
      function Gf(e2, t2) {
        const i2 = ma([]);
        return ya(i2, i2, -t2), _a(i2, i2, -e2), i2;
      }
      function qf(e2, t2) {
        const i2 = [e2[0], e2[1], 0], r2 = [t2[0], t2[1], 0];
        if (qs(i2) >= 1e-15) {
          const e3 = ea([], i2);
          Ys(r2, e3, ta(r2, e3)), t2[0] = r2[0], t2[1] = r2[1];
        }
        const n2 = ia([], t2, e2);
        if (ua(n2) < 1e-15)
          return null;
        const o2 = Math.atan2(-n2[1], n2[0]);
        return Gf(Math.atan2(Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]), -e2[2]), o2);
      }
      class FreeCameraOptions {
        constructor(e2, t2) {
          this.position = e2, this.orientation = t2;
        }
        get position() {
          return this._position;
        }
        set position(e2) {
          if (e2) {
            const t2 = e2 instanceof MercatorCoordinate ? e2 : new MercatorCoordinate(e2[0], e2[1], e2[2]);
            this._renderWorldCopies && (t2.x = I(t2.x, 0, 1)), this._position = t2;
          } else
            this._position = null;
        }
        lookAtPoint(e2, t2) {
          if (this.orientation = null, !this.position)
            return;
          const i2 = this._elevation ? this._elevation.getAtPointOrZero(MercatorCoordinate.fromLngLat(e2)) : 0, r2 = this.position, n2 = MercatorCoordinate.fromLngLat(e2, i2), o2 = [n2.x - r2.x, n2.y - r2.y, n2.z - r2.z];
          t2 || (t2 = [0, 0, 1]), t2[2] = Math.abs(t2[2]), this.orientation = qf(o2, t2);
        }
        setPitchBearing(e2, t2) {
          this.orientation = Gf(y(e2), y(-t2));
        }
      }
      class FreeCamera {
        constructor(e2, t2) {
          this._transform = Is([]), this.orientation = t2, this.position = e2;
        }
        get mercatorPosition() {
          const e2 = this.position;
          return new MercatorCoordinate(e2[0], e2[1], e2[2]);
        }
        get position() {
          const e2 = ee(this._transform, 3);
          return [e2[0], e2[1], e2[2]];
        }
        set position(e2) {
          var t2;
          e2 && te(this._transform, 3, [(t2 = e2)[0], t2[1], t2[2], 1]);
        }
        get orientation() {
          return this._orientation;
        }
        set orientation(e2) {
          this._orientation = e2 || ma([]), e2 && Nf(this._transform, this._orientation);
        }
        getPitchBearing() {
          const e2 = this.forward(), t2 = this.right();
          return { bearing: Math.atan2(-t2[1], t2[0]), pitch: Math.atan2(Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]), -e2[2]) };
        }
        setPitchBearing(e2, t2) {
          this._orientation = Gf(e2, t2), Nf(this._transform, this._orientation);
        }
        forward() {
          const e2 = ee(this._transform, 2);
          return [-e2[0], -e2[1], -e2[2]];
        }
        up() {
          const e2 = ee(this._transform, 1);
          return [-e2[0], -e2[1], -e2[2]];
        }
        right() {
          const e2 = ee(this._transform, 0);
          return [e2[0], e2[1], e2[2]];
        }
        getCameraToWorld(e2, t2) {
          const i2 = new Float64Array(16);
          return Ms(i2, this.getWorldToCamera(e2, t2)), i2;
        }
        getWorldToCameraPosition(e2, t2, i2) {
          const r2 = this.position;
          Ys(r2, r2, -e2);
          const n2 = new Float64Array(16);
          return Rs(n2, [i2, i2, i2]), Ps(n2, n2, r2), n2[10] *= t2, n2;
        }
        getWorldToCamera(e2, t2) {
          const i2 = new Float64Array(16), r2 = new Float64Array(4), n2 = this.position;
          var o2, s2;
          return (o2 = r2)[0] = -(s2 = this._orientation)[0], o2[1] = -s2[1], o2[2] = -s2[2], o2[3] = s2[3], Ys(n2, n2, -e2), Os(i2, r2), Ps(i2, i2, n2), i2[1] *= -1, i2[5] *= -1, i2[9] *= -1, i2[13] *= -1, i2[8] *= t2, i2[9] *= t2, i2[10] *= t2, i2[11] *= t2, i2;
        }
        getCameraToClipPerspective(e2, t2, i2, r2) {
          const n2 = new Float64Array(16);
          return Us(n2, e2, t2, i2, r2), n2;
        }
        getDistanceToElevation(e2, t2 = false) {
          const i2 = 0 === e2 ? 0 : Vo(e2, t2 ? No(this.position[1]) : this.position[1]), r2 = this.forward();
          return (i2 - this.position[2]) / r2[2];
        }
        clone() {
          return new FreeCamera([...this.position], [...this.orientation]);
        }
      }
      function Zf(e2, t2) {
        const i2 = Wf(e2.projection, e2.zoom, e2.width, e2.height), r2 = function(e3, t3, i3, r3, n3) {
          const o2 = new LngLat(i3.lng - 180 * Hf, i3.lat), s2 = new LngLat(i3.lng + 180 * Hf, i3.lat), a2 = e3.project(o2.lng, o2.lat), l2 = e3.project(s2.lng, s2.lat), c2 = -Math.atan2(l2.y - a2.y, l2.x - a2.x), u2 = MercatorCoordinate.fromLngLat(i3);
          u2.y = A(u2.y, -0.999975, 0.999975);
          const h2 = u2.toLngLat(), p2 = e3.project(h2.lng, h2.lat), d2 = MercatorCoordinate.fromLngLat(h2);
          d2.x += Hf;
          const f2 = d2.toLngLat(), m2 = e3.project(f2.lng, f2.lat), _2 = Kf(m2.x - p2.x, m2.y - p2.y, c2), g2 = MercatorCoordinate.fromLngLat(h2);
          g2.y += Hf;
          const y2 = g2.toLngLat(), x2 = e3.project(y2.lng, y2.lat), v2 = Kf(x2.x - p2.x, x2.y - p2.y, c2), b2 = Math.abs(_2.x) / Math.abs(v2.y), w2 = Is([]);
          Bs(w2, w2, -c2 * (1 - (n3 ? 0 : r3)));
          const T2 = Is([]);
          return zs(T2, T2, [1, 1 - (1 - b2) * r3, 1]), T2[4] = -v2.x / v2.y * r3, Bs(T2, T2, c2), Ds(T2, w2, T2), T2;
        }(e2.projection, 0, e2.center, i2, t2), n2 = $f(e2);
        return zs(r2, r2, [n2, n2, 1]), r2;
      }
      function $f(e2) {
        const t2 = e2.projection, i2 = Wf(e2.projection, e2.zoom, e2.width, e2.height), r2 = Xf(t2, e2.center), n2 = Xf(t2, LngLat.convert(t2.center));
        return Math.pow(2, r2 * i2 + (1 - i2) * n2);
      }
      function Wf(e2, t2, i2, r2, n2 = 1 / 0) {
        const o2 = e2.range;
        if (!o2)
          return 0;
        const s2 = Math.min(n2, Math.max(i2, r2)), a2 = Math.log(s2 / 1024) / Math.LN2;
        return C(o2[0] + a2, o2[1] + a2, t2);
      }
      const Hf = 1 / 4e4;
      function Xf(e2, t2) {
        const i2 = A(t2.lat, -85.051129, qo), r2 = new LngLat(t2.lng - 180 * Hf, i2), n2 = new LngLat(t2.lng + 180 * Hf, i2), o2 = e2.project(r2.lng, i2), s2 = e2.project(n2.lng, i2), a2 = MercatorCoordinate.fromLngLat(r2), l2 = MercatorCoordinate.fromLngLat(n2), c2 = s2.x - o2.x, u2 = s2.y - o2.y, h2 = l2.x - a2.x, p2 = l2.y - a2.y, d2 = Math.sqrt((h2 * h2 + p2 * p2) / (c2 * c2 + u2 * u2));
        return Math.log(d2) / Math.LN2;
      }
      function Kf(e2, t2, i2) {
        const r2 = Math.cos(i2), n2 = Math.sin(i2);
        return { x: e2 * r2 - t2 * n2, y: e2 * n2 + t2 * r2 };
      }
      class Transform {
        constructor(e2, t2, i2, r2, n2, o2, s2) {
          this.tileSize = 512, this._renderWorldCopies = void 0 === n2 || n2, this._minZoom = e2 || 0, this._maxZoom = t2 || 22, this._minPitch = null == i2 ? 0 : i2, this._maxPitch = null == r2 ? 60 : r2, this.setProjection(o2), this.setMaxBounds(s2), this.width = 0, this.height = 0, this._center = new LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new EdgeInsets(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new FreeCamera(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = 0.1;
        }
        clone() {
          const e2 = new Transform(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
          return e2._elevation = this._elevation, e2._centerAltitude = this._centerAltitude, e2._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e2.tileSize = this.tileSize, e2.mercatorFromTransition = this.mercatorFromTransition, e2.width = this.width, e2.height = this.height, e2.cameraElevationReference = this.cameraElevationReference, e2._center = this._center, e2._setZoom(this.zoom), e2._seaLevelZoom = this._seaLevelZoom, e2.angle = this.angle, e2._fov = this._fov, e2._pitch = this._pitch, e2._nearZ = this._nearZ, e2._farZ = this._farZ, e2._averageElevation = this._averageElevation, e2._unmodified = this._unmodified, e2._edgeInsets = this._edgeInsets.clone(), e2._camera = this._camera.clone(), e2._calcMatrices(), e2.freezeTileCoverage = this.freezeTileCoverage, e2.frustumCorners = this.frustumCorners, e2;
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(e2) {
          this._elevation !== e2 && (this._elevation = e2, this._updateCameraOnTerrain(), this._calcMatrices());
        }
        updateElevation(e2, t2 = false) {
          const i2 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
          (null == this._seaLevelZoom || i2) && this._updateCameraOnTerrain(), (e2 || i2) && this._constrainCamera(t2), this._calcMatrices();
        }
        getProjection() {
          return z(this.projection, ["name", "center", "parallels"]);
        }
        setProjection(e2) {
          this.projectionOptions = e2 || { name: "mercator" };
          const t2 = this.projection ? this.getProjection() : void 0;
          this.projection = nh(this.projectionOptions);
          const i2 = !m(t2, this.getProjection());
          return i2 && this._calcMatrices(), this.mercatorFromTransition = false, i2;
        }
        setMercatorFromTransition() {
          const e2 = this.projection.name;
          this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = nh({ name: "mercator" });
          const t2 = e2 !== this.projection.name;
          return t2 && this._calcMatrices(), t2;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(e2) {
          this._minZoom !== e2 && (this._minZoom = e2, this.zoom = Math.max(this.zoom, e2));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(e2) {
          this._maxZoom !== e2 && (this._maxZoom = e2, this.zoom = Math.min(this.zoom, e2));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(e2) {
          this._minPitch !== e2 && (this._minPitch = e2, this.pitch = Math.max(this.pitch, e2));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(e2) {
          this._maxPitch !== e2 && (this._maxPitch = e2, this.pitch = Math.min(this.pitch, e2));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
        }
        set renderWorldCopies(e2) {
          void 0 === e2 ? e2 = true : null === e2 && (e2 = false), this._renderWorldCopies = e2;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get cameraWorldSizeForFog() {
          const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
        }
        get cameraWorldSize() {
          const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
        }
        get pixelsPerMeter() {
          return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
        }
        get cameraPixelsPerMeter() {
          return Vo(this.center.lat, this.cameraWorldSizeForFog);
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new d(this.width, this.height);
        }
        get bearing() {
          return I(this.rotation, -180, 180);
        }
        set bearing(e2) {
          this.rotation = e2;
        }
        get rotation() {
          return -this.angle / Math.PI * 180;
        }
        set rotation(e2) {
          const t2 = -e2 * Math.PI / 180;
          var i2;
          this.angle !== t2 && (this._unmodified = false, this.angle = t2, this._calcMatrices(), this.rotationMatrix = (i2 = new ws(4), ws != Float32Array && (i2[1] = 0, i2[2] = 0), i2[0] = 1, i2[3] = 1, i2), function(e3, t3, i3) {
            var r2 = t3[0], n2 = t3[1], o2 = t3[2], s2 = t3[3], a2 = Math.sin(i3), l2 = Math.cos(i3);
            e3[0] = r2 * l2 + o2 * a2, e3[1] = n2 * l2 + s2 * a2, e3[2] = r2 * -a2 + o2 * l2, e3[3] = n2 * -a2 + s2 * l2;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(e2) {
          const t2 = A(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== t2 && (this._unmodified = false, this._pitch = t2, this._calcMatrices());
        }
        get aspect() {
          return this.width / this.height;
        }
        get fovX() {
          return this._fov;
        }
        get fovY() {
          const e2 = 1 / Math.tan(0.5 * this.fovX);
          return 2 * Math.atan(1 / this.aspect / e2);
        }
        set fov(e2) {
          e2 = Math.max(0.01, Math.min(60, e2)), this._fov !== e2 && (this._unmodified = false, this._fov = y(e2), this._calcMatrices());
        }
        get averageElevation() {
          return this._averageElevation;
        }
        set averageElevation(e2) {
          this._averageElevation = e2, this._calcFogMatrices(), this._distanceTileDataCache = {};
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(e2) {
          const t2 = Math.min(Math.max(e2, this.minZoom), this.maxZoom);
          this._zoom !== t2 && (this._unmodified = false, this._setZoom(t2), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
        }
        _setZoom(e2) {
          this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom;
        }
        _updateCameraOnTerrain() {
          if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center)))
            return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
          const e2 = this._elevation;
          this._centerAltitude = e2.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e2.exaggeration(), this._updateSeaLevelZoom();
        }
        _updateSeaLevelZoom() {
          void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
        }
        sampleAverageElevation() {
          if (!this._elevation)
            return 0;
          const e2 = this._elevation, t2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], i2 = this.horizonLineFromTop();
          let r2 = 0, n2 = 0;
          for (let o2 = 0; o2 < t2.length; o2++) {
            const s2 = new d(t2[o2][0] * this.width, i2 + t2[o2][1] * (this.height - i2)), a2 = e2.pointCoordinate(s2);
            if (!a2)
              continue;
            const l2 = 1 / Math.hypot(a2[0] - this._camera.position[0], a2[1] - this._camera.position[1]);
            r2 += a2[3] * l2, n2 += l2;
          }
          return 0 === n2 ? NaN : r2 / n2;
        }
        get center() {
          return this._center;
        }
        set center(e2) {
          e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
        }
        _updateZoomFromElevation() {
          if (null == this._seaLevelZoom || !this._elevation)
            return;
          const e2 = this._seaLevelZoom, t2 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i2 = this.pixelsPerMeter / this.worldSize * t2, r2 = this._mercatorZfromZoom(e2), n2 = this._mercatorZfromZoom(this._maxZoom), o2 = Math.max(r2 - i2, n2);
          this._setZoom(this._zoomFromMercatorZ(o2));
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(e2) {
          this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
        }
        computeZoomRelativeTo(e2) {
          const t2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, e2.toAltitude()));
          let i2;
          i2 = e2.z < this._camera.position[2] ? [t2.x, t2.y, t2.z] : [e2.x, e2.y, e2.z];
          const r2 = qs(aa([], this._camera.position, i2));
          return A(this._zoomFromMercatorZ(r2), this._minZoom, this._maxZoom);
        }
        setFreeCameraOptions(e2) {
          if (!this.height)
            return;
          if (!e2.position && !e2.orientation)
            return;
          this._updateCameraState();
          let t2 = false;
          if (e2.orientation && !function(e3, t3) {
            return e3[0] === t3[0] && e3[1] === t3[1] && e3[2] === t3[2] && e3[3] === t3[3];
          }(e2.orientation, this._camera.orientation) && (t2 = this._setCameraOrientation(e2.orientation)), e2.position) {
            const n2 = [e2.position.x, e2.position.y, e2.position.z];
            ((i2 = n2)[0] !== (r2 = this._camera.position)[0] || i2[1] !== r2[1] || i2[2] !== r2[2]) && (this._setCameraPosition(n2), t2 = true);
          }
          var i2, r2;
          t2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
        }
        getFreeCameraOptions() {
          this._updateCameraState();
          const e2 = this._camera.position, t2 = new FreeCameraOptions();
          return t2.position = new MercatorCoordinate(e2[0], e2[1], e2[2]), t2.orientation = this._camera.orientation, t2._elevation = this.elevation, t2._renderWorldCopies = this.renderWorldCopies, t2;
        }
        _setCameraOrientation(e2) {
          if (t2 = e2, !Math.hypot(t2[0], t2[1], t2[2], t2[3]))
            return false;
          var t2;
          xa(e2, e2);
          const i2 = oa([], [0, 0, -1], e2), r2 = oa([], [0, -1, 0], e2);
          if (r2[2] < 0)
            return false;
          const n2 = qf(i2, r2);
          return !!n2 && (this._camera.orientation = n2, true);
        }
        _setCameraPosition(e2) {
          const t2 = this.zoomScale(this.minZoom) * this.tileSize, i2 = this.zoomScale(this.maxZoom) * this.tileSize, r2 = this.cameraToCenterDistance;
          e2[2] = A(e2[2], r2 / i2, r2 / t2), this._camera.position = e2;
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        get fovAboveCenter() {
          return this._fov * (0.5 + this.centerOffset.y / this.height);
        }
        isPaddingEqual(e2) {
          return this._edgeInsets.equals(e2);
        }
        interpolatePadding(e2, t2, i2) {
          this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(e2) {
          const t2 = (e2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e2.tileSize));
          return Math.max(0, t2);
        }
        getVisibleUnwrappedCoordinates(e2) {
          const t2 = [new UnwrappedTileID(0, e2)];
          if (this.renderWorldCopies) {
            const i2 = this.pointCoordinate(new d(0, 0)), r2 = this.pointCoordinate(new d(this.width, 0)), n2 = this.pointCoordinate(new d(this.width, this.height)), o2 = this.pointCoordinate(new d(0, this.height)), s2 = Math.floor(Math.min(i2.x, r2.x, n2.x, o2.x)), a2 = Math.floor(Math.max(i2.x, r2.x, n2.x, o2.x)), l2 = 1;
            for (let i3 = s2 - l2; i3 <= a2 + l2; i3++)
              0 !== i3 && t2.push(new UnwrappedTileID(i3, e2));
          }
          return t2;
        }
        coveringTiles(e2) {
          let t2 = this.coveringZoomLevel(e2);
          const i2 = t2, r2 = this.elevation && !e2.isTerrainDEM, n2 = "mercator" === this.projection.name;
          if (void 0 !== e2.minzoom && t2 < e2.minzoom)
            return [];
          void 0 !== e2.maxzoom && t2 > e2.maxzoom && (t2 = e2.maxzoom);
          const o2 = this.locationCoordinate(this.center), s2 = this.center.lat, a2 = 1 << t2, l2 = [a2 * o2.x, a2 * o2.y, 0], c2 = "globe" === this.projection.name, u2 = !c2, h2 = Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t2, u2), p2 = c2 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), d2 = a2 * Vo(1, this.center.lat), f2 = this._camera.position[2] / Vo(1, this.center.lat), m2 = [a2 * p2.x, a2 * p2.y, f2 * (u2 ? 1 : d2)], _2 = this.cameraToCenterDistance / e2.tileSize * (e2.roundZoom ? 1 : 0.502), g2 = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? t2 : 0, y2 = e2.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, x2 = e2.isTerrainDEM ? -y2 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, b2 = this.projection.isReprojectedInTileSpace ? $f(this) : 1, w2 = (e3) => {
            const t3 = 1 / 4e4, i3 = new MercatorCoordinate(e3.x + t3, e3.y, e3.z), r3 = new MercatorCoordinate(e3.x, e3.y + t3, e3.z), n3 = e3.toLngLat(), o3 = i3.toLngLat(), s3 = r3.toLngLat(), a3 = this.locationCoordinate(n3), l3 = this.locationCoordinate(o3), c3 = this.locationCoordinate(s3), u3 = Math.hypot(l3.x - a3.x, l3.y - a3.y), h3 = Math.hypot(c3.x - a3.x, c3.y - a3.y);
            return Math.sqrt(u3 * h3) * b2 / t3;
          }, T2 = (e3) => {
            const t3 = y2, i3 = x2;
            return { aabb: Zu(this, a2, 0, 0, 0, e3, i3, t3, this.projection), zoom: 0, x: 0, y: 0, minZ: i3, maxZ: t3, wrap: e3, fullyVisible: false };
          }, E2 = [];
          let S2 = [];
          const A2 = t2, C2 = e2.reparseOverscaled ? i2 : t2, I2 = (e3) => e3 * e3, M2 = I2((f2 - this._centerAltitude) * d2), D2 = (e3) => {
            if (!this._elevation || !e3.tileID || !n2)
              return;
            const t3 = this._elevation.getMinMaxForTile(e3.tileID), i3 = e3.aabb;
            t3 ? (i3.min[2] = t3.min, i3.max[2] = t3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e3.shouldSplit = P2(e3), e3.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
          }, P2 = (e3) => {
            if (e3.zoom < g2)
              return true;
            if (e3.zoom === A2)
              return false;
            if (null != e3.shouldSplit)
              return e3.shouldSplit;
            const t3 = e3.aabb.distanceX(m2), n3 = e3.aabb.distanceY(m2);
            let o3 = M2, a3 = 1;
            if (c2) {
              o3 = I2(e3.aabb.distanceZ(m2));
              const t4 = Math.pow(2, e3.zoom), i3 = No((e3.y + 1) / t4), r3 = No(e3.y / t4), n4 = Math.min(Math.max(s2, i3), r3), l4 = Fo(n4) / Fo(s2);
              if (a3 = n4 === s2 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, l4 / this._mercatorScaleRatio), this.zoom <= 5 && e3.zoom === A2 - 1 && l4 >= 0.9)
                return true;
            } else if (r2 && (o3 = I2(e3.aabb.distanceZ(m2) * d2)), this.projection.isReprojectedInTileSpace && i2 <= 5) {
              const t4 = Math.pow(2, e3.zoom), i3 = w2(new MercatorCoordinate((e3.x + 0.5) / t4, (e3.y + 0.5) / t4));
              a3 = i3 > 0.85 ? 1 : i3;
            }
            const l3 = t3 * t3 + n3 * n3 + o3, u3 = I2((1 << A2 - e3.zoom) * _2 * a3 * ((e4, t4) => {
              if (t4 * I2(0.707) < e4)
                return 1;
              const i3 = Math.sqrt(t4 / e4);
              return i3 / (1.4144271570014144 + (Math.pow(1.1, i3 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
            })(Math.max(o3, M2), l3));
            return l3 < u3;
          };
          if (this.renderWorldCopies)
            for (let e3 = 1; e3 <= 3; e3++)
              E2.push(T2(-e3)), E2.push(T2(e3));
          for (E2.push(T2(0)); E2.length > 0; ) {
            const i3 = E2.pop(), o3 = i3.x, s3 = i3.y;
            let u3 = i3.fullyVisible;
            if (!u3) {
              const e3 = i3.aabb.intersects(h2);
              if (0 === e3)
                continue;
              u3 = 2 === e3;
            }
            if (i3.zoom !== A2 && P2(i3))
              for (let e3 = 0; e3 < 4; e3++) {
                const t3 = (o3 << 1) + e3 % 2, l3 = (s3 << 1) + (e3 >> 1), h3 = { aabb: n2 ? i3.aabb.quadrant(e3) : Zu(this, a2, i3.zoom + 1, t3, l3, i3.wrap, i3.minZ, i3.maxZ, this.projection), zoom: i3.zoom + 1, x: t3, y: l3, wrap: i3.wrap, fullyVisible: u3, tileID: void 0, shouldSplit: void 0, minZ: i3.minZ, maxZ: i3.maxZ };
                r2 && !c2 && (h3.tileID = new OverscaledTileID(i3.zoom + 1 === A2 ? C2 : i3.zoom + 1, i3.wrap, i3.zoom + 1, t3, l3), D2(h3)), E2.push(h3);
              }
            else {
              const r3 = i3.zoom === A2 ? C2 : i3.zoom;
              if (e2.minzoom && e2.minzoom > r3)
                continue;
              const n3 = l2[0] - (0.5 + o3 + (i3.wrap << i3.zoom)) * (1 << t2 - i3.zoom), a3 = l2[1] - 0.5 - s3, c3 = i3.tileID ? i3.tileID : new OverscaledTileID(r3, i3.wrap, i3.zoom, o3, s3);
              S2.push({ tileID: c3, distanceSq: n3 * n3 + a3 * a3 });
            }
          }
          if (this.fogCullDistSq) {
            const t3 = this.fogCullDistSq, i3 = this.horizonLineFromTop();
            S2 = S2.filter((r3) => {
              const n3 = [0, 0, 0, 1], o3 = [ko, ko, 0, 1], s3 = this.calculateFogTileMatrix(r3.tileID.toUnwrapped());
              da(n3, n3, s3), da(o3, o3, s3);
              const a3 = function(e3, t4, i4) {
                let r4 = 0;
                for (let i5 = 0; i5 < 2; ++i5) {
                  const n4 = 0;
                  e3[i5] > n4 && (r4 += (e3[i5] - n4) * (e3[i5] - n4)), t4[i5] < n4 && (r4 += (n4 - t4[i5]) * (n4 - t4[i5]));
                }
                return r4;
              }(n3, o3);
              if (0 === a3)
                return true;
              let l3 = false;
              const c3 = this._elevation;
              if (c3 && a3 > t3 && 0 !== i3) {
                const t4 = this.calculateProjMatrix(r3.tileID.toUnwrapped());
                let n4;
                e2.isTerrainDEM || (n4 = c3.getMinMaxForTile(r3.tileID)), n4 || (n4 = { min: x2, max: y2 });
                const o4 = function(e3) {
                  const t5 = Math.round((e3 + 45 + 360) % 360 / 90) % 4;
                  return v[t5];
                }(this.rotation), s4 = [o4[0] * ko, o4[1] * ko, n4.max];
                ra(s4, s4, t4), l3 = (1 - s4[1]) * this.height * 0.5 < i3;
              }
              return a3 < t3 || l3;
            });
          }
          return S2.sort((e3, t3) => e3.distanceSq - t3.distanceSq).map((e3) => e3.tileID);
        }
        resize(e2, t2) {
          this.width = e2, this.height = t2, this.pixelsToGLUnits = [2 / e2, -2 / t2], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(e2) {
          return Math.pow(2, e2);
        }
        scaleZoom(e2) {
          return Math.log(e2) / Math.LN2;
        }
        project(e2) {
          const t2 = A(e2.lat, -85.051129, qo), i2 = this.projection.project(e2.lng, t2);
          return new d(i2.x * this.worldSize, i2.y * this.worldSize);
        }
        unproject(e2) {
          return this.projection.unproject(e2.x / this.worldSize, e2.y / this.worldSize);
        }
        get point() {
          return this.project(this.center);
        }
        setLocationAtPoint(e2, t2) {
          let i2, r2;
          const n2 = this.centerPoint;
          if ("globe" === this.projection.name) {
            const e3 = this.worldSize;
            i2 = (t2.x - n2.x) / e3, r2 = (t2.y - n2.y) / e3;
          } else {
            const e3 = this.pointCoordinate(t2), o3 = this.pointCoordinate(n2);
            i2 = e3.x - o3.x, r2 = e3.y - o3.y;
          }
          const o2 = this.locationCoordinate(e2);
          this.setLocation(new MercatorCoordinate(o2.x - i2, o2.y - r2));
        }
        setLocation(e2) {
          this.center = this.coordinateLocation(e2), this.projection.wrap && (this.center = this.center.wrap());
        }
        locationPoint(e2) {
          return this.projection.locationPoint(this, e2);
        }
        locationPoint3D(e2) {
          return this.projection.locationPoint(this, e2, true);
        }
        pointLocation(e2) {
          return this.coordinateLocation(this.pointCoordinate(e2));
        }
        pointLocation3D(e2) {
          return this.coordinateLocation(this.pointCoordinate3D(e2));
        }
        locationCoordinate(e2, t2) {
          const i2 = t2 ? Vo(t2, e2.lat) : void 0, r2 = this.projection.project(e2.lng, e2.lat);
          return new MercatorCoordinate(r2.x, r2.y, i2);
        }
        coordinateLocation(e2) {
          return this.projection.unproject(e2.x, e2.y);
        }
        pointRayIntersection(e2, t2) {
          const i2 = null != t2 ? t2 : this._centerAltitude, r2 = [e2.x, e2.y, 0, 1], n2 = [e2.x, e2.y, 1, 1];
          da(r2, r2, this.pixelMatrixInverse), da(n2, n2, this.pixelMatrixInverse);
          const o2 = n2[3];
          ha(r2, r2, 1 / r2[3]), ha(n2, n2, 1 / o2);
          const s2 = r2[2], a2 = n2[2];
          return { p0: r2, p1: n2, t: s2 === a2 ? 0 : (i2 - s2) / (a2 - s2) };
        }
        screenPointToMercatorRay(e2) {
          const t2 = [e2.x, e2.y, 0, 1], i2 = [e2.x, e2.y, 1, 1];
          return da(t2, t2, this.pixelMatrixInverse), da(i2, i2, this.pixelMatrixInverse), ha(t2, t2, 1 / t2[3]), ha(i2, i2, 1 / i2[3]), t2[2] = Vo(t2[2], this._center.lat) * this.worldSize, i2[2] = Vo(i2[2], this._center.lat) * this.worldSize, ha(t2, t2, 1 / this.worldSize), ha(i2, i2, 1 / this.worldSize), new Ray([t2[0], t2[1], t2[2]], ea([], aa([], i2, t2)));
        }
        rayIntersectionCoordinate(e2) {
          const { p0: t2, p1: i2, t: r2 } = e2, n2 = Vo(t2[2], this._center.lat), o2 = Vo(i2[2], this._center.lat);
          return new MercatorCoordinate(Ii(t2[0], i2[0], r2) / this.worldSize, Ii(t2[1], i2[1], r2) / this.worldSize, Ii(n2, o2, r2));
        }
        pointCoordinate(e2, t2 = this._centerAltitude) {
          return this.projection.pointCoordinate(this, e2.x, e2.y, t2);
        }
        pointCoordinate3D(e2) {
          if (!this.elevation)
            return this.pointCoordinate(e2);
          let t2 = this.projection.pointCoordinate3D(this, e2.x, e2.y);
          if (t2)
            return new MercatorCoordinate(t2[0], t2[1], t2[2]);
          let i2 = 0, r2 = this.horizonLineFromTop();
          if (e2.y > r2)
            return this.pointCoordinate(e2);
          const n2 = 0.02 * r2, o2 = e2.clone();
          for (let e3 = 0; e3 < 10 && r2 - i2 > n2; e3++) {
            o2.y = Ii(i2, r2, 0.66);
            const e4 = this.projection.pointCoordinate3D(this, o2.x, o2.y);
            e4 ? (r2 = o2.y, t2 = e4) : i2 = o2.y;
          }
          return t2 ? new MercatorCoordinate(t2[0], t2[1], t2[2]) : this.pointCoordinate(e2);
        }
        isPointAboveHorizon(e2) {
          return this.projection.isPointAboveHorizon(this, e2);
        }
        _coordinatePoint(e2, t2) {
          const i2 = t2 && this.elevation ? this.elevation.getAtPointOrZero(e2, this._centerAltitude) : this._centerAltitude, r2 = [e2.x * this.worldSize, e2.y * this.worldSize, i2 + e2.toAltitude(), 1];
          return da(r2, r2, this.pixelMatrix), r2[3] > 0 ? new d(r2[0] / r2[3], r2[1] / r2[3]) : new d(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        _getGlobeBounds() {
          const { top: e2, left: t2 } = this._edgeInsets, i2 = this.height - this._edgeInsets.bottom, r2 = this.width - this._edgeInsets.right, n2 = this.pointCoordinate3D(new d(t2, e2)), o2 = this.pointCoordinate3D(new d(r2, e2)), s2 = this.pointCoordinate3D(new d(r2, i2)), a2 = this.pointCoordinate3D(new d(t2, i2));
          let l2 = Math.min(n2.x, a2.x), c2 = Math.max(o2.x, s2.x), u2 = Math.min(n2.y, o2.y), h2 = Math.max(a2.y, s2.y);
          const p2 = Math.pow(2, -this.zoom) / 16, f2 = (e3, t3, i3, r3) => {
            const n3 = (e3 + i3) / 2, o3 = (t3 + r3) / 2, s3 = new d(n3, o3), a3 = this.pointCoordinate3D(s3), m3 = Math.max(0, l2 - a3.x, u2 - a3.y, a3.x - c2, a3.y - h2);
            l2 = Math.min(l2, a3.x), c2 = Math.max(c2, a3.x), u2 = Math.min(u2, a3.y), h2 = Math.max(h2, a3.y), m3 > p2 && (f2(e3, t3, n3, o3), f2(n3, o3, i3, r3));
          };
          f2(t2, e2, r2, e2), f2(r2, e2, r2, i2), f2(r2, i2, t2, i2), f2(t2, i2, t2, e2);
          const [m2, _2] = function(e3) {
            const t3 = Is(new Float64Array(16));
            Ds(t3, e3.pixelMatrix, e3.globeMatrix);
            const i3 = [0, hu, 0], r3 = [0, pu, 0];
            return ra(i3, i3, t3), ra(r3, r3, t3), [i3[0] > 0 && i3[0] <= e3.width && i3[1] > 0 && i3[1] <= e3.height && !Uu(e3, new LngLat(e3.center.lat, 90)), r3[0] > 0 && r3[0] <= e3.width && r3[1] > 0 && r3[1] <= e3.height && !Uu(e3, new LngLat(e3.center.lat, -90))];
          }(this), g2 = m2 || _2, y2 = m2 ? 90 : No(u2), x2 = g2 ? 180 : jo(c2), v2 = _2 ? -90 : No(h2), b2 = g2 ? -180 : jo(l2);
          return new LngLatBounds(new LngLat(b2, v2), new LngLat(x2, y2));
        }
        _getBounds(e2, t2) {
          if ("globe" === this.projection.name)
            return this._getGlobeBounds();
          const i2 = new d(this._edgeInsets.left, this._edgeInsets.top), r2 = new d(this.width - this._edgeInsets.right, this._edgeInsets.top), n2 = new d(this.width - this._edgeInsets.right, this.height - this._edgeInsets.bottom), o2 = new d(this._edgeInsets.left, this.height - this._edgeInsets.bottom);
          let s2 = this.pointCoordinate(i2, e2), a2 = this.pointCoordinate(r2, e2);
          const l2 = this.pointCoordinate(n2, t2), c2 = this.pointCoordinate(o2, t2), u2 = (e3, t3) => (t3.y - e3.y) / (t3.x - e3.x);
          return s2.y > 1 && a2.y >= 0 ? s2 = new MercatorCoordinate((1 - c2.y) / u2(c2, s2) + c2.x, 1) : s2.y < 0 && a2.y <= 1 && (s2 = new MercatorCoordinate(-c2.y / u2(c2, s2) + c2.x, 0)), a2.y > 1 && s2.y >= 0 ? a2 = new MercatorCoordinate((1 - l2.y) / u2(l2, a2) + l2.x, 1) : a2.y < 0 && s2.y <= 1 && (a2 = new MercatorCoordinate(-l2.y / u2(l2, a2) + l2.x, 0)), new LngLatBounds().extend(this.coordinateLocation(s2)).extend(this.coordinateLocation(a2)).extend(this.coordinateLocation(c2)).extend(this.coordinateLocation(l2));
        }
        _getBounds3D() {
          const e2 = this.elevation;
          if (!e2.visibleDemTiles.length || e2.isUsingMockSource())
            return this._getBounds(0, 0);
          const t2 = e2.visibleDemTiles.reduce((e3, t3) => {
            if (t3.dem) {
              const i2 = t3.dem.tree;
              e3.min = Math.min(e3.min, i2.minimums[0]), e3.max = Math.max(e3.max, i2.maximums[0]);
            }
            return e3;
          }, { min: Number.MAX_VALUE, max: 0 });
          return this._getBounds(t2.min * e2.exaggeration(), t2.max * e2.exaggeration());
        }
        getBounds() {
          return this._terrainEnabled() ? this._getBounds3D() : this._getBounds(0, 0);
        }
        horizonLineFromTop(e2 = true) {
          const t2 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) + this.centerOffset.y, i2 = this.height / 2 - t2 * (1 - this._horizonShift);
          return e2 ? Math.max(0, i2) : i2;
        }
        getMaxBounds() {
          return this.maxBounds;
        }
        setMaxBounds(e2) {
          this.maxBounds = e2, this.minLat = -85.051129, this.maxLat = qo, this.minLng = -180, this.maxLng = 180, e2 && (this.minLat = e2.getSouth(), this.maxLat = e2.getNorth(), this.minLng = e2.getWest(), this.maxLng = e2.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = Oo(this.minLng) * this.tileSize, this.worldMaxX = Oo(this.maxLng) * this.tileSize, this.worldMinY = Uo(this.maxLat) * this.tileSize, this.worldMaxY = Uo(this.minLat) * this.tileSize, this._constrain();
        }
        calculatePosMatrix(e2, t2) {
          return this.projection.createTileMatrix(this, t2, e2);
        }
        calculateDistanceTileData(e2) {
          const t2 = e2.key, i2 = this._distanceTileDataCache;
          if (i2[t2])
            return i2[t2];
          const r2 = e2.canonical, n2 = 1 / this.height, o2 = this.cameraWorldSize, s2 = o2 / this.zoomScale(r2.z), a2 = (r2.x + Math.pow(2, r2.z) * e2.wrap) * s2, l2 = r2.y * s2, c2 = this.point;
          c2.x *= o2 / this.worldSize, c2.y *= o2 / this.worldSize;
          const u2 = this.angle, h2 = Math.sin(-u2), p2 = -Math.cos(-u2);
          return i2[t2] = { bearing: [h2, p2], center: [(c2.x - a2) * n2, (c2.y - l2) * n2], scale: s2 / ko * n2 }, i2[t2];
        }
        calculateFogTileMatrix(e2) {
          const t2 = e2.key, i2 = this._fogTileMatrixCache;
          if (i2[t2])
            return i2[t2];
          const r2 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, e2);
          return Ds(r2, this.worldToFogMatrix, r2), i2[t2] = new Float32Array(r2), i2[t2];
        }
        calculateProjMatrix(e2, t2 = false) {
          const i2 = e2.key, r2 = t2 ? this._alignedProjMatrixCache : this._projMatrixCache;
          if (r2[i2])
            return r2[i2];
          const n2 = this.calculatePosMatrix(e2, this.worldSize);
          return Ds(n2, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : t2 ? this.alignedProjMatrix : this.projMatrix, n2), r2[i2] = new Float32Array(n2), r2[i2];
        }
        calculatePixelsToTileUnitsMatrix(e2) {
          const t2 = e2.tileID.key, i2 = this._pixelsToTileUnitsCache;
          if (i2[t2])
            return i2[t2];
          const r2 = function(e3, t3) {
            const { scale: i3 } = e3.tileTransform, r3 = i3 * ko / (e3.tileSize * Math.pow(2, t3.zoom - e3.tileID.overscaledZ + e3.tileID.canonical.z));
            return function(e4, t4, i4) {
              var r4 = t4[1], n2 = t4[2], o2 = t4[3], s2 = i4[0], a2 = i4[1];
              return e4[0] = t4[0] * s2, e4[1] = r4 * s2, e4[2] = n2 * a2, e4[3] = o2 * a2, e4;
            }(new Float32Array(4), t3.inverseAdjustmentMatrix, [r3, r3]);
          }(e2, this);
          return i2[t2] = r2, i2[t2];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        recenterOnTerrain() {
          if (!this._elevation || "globe" === this.projection.name)
            return;
          const e2 = this._elevation;
          this._updateCameraState();
          const t2 = Vo(1, this._center.lat) * this.worldSize, i2 = this._computeCameraPosition(t2), r2 = this._camera.forward(), n2 = Vo(1, this._center.lat);
          i2[2] /= n2, r2[2] /= n2, ea(r2, r2);
          const o2 = e2.raycast(i2, r2, e2.exaggeration());
          if (o2) {
            const e3 = Js([], i2, r2, o2), t3 = new MercatorCoordinate(e3[0], e3[1], Vo(e3[2], No(e3[1]))), s2 = (t3.z + qs([t3.x - i2[0], t3.y - i2[1], t3.z - i2[2] * n2])) * this._pixelsPerMercatorPixel;
            this._seaLevelZoom = this._zoomFromMercatorZ(s2), this._centerAltitude = t3.toAltitude(), this._center = this.coordinateLocation(t3), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
          }
        }
        _constrainCamera(e2 = false) {
          if (!this._elevation)
            return;
          const t2 = this._elevation, i2 = Vo(1, this._center.lat) * this.worldSize, r2 = this._computeCameraPosition(i2), n2 = t2.getAtPointOrZero(new MercatorCoordinate(...r2)), o2 = this.pixelsPerMeter / this.worldSize * n2, s2 = this._minimumHeightOverTerrain(), a2 = r2[2] - o2;
          if (a2 <= s2)
            if (a2 < 0 || e2) {
              const e3 = this.locationCoordinate(this._center, this._centerAltitude), t3 = [r2[0], r2[1], e3.z - r2[2]], i3 = qs(t3);
              t3[2] -= (s2 - a2) / this._pixelsPerMercatorPixel;
              const n3 = qs(t3);
              if (0 === n3)
                return;
              Ys(t3, t3, i3 / n3 * this._pixelsPerMercatorPixel), this._camera.position = [r2[0], r2[1], e3.z * this._pixelsPerMercatorPixel - t3[2]], this._updateStateFromCamera();
            } else
              this._isCameraConstrained = true;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = true;
          const e2 = "globe" === this.projection.name || this.mercatorFromTransition;
          if (this.projection.isReprojectedInTileSpace || e2) {
            const t3 = this.center;
            return t3.lat = A(t3.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !e2) && (t3.lng = A(t3.lng, this.minLng, this.maxLng)), this.center = t3, void (this._constraining = false);
          }
          const t2 = this._unmodified, { x: i2, y: r2 } = this.point;
          let n2 = 0, o2 = i2, s2 = r2;
          const a2 = this.width / 2, l2 = this.height / 2, c2 = this.worldMinY * this.scale, u2 = this.worldMaxY * this.scale;
          if (r2 - l2 < c2 && (s2 = c2 + l2), r2 + l2 > u2 && (s2 = u2 - l2), u2 - c2 < this.height && (n2 = Math.max(n2, this.height / (u2 - c2)), s2 = (u2 + c2) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
            const e3 = this.worldMinX * this.scale, t3 = this.worldMaxX * this.scale, r3 = this.worldSize / 2 - (e3 + t3) / 2;
            o2 = (i2 + r3 + this.worldSize) % this.worldSize - r3, o2 - a2 < e3 && (o2 = e3 + a2), o2 + a2 > t3 && (o2 = t3 - a2), t3 - e3 < this.width && (n2 = Math.max(n2, this.width / (t3 - e3)), o2 = (t3 + e3) / 2);
          }
          o2 === i2 && s2 === r2 || (this.center = this.unproject(new d(o2, s2))), n2 && (this.zoom += this.scaleZoom(n2)), this._constrainCamera(), this._unmodified = t2, this._constraining = false;
        }
        _minZoomForBounds() {
          let e2 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
          return this.maxBounds && (e2 = Math.max(e2, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e2;
        }
        _maxCameraBoundsDistance() {
          return this._mercatorZfromZoom(this._minZoomForBounds());
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const e2 = this.centerOffset, t2 = this.pixelsPerMeter;
          "globe" === this.projection.name && (this._mercatorScaleRatio = Vo(1, this.center.lat) / Vo(1, 45));
          const i2 = Wf(this.projection, this.zoom, this.width, this.height, 1024);
          this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, i2), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
          const r2 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? t2 : 1), n2 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
          n2[8] = 2 * -e2.x / this.width, n2[9] = 2 * e2.y / this.height;
          let o2 = js([], n2, r2);
          if (this.projection.isReprojectedInTileSpace) {
            const e3 = this.locationCoordinate(this.center), t3 = Is([]);
            Ps(t3, t3, [e3.x * this.worldSize, e3.y * this.worldSize, 0]), Ds(t3, t3, Zf(this)), Ps(t3, t3, [-e3.x * this.worldSize, -e3.y * this.worldSize, 0]), Ds(o2, o2, t3), this.inverseAdjustmentMatrix = function(e4) {
              const t4 = Zf(e4, true);
              return Ts([], [t4[0], t4[1], t4[4], t4[5]]);
            }(this);
          } else
            this.inverseAdjustmentMatrix = [1, 0, 0, 1];
          this.mercatorMatrix = zs([], o2, [this.worldSize, this.worldSize, this.worldSize / t2, 1]), this.projMatrix = o2, this.invProjMatrix = Ms(new Float64Array(16), this.projMatrix);
          const s2 = Ms([], n2);
          this.frustumCorners = FrustumCorners.fromInvProjectionMatrix(s2, this.horizonLineFromTop(), this.height);
          const a2 = new Float32Array(16);
          Is(a2), zs(a2, a2, [1, -1, 1]), Ls(a2, a2, this._pitch), Bs(a2, a2, this.angle);
          const l2 = Us(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), c2 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
          l2[8] = 2 * -e2.x / this.width, l2[9] = 2 * (e2.y + c2) / this.height, this.skyboxMatrix = Ds(a2, l2, a2);
          const u2 = this.point, h2 = u2.x, p2 = u2.y, d2 = this.width % 2 / 2, f2 = this.height % 2 / 2, m2 = Math.cos(this.angle), _2 = Math.sin(this.angle), g2 = h2 - Math.round(h2) + m2 * d2 + _2 * f2, y2 = p2 - Math.round(p2) + m2 * f2 + _2 * d2, x2 = new Float64Array(o2);
          if (Ps(x2, x2, [g2 > 0.5 ? g2 - 1 : g2, y2 > 0.5 ? y2 - 1 : y2, 0]), this.alignedProjMatrix = x2, o2 = Cs(), zs(o2, o2, [this.width / 2, -this.height / 2, 1]), Ps(o2, o2, [1, -1, 0]), this.labelPlaneMatrix = o2, o2 = Cs(), zs(o2, o2, [1, -1, 1]), Ps(o2, o2, [-1, -1, 0]), zs(o2, o2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = o2, this.pixelMatrix = Ds(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, o2 = Ms(new Float64Array(16), this.pixelMatrix), !o2)
            throw new Error("failed to invert matrix");
          if (this.pixelMatrixInverse = o2, "globe" === this.projection.name || this.mercatorFromTransition) {
            this.globeMatrix = function(e4) {
              const { x: t3, y: i3 } = e4.point, { lng: r3, lat: n3 } = e4._center;
              return Pu(t3, i3, e4.worldSize, r3, n3);
            }(this);
            const e3 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
            this.globeCenterInViewSpace = ra(e3, e3, r2), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
          } else
            this.globeMatrix = o2;
          this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
        }
        _calcFogMatrices() {
          this._fogTileMatrixCache = {};
          const e2 = this.cameraWorldSizeForFog, t2 = this.cameraPixelsPerMeter, i2 = this._camera.position, r2 = 1 / this.height / this._pixelsPerMercatorPixel, n2 = [e2, e2, t2];
          Ys(n2, n2, r2), Ys(i2, i2, -1), Hs(i2, i2, n2);
          const o2 = Cs();
          Ps(o2, o2, i2), zs(o2, o2, n2), this.mercatorFogMatrix = o2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(e2, t2, r2);
        }
        _computeCameraPosition(e2) {
          const t2 = (e2 = e2 || this.pixelsPerMeter) / this.pixelsPerMeter, i2 = this._camera.forward(), r2 = this.point, n2 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t2 - e2 / this.worldSize * this._centerAltitude;
          return [r2.x / this.worldSize - i2[0] * n2, r2.y / this.worldSize - i2[1] * n2, e2 / this.worldSize * this._centerAltitude - i2[2] * n2];
        }
        _updateCameraState() {
          this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
        }
        _translateCameraConstrained(e2) {
          const t2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), i2 = this._camera.position[2], r2 = e2[2];
          let n2 = 1;
          this.projection.wrap && (this.center = this.center.wrap()), r2 > 0 && (n2 = Math.min((t2 - i2) / r2, 1)), this._camera.position = Js([], this._camera.position, e2, n2), this._updateStateFromCamera();
        }
        _updateStateFromCamera() {
          const e2 = this._camera.position, t2 = this._camera.forward(), { pitch: i2, bearing: r2 } = this._camera.getPitchBearing(), n2 = Vo(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, o2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(y(this._maxPitch)), s2 = Math.max((e2[2] - n2) / Math.cos(i2), o2), a2 = this._zoomFromMercatorZ(s2);
          Js(e2, e2, t2, s2), this._pitch = A(i2, y(this.minPitch), y(this.maxPitch)), this.angle = I(r2, -Math.PI, Math.PI), this._setZoom(A(a2, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new MercatorCoordinate(e2[0], e2[1], e2[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
        }
        _worldSizeFromZoom(e2) {
          return Math.pow(2, e2) * this.tileSize;
        }
        _mercatorZfromZoom(e2) {
          return this.cameraToCenterDistance / this._worldSizeFromZoom(e2);
        }
        _minimumHeightOverTerrain() {
          const e2 = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
          return this._mercatorZfromZoom(e2);
        }
        _zoomFromMercatorZ(e2) {
          return this.scaleZoom(this.cameraToCenterDistance / (e2 * this.tileSize));
        }
        zoomFromMercatorZAdjusted(e2) {
          const t2 = (t3) => {
            const i3 = this.getCameraToCenterDistance(this.projection, t3);
            return this.scaleZoom(i3 / (e2 * this.tileSize));
          };
          let i2, r2 = t2(this.zoom), n2 = Math.abs(r2 - t2(r2));
          for (; i2 !== n2; )
            r2 = t2(r2), i2 = n2, n2 = Math.abs(r2 - t2(r2));
          return r2;
        }
        _terrainEnabled() {
          return !(!this._elevation || !this.projection.supportsTerrain && (Z("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
        }
        anyCornerOffEdge(e2, t2) {
          const i2 = Math.min(e2.x, t2.x), r2 = Math.max(e2.x, t2.x), n2 = Math.min(e2.y, t2.y), o2 = Math.max(e2.y, t2.y);
          if (n2 < this.horizonLineFromTop(false))
            return true;
          if ("mercator" !== this.projection.name)
            return false;
          const s2 = [new d(i2, n2), new d(r2, o2), new d(i2, o2), new d(r2, n2)], a2 = this.renderWorldCopies ? -3 : 0, l2 = this.renderWorldCopies ? 4 : 1;
          for (const e3 of s2) {
            const t3 = this.pointRayIntersection(e3);
            if (t3.t < 0)
              return true;
            const i3 = this.rayIntersectionCoordinate(t3);
            if (i3.x < a2 || i3.y < 0 || i3.x > l2 || i3.y > 1)
              return true;
          }
          return false;
        }
        isHorizonVisible() {
          return this.pitch + x(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new d(0, 0), new d(this.width, this.height));
        }
        zoomDeltaToMovement(e2, t2) {
          const i2 = qs(aa([], this._camera.position, e2)), r2 = this._zoomFromMercatorZ(i2) + t2;
          return i2 - this._mercatorZfromZoom(r2);
        }
        getCameraPoint() {
          if ("globe" === this.projection.name) {
            const e2 = function([e3, t2, i2], r2) {
              const n2 = [e3, t2, i2, 1];
              da(n2, n2, r2);
              const o2 = n2[3] = Math.max(n2[3], 1e-6);
              return n2[0] /= o2, n2[1] /= o2, n2[2] /= o2, n2;
            }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
            return new d(e2[0], e2[1]);
          }
          {
            const e2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new d(0, e2));
          }
        }
        getCameraToCenterDistance(e2, t2 = this.zoom) {
          const i2 = Wf(e2, t2, this.width, this.height, 1024), r2 = e2.pixelSpaceConversion(this.center.lat, this.worldSize, i2);
          return 0.5 / Math.tan(0.5 * this._fov) * this.height * r2;
        }
        getWorldToCameraMatrix() {
          const e2 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
          return "globe" === this.projection.name && Ds(e2, e2, this.globeMatrix), e2;
        }
      }
      function Yf(e2, t2) {
        let i2 = false, r2 = null;
        const n2 = () => {
          r2 = null, i2 && (e2(), r2 = setTimeout(n2, t2), i2 = false);
        };
        return () => (i2 = true, r2 || n2(), r2);
      }
      class Hash {
        constructor(e2) {
          this._hashName = e2 && encodeURIComponent(e2), O(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Yf(this._updateHashUnthrottled.bind(this), 300);
        }
        addTo(t2) {
          return this._map = t2, e.addEventListener("hashchange", this._onHashChange, false), t2.on("moveend", this._updateHash), this;
        }
        remove() {
          return this._map ? (this._map.off("moveend", this._updateHash), e.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
        }
        getHashString() {
          const t2 = this._map;
          if (!t2)
            return "";
          const i2 = Jf(t2);
          if (this._hashName) {
            const t3 = this._hashName;
            let r2 = false;
            const n2 = e.location.hash.slice(1).split("&").map((e2) => {
              const n3 = e2.split("=")[0];
              return n3 === t3 ? (r2 = true, `${n3}=${i2}`) : e2;
            }).filter((e2) => e2);
            return r2 || n2.push(`${t3}=${i2}`), `#${n2.join("&")}`;
          }
          return `#${i2}`;
        }
        _getCurrentHash() {
          const t2 = e.location.hash.replace("#", "");
          if (this._hashName) {
            let e2;
            return t2.split("&").map((e3) => e3.split("=")).forEach((t3) => {
              t3[0] === this._hashName && (e2 = t3);
            }), (e2 && e2[1] || "").split("/");
          }
          return t2.split("/");
        }
        _onHashChange() {
          const e2 = this._map;
          if (!e2)
            return false;
          const t2 = this._getCurrentHash();
          if (t2.length >= 3 && !t2.some((e3) => isNaN(e3))) {
            const i2 = e2.dragRotate.isEnabled() && e2.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : e2.getBearing();
            return e2.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: i2, pitch: +(t2[4] || 0) }), true;
          }
          return false;
        }
        _updateHashUnthrottled() {
          const t2 = e.location.href.replace(/(#.+)?$/, this.getHashString());
          e.history.replaceState(e.history.state, null, t2);
        }
      }
      function Jf(e2, t2) {
        const i2 = e2.getCenter(), r2 = Math.round(100 * e2.getZoom()) / 100, n2 = Math.ceil((r2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), o2 = Math.pow(10, n2), s2 = Math.round(i2.lng * o2) / o2, a2 = Math.round(i2.lat * o2) / o2, l2 = e2.getBearing(), c2 = e2.getPitch();
        let u2 = t2 ? `/${s2}/${a2}/${r2}` : `${r2}/${a2}/${s2}`;
        return (l2 || c2) && (u2 += "/" + Math.round(10 * l2) / 10), c2 && (u2 += `/${Math.round(c2)}`), u2;
      }
      const Qf = { linearity: 0.3, easing: E(0, 0, 0.3, 1) }, em = P({ deceleration: 2500, maxSpeed: 1400 }, Qf), tm = P({ deceleration: 20, maxSpeed: 1400 }, Qf), im = P({ deceleration: 1e3, maxSpeed: 360 }, Qf), rm = P({ deceleration: 1e3, maxSpeed: 90 }, Qf);
      class HandlerInertia {
        constructor(e2) {
          this._map = e2, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(e2) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: Je.now(), settings: e2 });
        }
        _drainInertiaBuffer() {
          const e2 = this._inertiaBuffer, t2 = Je.now();
          for (; e2.length > 0 && t2 - e2[0].time > 160; )
            e2.shift();
        }
        _onMoveEnd(e2) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
            return;
          const t2 = { zoom: 0, bearing: 0, pitch: 0, pan: new d(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: e3 } of this._inertiaBuffer)
            t2.zoom += e3.zoomDelta || 0, t2.bearing += e3.bearingDelta || 0, t2.pitch += e3.pitchDelta || 0, e3.panDelta && t2.pan._add(e3.panDelta), e3.around && (t2.around = e3.around), e3.pinchAround && (t2.pinchAround = e3.pinchAround);
          const i2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r2 = {};
          if (t2.pan.mag()) {
            const n2 = om(t2.pan.mag(), i2, P({}, em, e2 || {}));
            r2.offset = t2.pan.mult(n2.amount / t2.pan.mag()), r2.center = this._map.transform.center, nm(r2, n2);
          }
          if (t2.zoom) {
            const e3 = om(t2.zoom, i2, tm);
            r2.zoom = this._map.transform.zoom + e3.amount, nm(r2, e3);
          }
          if (t2.bearing) {
            const e3 = om(t2.bearing, i2, im);
            r2.bearing = this._map.transform.bearing + A(e3.amount, -179, 179), nm(r2, e3);
          }
          if (t2.pitch) {
            const e3 = om(t2.pitch, i2, rm);
            r2.pitch = this._map.transform.pitch + e3.amount, nm(r2, e3);
          }
          if (r2.zoom || r2.bearing) {
            const e3 = void 0 === t2.pinchAround ? t2.around : t2.pinchAround;
            r2.around = e3 ? this._map.unproject(e3) : this._map.getCenter();
          }
          return this.clear(), r2.noMoveStart = true, r2;
        }
      }
      function nm(e2, t2) {
        (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
      }
      function om(e2, t2, i2) {
        const { maxSpeed: r2, linearity: n2, deceleration: o2 } = i2, s2 = A(e2 * n2 / (t2 / 1e3), -r2, r2), a2 = Math.abs(s2) / (o2 * n2);
        return { easing: i2.easing, duration: 1e3 * a2, amount: s2 * (a2 / 2) };
      }
      class MapMouseEvent extends Event {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e2, t2, i2, r2 = {}) {
          const n2 = lt(t2.getCanvasContainer(), i2);
          super(e2, P({ point: n2, lngLat: t2.unproject(n2), originalEvent: i2 }, r2)), this._defaultPrevented = false, this.target = t2;
        }
      }
      class MapTouchEvent extends Event {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e2, t2, i2) {
          const r2 = "touchend" === e2 ? i2.changedTouches : i2.touches, n2 = ct(t2.getCanvasContainer(), r2), o2 = n2.map((e3) => t2.unproject(e3)), s2 = n2.reduce((e3, t3, i3, r3) => e3.add(t3.div(r3.length)), new d(0, 0));
          super(e2, { points: n2, point: s2, lngLats: o2, lngLat: t2.unproject(s2), originalEvent: i2 }), this._defaultPrevented = false;
        }
      }
      class MapWheelEvent extends Event {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e2, t2, i2) {
          super(e2, { originalEvent: i2 }), this._defaultPrevented = false;
        }
      }
      class MapEventHandler {
        constructor(e2, t2) {
          this._map = e2, this._clickTolerance = t2.clickTolerance;
        }
        reset() {
          this._mousedownPos = void 0;
        }
        wheel(e2) {
          return this._firePreventable(new MapWheelEvent(e2.type, this._map, e2));
        }
        mousedown(e2, t2) {
          return this._mousedownPos = t2, this._firePreventable(new MapMouseEvent(e2.type, this._map, e2));
        }
        mouseup(e2) {
          this._map.fire(new MapMouseEvent(e2.type, this._map, e2));
        }
        preclick(e2) {
          const t2 = P({}, e2);
          t2.type = "preclick", this._map.fire(new MapMouseEvent(t2.type, this._map, t2));
        }
        click(e2, t2) {
          this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || (this.preclick(e2), this._map.fire(new MapMouseEvent(e2.type, this._map, e2)));
        }
        dblclick(e2) {
          return this._firePreventable(new MapMouseEvent(e2.type, this._map, e2));
        }
        mouseover(e2) {
          this._map.fire(new MapMouseEvent(e2.type, this._map, e2));
        }
        mouseout(e2) {
          this._map.fire(new MapMouseEvent(e2.type, this._map, e2));
        }
        touchstart(e2) {
          return this._firePreventable(new MapTouchEvent(e2.type, this._map, e2));
        }
        touchmove(e2) {
          this._map.fire(new MapTouchEvent(e2.type, this._map, e2));
        }
        touchend(e2) {
          this._map.fire(new MapTouchEvent(e2.type, this._map, e2));
        }
        touchcancel(e2) {
          this._map.fire(new MapTouchEvent(e2.type, this._map, e2));
        }
        _firePreventable(e2) {
          if (this._map.fire(e2), e2.defaultPrevented)
            return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class BlockableMapEventHandler {
        constructor(e2) {
          this._map = e2;
        }
        reset() {
          this._delayContextMenu = false, this._contextMenuEvent = void 0;
        }
        mousemove(e2) {
          this._map.fire(new MapMouseEvent(e2.type, this._map, e2));
        }
        mousedown() {
          this._delayContextMenu = true;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new MapMouseEvent("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e2) {
          this._delayContextMenu ? this._contextMenuEvent = e2 : this._map.fire(new MapMouseEvent(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class BoxZoomHandler {
        constructor(e2, t2) {
          this._map = e2, this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(e2, t2) {
          this.isEnabled() && e2.shiftKey && 0 === e2.button && (nt(), this._startPos = this._lastPos = t2, this._active = true);
        }
        mousemoveWindow(e2, t2) {
          if (!this._active)
            return;
          const i2 = t2, r2 = this._startPos, n2 = this._lastPos;
          if (!r2 || !n2 || n2.equals(i2) || !this._box && i2.dist(r2) < this._clickTolerance)
            return;
          this._lastPos = i2, this._box || (this._box = Qe("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e2));
          const o2 = Math.min(r2.x, i2.x), s2 = Math.max(r2.x, i2.x), a2 = Math.min(r2.y, i2.y), l2 = Math.max(r2.y, i2.y);
          this._map._requestDomTask(() => {
            this._box && (this._box.style.transform = `translate(${o2}px,${a2}px)`, this._box.style.width = s2 - o2 + "px", this._box.style.height = l2 - a2 + "px");
          });
        }
        mouseupWindow(e2, t2) {
          if (!this._active)
            return;
          const i2 = this._startPos, r2 = t2;
          if (i2 && 0 === e2.button) {
            if (this.reset(), at(), i2.x !== r2.x || i2.y !== r2.y)
              return this._map.fire(new Event("boxzoomend", { originalEvent: e2 })), { cameraAnimation: (e3) => e3.fitScreenCoordinates(i2, r2, this._map.getBearing(), { linear: false }) };
            this._fireEvent("boxzoomcancel", e2);
          }
        }
        keydown(e2) {
          this._active && 27 === e2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e2));
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), ot(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(e2, t2) {
          return this._map.fire(new Event(e2, { originalEvent: t2 }));
        }
      }
      function sm(e2, t2) {
        const i2 = {};
        for (let r2 = 0; r2 < e2.length; r2++)
          i2[e2[r2].identifier] = t2[r2];
        return i2;
      }
      class SingleTapRecognizer {
        constructor(e2) {
          this.reset(), this.numTouches = e2.numTouches;
        }
        reset() {
          this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
        }
        touchstart(e2, t2, i2) {
          (this.centroid || i2.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = e2.timeStamp), i2.length === this.numTouches && (this.centroid = function(e3) {
            const t3 = new d(0, 0);
            for (const i3 of e3)
              t3._add(i3);
            return t3.div(e3.length);
          }(t2), this.touches = sm(i2, t2)));
        }
        touchmove(e2, t2, i2) {
          if (this.aborted || !this.centroid)
            return;
          const r2 = sm(i2, t2);
          for (const e3 in this.touches) {
            const t3 = this.touches[e3], i3 = r2[e3];
            (!i3 || i3.dist(t3) > 30) && (this.aborted = true);
          }
        }
        touchend(e2, t2, i2) {
          if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
            const e3 = !this.aborted && this.centroid;
            if (this.reset(), e3)
              return e3;
          }
        }
      }
      class TapRecognizer {
        constructor(e2) {
          this.singleTap = new SingleTapRecognizer(e2), this.numTaps = e2.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
        }
        touchstart(e2, t2, i2) {
          this.singleTap.touchstart(e2, t2, i2);
        }
        touchmove(e2, t2, i2) {
          this.singleTap.touchmove(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          const r2 = this.singleTap.touchend(e2, t2, i2);
          if (r2) {
            const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(r2) < 30;
            if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = r2, this.count === this.numTaps)
              return this.reset(), r2;
          }
        }
      }
      class TapZoomHandler {
        constructor() {
          this._zoomIn = new TapRecognizer({ numTouches: 1, numTaps: 2 }), this._zoomOut = new TapRecognizer({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e2, t2, i2) {
          this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
        }
        touchmove(e2, t2, i2) {
          this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          const r2 = this._zoomIn.touchend(e2, t2, i2), n2 = this._zoomOut.touchend(e2, t2, i2);
          return r2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() + 1, around: t3.unproject(r2) }, { originalEvent: e2 }) }) : n2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() - 1, around: t3.unproject(n2) }, { originalEvent: e2 }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const am = { 0: 1, 2: 2 };
      class MouseHandler {
        constructor(e2) {
          this.reset(), this._clickTolerance = e2.clickTolerance || 1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
        }
        _correctButton(e2, t2) {
          return false;
        }
        _move(e2, t2) {
          return {};
        }
        mousedown(e2, t2) {
          if (this._lastPoint)
            return;
          const i2 = ut(e2);
          this._correctButton(e2, i2) && (this._lastPoint = t2, this._eventButton = i2);
        }
        mousemoveWindow(e2, t2) {
          const i2 = this._lastPoint;
          if (i2) {
            if (e2.preventDefault(), null != this._eventButton && function(e3, t3) {
              const i3 = am[t3];
              return void 0 === e3.buttons || (e3.buttons & i3) !== i3;
            }(e2, this._eventButton))
              this.reset();
            else if (this._moved || !(t2.dist(i2) < this._clickTolerance))
              return this._moved = true, this._lastPoint = t2, this._move(i2, t2);
          }
        }
        mouseupWindow(e2) {
          this._lastPoint && ut(e2) === this._eventButton && (this._moved && at(), this.reset());
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class MousePanHandler extends MouseHandler {
        mousedown(e2, t2) {
          super.mousedown(e2, t2), this._lastPoint && (this._active = true);
        }
        _correctButton(e2, t2) {
          return 0 === t2 && !e2.ctrlKey;
        }
        _move(e2, t2) {
          return { around: t2, panDelta: t2.sub(e2) };
        }
      }
      class MouseRotateHandler extends MouseHandler {
        _correctButton(e2, t2) {
          return 0 === t2 && e2.ctrlKey || 2 === t2;
        }
        _move(e2, t2) {
          const i2 = 0.8 * (t2.x - e2.x);
          if (i2)
            return this._active = true, { bearingDelta: i2 };
        }
        contextmenu(e2) {
          e2.preventDefault();
        }
      }
      class MousePitchHandler extends MouseHandler {
        _correctButton(e2, t2) {
          return 0 === t2 && e2.ctrlKey || 2 === t2;
        }
        _move(e2, t2) {
          const i2 = -0.5 * (t2.y - e2.y);
          if (i2)
            return this._active = true, { pitchDelta: i2 };
        }
        contextmenu(e2) {
          e2.preventDefault();
        }
      }
      class TouchPanHandler {
        constructor(e2, t2) {
          this._map = e2, this._el = e2.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = t2.clickTolerance || 1, this.reset(), O(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new d(0, 0);
        }
        touchstart(e2, t2, i2) {
          return this._calculateTransform(e2, t2, i2);
        }
        touchmove(e2, t2, i2) {
          if (this._active && !(i2.length < this._minTouches)) {
            if (this._map._cooperativeGestures && !this._map.isMoving()) {
              if (1 === i2.length && !J())
                return void this._showTouchPanBlockerAlert();
              "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            return e2.cancelable && e2.preventDefault(), this._calculateTransform(e2, t2, i2);
          }
        }
        touchend(e2, t2, i2) {
          this._calculateTransform(e2, t2, i2), this._active && i2.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(e2, t2, i2) {
          i2.length > 0 && (this._active = true);
          const r2 = sm(i2, t2), n2 = new d(0, 0), o2 = new d(0, 0);
          let s2 = 0;
          for (const e3 in r2) {
            const t3 = r2[e3], i3 = this._touches[e3];
            i3 && (n2._add(t3), o2._add(t3.sub(i3)), s2++, r2[e3] = t3);
          }
          if (this._touches = r2, s2 < this._minTouches || !o2.mag())
            return;
          const a2 = o2.div(s2);
          return this._sum._add(a2), this._sum.mag() < this._clickTolerance ? void 0 : { around: n2.div(s2), panDelta: a2 };
        }
        enable() {
          this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
        }
        disable() {
          this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        _addTouchPanBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = Qe("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showTouchPanBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
          }, 500);
        }
      }
      class TwoTouchHandler {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, this._firstTwoTouches = void 0;
        }
        _start(e2) {
        }
        _move(e2, t2, i2) {
          return {};
        }
        touchstart(e2, t2, i2) {
          this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
        }
        touchmove(e2, t2, i2) {
          const r2 = this._firstTwoTouches;
          if (!r2)
            return;
          e2.preventDefault();
          const [n2, o2] = r2, s2 = lm(i2, t2, n2), a2 = lm(i2, t2, o2);
          if (!s2 || !a2)
            return;
          const l2 = this._aroundCenter ? null : s2.add(a2).div(2);
          return this._move([s2, a2], l2, e2);
        }
        touchend(e2, t2, i2) {
          if (!this._firstTwoTouches)
            return;
          const [r2, n2] = this._firstTwoTouches, o2 = lm(i2, t2, r2), s2 = lm(i2, t2, n2);
          o2 && s2 || (this._active && at(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e2) {
          this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function lm(e2, t2, i2) {
        for (let r2 = 0; r2 < e2.length; r2++)
          if (e2[r2].identifier === i2)
            return t2[r2];
      }
      function cm(e2, t2) {
        return Math.log(e2 / t2) / Math.LN2;
      }
      class TouchZoomHandler extends TwoTouchHandler {
        reset() {
          super.reset(), this._distance = 0, this._startDistance = 0;
        }
        _start(e2) {
          this._startDistance = this._distance = e2[0].dist(e2[1]);
        }
        _move(e2, t2) {
          const i2 = this._distance;
          if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(cm(this._distance, this._startDistance)) < 0.1))
            return this._active = true, { zoomDelta: cm(this._distance, i2), pinchAround: t2 };
        }
      }
      function um(e2, t2) {
        return 180 * e2.angleWith(t2) / Math.PI;
      }
      class TouchRotateHandler extends TwoTouchHandler {
        reset() {
          super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
        }
        _start(e2) {
          this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
        }
        _move(e2, t2) {
          const i2 = this._vector;
          if (this._vector = e2[0].sub(e2[1]), i2 && (this._active || !this._isBelowThreshold(this._vector)))
            return this._active = true, { bearingDelta: um(this._vector, i2), pinchAround: t2 };
        }
        _isBelowThreshold(e2) {
          this._minDiameter = Math.min(this._minDiameter, e2.mag());
          const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = this._startVector;
          if (!i2)
            return false;
          const r2 = um(e2, i2);
          return Math.abs(r2) < t2;
        }
      }
      function hm(e2) {
        return Math.abs(e2.y) > Math.abs(e2.x);
      }
      class TouchPitchHandler extends TwoTouchHandler {
        constructor(e2) {
          super(), this._map = e2;
        }
        reset() {
          super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
        }
        _start(e2) {
          this._lastPoints = e2, hm(e2[0].sub(e2[1])) && (this._valid = false);
        }
        _move(e2, t2, i2) {
          const r2 = this._lastPoints;
          if (!r2)
            return;
          const n2 = e2[0].sub(r2[0]), o2 = e2[1].sub(r2[1]);
          return this._map._cooperativeGestures && !J() && i2.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n2, o2, i2.timeStamp), !this._valid) ? void 0 : (this._lastPoints = e2, this._active = true, { pitchDelta: (n2.y + o2.y) / 2 * -0.5 });
        }
        gestureBeginsVertically(e2, t2, i2) {
          if (void 0 !== this._valid)
            return this._valid;
          const r2 = e2.mag() >= 2, n2 = t2.mag() >= 2;
          if (!r2 && !n2)
            return;
          if (!r2 || !n2)
            return null == this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
          const o2 = e2.y > 0 == t2.y > 0;
          return hm(e2) && hm(t2) && o2;
        }
      }
      const pm = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class KeyboardHandler {
        constructor() {
          const e2 = pm;
          this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        keydown(e2) {
          if (e2.altKey || e2.ctrlKey || e2.metaKey)
            return;
          let t2 = 0, i2 = 0, r2 = 0, n2 = 0, o2 = 0;
          switch (e2.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              t2 = 1;
              break;
            case 189:
            case 109:
            case 173:
              t2 = -1;
              break;
            case 37:
              e2.shiftKey ? i2 = -1 : (e2.preventDefault(), n2 = -1);
              break;
            case 39:
              e2.shiftKey ? i2 = 1 : (e2.preventDefault(), n2 = 1);
              break;
            case 38:
              e2.shiftKey ? r2 = 1 : (e2.preventDefault(), o2 = -1);
              break;
            case 40:
              e2.shiftKey ? r2 = -1 : (e2.preventDefault(), o2 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (i2 = 0, r2 = 0), { cameraAnimation: (s2) => {
            const a2 = s2.getZoom();
            s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: dm, zoom: t2 ? Math.round(a2) + t2 * (e2.shiftKey ? 2 : 1) : a2, bearing: s2.getBearing() + i2 * this._bearingStep, pitch: s2.getPitch() + r2 * this._pitchStep, offset: [-n2 * this._panStep, -o2 * this._panStep], center: s2.getCenter() }, { originalEvent: e2 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function dm(e2) {
        return e2 * (2 - e2);
      }
      const fm = 4.000244140625;
      class ScrollZoomHandler {
        constructor(e2, t2) {
          this._map = e2, this._el = e2.getCanvasContainer(), this._handler = t2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, O(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
        }
        setZoomRate(e2) {
          this._defaultZoomRate = e2;
        }
        setWheelZoomRate(e2) {
          this._wheelZoomRate = e2;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return this._active || void 0 !== this._finishTimeout;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e2) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
        }
        disable() {
          this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
        }
        wheel(t2) {
          if (!this.isEnabled())
            return;
          if (this._map._cooperativeGestures) {
            if (!(t2.ctrlKey || t2.metaKey || this.isZooming() || J()))
              return void this._showBlockerAlert();
            "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
          }
          let i2 = t2.deltaMode === e.WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
          const r2 = Je.now(), n2 = r2 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = r2, 0 !== i2 && i2 % fm == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : n2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(n2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), t2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= i2, this._active || this._start(t2)), t2.preventDefault();
        }
        _onTimeout(e2) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e2);
        }
        _start(e2) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const t2 = lt(this._el, e2);
          this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t2, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId)
            return;
          if (this._frameId = null, !this.isActive())
            return;
          const e2 = this._map.transform;
          "wheel" === this._type && e2.projection.wrap && (e2._center.lng >= 180 || e2._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
          const t2 = () => e2._terrainEnabled() && this._aroundCoord ? e2.computeZoomRelativeTo(this._aroundCoord) : e2.zoom;
          if (0 !== this._delta) {
            const i3 = "wheel" === this._type && Math.abs(this._delta) > fm ? this._wheelZoomRate : this._defaultZoomRate;
            let r3 = 2 / (1 + Math.exp(-Math.abs(this._delta * i3)));
            this._delta < 0 && 0 !== r3 && (r3 = 1 / r3);
            const n3 = t2(), o3 = Math.pow(2, n3), s3 = "number" == typeof this._targetZoom ? e2.zoomScale(this._targetZoom) : o3;
            this._targetZoom = Math.min(e2.maxZoom, Math.max(e2.minZoom, e2.scaleZoom(s3 * r3))), "wheel" === this._type && (this._startZoom = n3, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const i2 = "number" == typeof this._targetZoom ? this._targetZoom : t2(), r2 = this._startZoom, n2 = this._easing;
          let o2, s2 = false;
          if ("wheel" === this._type && r2 && n2) {
            const e3 = Math.min((Je.now() - this._lastWheelEventTime) / 200, 1);
            o2 = Ii(r2, i2, n2(e3)), e3 < 1 ? this._frameId || (this._frameId = true) : s2 = true;
          } else
            o2 = i2, s2 = true;
          return this._active = true, s2 && (this._active = false, this._finishTimeout = setTimeout(() => {
            this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: true, needsRenderFrame: !s2, zoomDelta: o2 - t2(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(e2) {
          let t2 = S;
          if (this._prevEase) {
            const e3 = this._prevEase, i2 = (Je.now() - e3.start) / e3.duration, r2 = e3.easing(i2 + 0.01) - e3.easing(i2), n2 = 0.27 / Math.sqrt(r2 * r2 + 1e-4) * 0.01;
            t2 = E(n2, Math.sqrt(0.0729 - n2 * n2), 0.25, 1);
          }
          return this._prevEase = { start: Je.now(), duration: e2, easing: t2 }, t2;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        _addScrollZoomBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = Qe("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
          }, 200);
        }
      }
      class DoubleClickZoomHandler {
        constructor(e2, t2) {
          this._clickZoom = e2, this._tapZoom = t2;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class ClickZoomHandler {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        blur() {
          this.reset();
        }
        dblclick(e2, t2) {
          return e2.preventDefault(), { cameraAnimation: (i2) => {
            i2.easeTo({ duration: 300, zoom: i2.getZoom() + (e2.shiftKey ? -1 : 1), around: i2.unproject(t2) }, { originalEvent: e2 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class TapDragZoomHandler {
        constructor() {
          this._tap = new TapRecognizer({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
        }
        touchstart(e2, t2, i2) {
          this._swipePoint || (this._tapTime && e2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = t2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(e2, t2, i2));
        }
        touchmove(e2, t2, i2) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i2[0].identifier !== this._swipeTouch)
                return;
              const r2 = t2[0], n2 = r2.y - this._swipePoint.y;
              return this._swipePoint = r2, e2.preventDefault(), this._active = true, { zoomDelta: n2 / 128 };
            }
          } else
            this._tap.touchmove(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(e2, t2, i2) && (this._tapTime = e2.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class DragPanHandler {
        constructor(e2, t2, i2) {
          this._el = e2, this._mousePan = t2, this._touchPan = i2;
        }
        enable(e2) {
          this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class DragRotateHandler {
        constructor(e2, t2, i2) {
          this._pitchWithRotate = e2.pitchWithRotate, this._mouseRotate = t2, this._mousePitch = i2;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class TouchZoomRotateHandler {
        constructor(e2, t2, i2, r2) {
          this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = r2, this._rotationDisabled = false, this._enabled = true;
        }
        enable(e2) {
          this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const mm = (e2) => e2.zoom || e2.drag || e2.pitch || e2.rotate;
      class RenderFrameEvent extends Event {
      }
      class TrackingEllipsoid {
        constructor() {
          this.constants = [1, 1, 0.01], this.radius = 0;
        }
        setup(e2, t2) {
          const i2 = aa([], t2, e2);
          this.radius = qs(i2[2] < 0 ? ca([], i2, this.constants) : [i2[0], i2[1], 0]);
        }
        projectRay(e2) {
          ca(e2, e2, this.constants), ea(e2, e2), la(e2, e2, this.constants);
          const t2 = Ys([], e2, this.radius);
          if (t2[2] > 0) {
            const e3 = Ys([], [0, 0, 1], ta(t2, [0, 0, 1])), i2 = Ys([], ea([], [t2[0], t2[1], 0]), this.radius), r2 = $s([], t2, Ys([], aa([], $s([], i2, e3), t2), 2));
            t2[0] = r2[0], t2[1] = r2[1];
          }
          return t2;
        }
      }
      function _m(e2) {
        return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta;
      }
      class HandlerManager {
        constructor(t2, i2) {
          this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new HandlerInertia(t2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new TrackingEllipsoid(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), O(["handleEvent", "handleWindowEvent"], this);
          const r2 = this._el;
          this._listeners = [[r2, "touchstart", { passive: true }], [r2, "touchmove", { passive: false }], [r2, "touchend", void 0], [r2, "touchcancel", void 0], [r2, "mousedown", void 0], [r2, "mousemove", void 0], [r2, "mouseup", void 0], [e.document, "mousemove", { capture: true }], [e.document, "mouseup", void 0], [r2, "mouseover", void 0], [r2, "mouseout", void 0], [r2, "dblclick", void 0], [r2, "click", void 0], [r2, "keydown", { capture: false }], [r2, "keyup", void 0], [r2, "wheel", { passive: false }], [r2, "contextmenu", void 0], [e, "blur", void 0]];
          for (const [t3, i3, r3] of this._listeners)
            t3.addEventListener(i3, t3 === e.document ? this.handleWindowEvent : this.handleEvent, r3);
        }
        destroy() {
          for (const [t2, i2, r2] of this._listeners)
            t2.removeEventListener(i2, t2 === e.document ? this.handleWindowEvent : this.handleEvent, r2);
        }
        _addDefaultHandlers(e2) {
          const t2 = this._map, i2 = t2.getCanvasContainer();
          this._add("mapEvent", new MapEventHandler(t2, e2));
          const r2 = t2.boxZoom = new BoxZoomHandler(t2, e2);
          this._add("boxZoom", r2);
          const n2 = new TapZoomHandler(), o2 = new ClickZoomHandler();
          t2.doubleClickZoom = new DoubleClickZoomHandler(o2, n2), this._add("tapZoom", n2), this._add("clickZoom", o2);
          const s2 = new TapDragZoomHandler();
          this._add("tapDragZoom", s2);
          const a2 = t2.touchPitch = new TouchPitchHandler(t2);
          this._add("touchPitch", a2);
          const l2 = new MouseRotateHandler(e2), c2 = new MousePitchHandler(e2);
          t2.dragRotate = new DragRotateHandler(e2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
          const u2 = new MousePanHandler(e2), h2 = new TouchPanHandler(t2, e2);
          t2.dragPan = new DragPanHandler(i2, u2, h2), this._add("mousePan", u2), this._add("touchPan", h2, ["touchZoom", "touchRotate"]);
          const p2 = new TouchRotateHandler(), d2 = new TouchZoomHandler();
          t2.touchZoomRotate = new TouchZoomRotateHandler(i2, d2, p2, s2), this._add("touchRotate", p2, ["touchPan", "touchZoom"]), this._add("touchZoom", d2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new BlockableMapEventHandler(t2));
          const f2 = t2.scrollZoom = new ScrollZoomHandler(t2, this);
          this._add("scrollZoom", f2, ["mousePan"]);
          const m2 = t2.keyboard = new KeyboardHandler();
          this._add("keyboard", m2);
          for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
            e2.interactive && e2[i3] && t2[i3].enable(e2[i3]);
        }
        _add(e2, t2, i2) {
          this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
        }
        stop(e2) {
          if (!this._updatingCamera) {
            for (const { handler: e3 } of this._handlers)
              e3.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: e2 } of this._handlers)
            if (e2.isActive())
              return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!mm(this._eventsInProgress) || this.isZooming();
        }
        _isDragging() {
          return !!this._eventsInProgress.drag;
        }
        _blockedByActive(e2, t2, i2) {
          for (const r2 in e2)
            if (r2 !== i2 && (!t2 || t2.indexOf(r2) < 0))
              return true;
          return false;
        }
        handleWindowEvent(e2) {
          this.handleEvent(e2, `${e2.type}Window`);
        }
        _getMapTouches(e2) {
          const t2 = [];
          for (const i2 of e2)
            this._el.contains(i2.target) && t2.push(i2);
          return t2;
        }
        handleEvent(e2, t2) {
          this._updatingCamera = true;
          const i2 = "renderFrame" === e2.type, r2 = i2 ? void 0 : e2, n2 = { needsRenderFrame: false }, o2 = {}, s2 = {}, a2 = e2.touches ? this._getMapTouches(e2.touches) : void 0, l2 = a2 ? ct(this._el, a2) : i2 ? void 0 : lt(this._el, e2);
          for (const { handlerName: i3, handler: c3, allowed: u3 } of this._handlers) {
            if (!c3.isEnabled())
              continue;
            let h2;
            this._blockedByActive(s2, u3, i3) ? c3.reset() : c3[t2 || e2.type] && (h2 = c3[t2 || e2.type](e2, l2, a2), this.mergeHandlerResult(n2, o2, h2, i3, r2), h2 && h2.needsRenderFrame && this._triggerRenderFrame()), (h2 || c3.isActive()) && (s2[i3] = c3);
          }
          const c2 = {};
          for (const e3 in this._previousActiveHandlers)
            s2[e3] || (c2[e3] = r2);
          this._previousActiveHandlers = s2, (Object.keys(c2).length || _m(n2)) && (this._changes.push([n2, o2, c2]), this._triggerRenderFrame()), (Object.keys(s2).length || _m(n2)) && this._map._stop(true), this._updatingCamera = false;
          const { cameraAnimation: u2 } = n2;
          u2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u2(this._map));
        }
        mergeHandlerResult(e2, t2, i2, r2, n2) {
          if (!i2)
            return;
          P(e2, i2);
          const o2 = { handlerName: r2, originalEvent: i2.originalEvent || n2 };
          void 0 !== i2.zoomDelta && (t2.zoom = o2), void 0 !== i2.panDelta && (t2.drag = o2), void 0 !== i2.pitchDelta && (t2.pitch = o2), void 0 !== i2.bearingDelta && (t2.rotate = o2);
        }
        _applyChanges() {
          const e2 = {}, t2 = {}, i2 = {};
          for (const [r2, n2, o2] of this._changes)
            r2.panDelta && (e2.panDelta = (e2.panDelta || new d(0, 0))._add(r2.panDelta)), r2.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + r2.zoomDelta), r2.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + r2.bearingDelta), r2.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + r2.pitchDelta), void 0 !== r2.around && (e2.around = r2.around), void 0 !== r2.aroundCoord && (e2.aroundCoord = r2.aroundCoord), void 0 !== r2.pinchAround && (e2.pinchAround = r2.pinchAround), r2.noInertia && (e2.noInertia = r2.noInertia), P(t2, n2), P(i2, o2);
          this._updateMapTransform(e2, t2, i2), this._changes = [];
        }
        _updateMapTransform(e2, t2, i2) {
          const r2 = this._map, n2 = r2.transform, o2 = (e3) => [e3.x, e3.y, e3.z];
          if (((e3) => {
            const t3 = this._eventsInProgress.drag;
            return t3 && !this._handlersById[t3.handlerName].isActive();
          })() && !_m(e2)) {
            const e3 = n2.zoom;
            n2.cameraElevationReference = "sea", n2.recenterOnTerrain(), n2.cameraElevationReference = "ground", e3 !== n2.zoom && this._map._update(true);
          }
          if (n2._isCameraConstrained && r2._stop(true), !_m(e2))
            return void this._fireEvents(t2, i2, true);
          let { panDelta: s2, zoomDelta: a2, bearingDelta: l2, pitchDelta: c2, around: u2, aroundCoord: h2, pinchAround: p2 } = e2;
          n2._isCameraConstrained && (a2 > 0 && (a2 = 0), n2._isCameraConstrained = false), void 0 !== p2 && (u2 = p2), ((e3) => t2.drag && !this._eventsInProgress.drag)() && u2 && (this._dragOrigin = o2(n2.pointCoordinate3D(u2)), this._trackingEllipsoid.setup(n2._camera.position, this._dragOrigin)), n2.cameraElevationReference = "sea", r2._stop(true), u2 = u2 || r2.transform.centerPoint, l2 && (n2.bearing += l2), c2 && (n2.pitch += c2), n2._updateCameraState();
          const d2 = [0, 0, 0];
          if (s2)
            if ("mercator" === n2.projection.name) {
              const e3 = this._trackingEllipsoid.projectRay(n2.screenPointToMercatorRay(u2).dir), t3 = this._trackingEllipsoid.projectRay(n2.screenPointToMercatorRay(u2.sub(s2)).dir);
              d2[0] = t3[0] - e3[0], d2[1] = t3[1] - e3[1];
            } else {
              const e3 = n2.pointCoordinate(u2);
              if ("globe" === n2.projection.name) {
                s2 = s2.rotate(-n2.angle);
                const t3 = n2._pixelsPerMercatorPixel / n2.worldSize;
                d2[0] = -s2.x * Zo(No(e3.y)) * t3, d2[1] = -s2.y * Zo(n2.center.lat) * t3;
              } else {
                const t3 = n2.pointCoordinate(u2.sub(s2));
                e3 && t3 && (d2[0] = t3.x - e3.x, d2[1] = t3.y - e3.y);
              }
            }
          const f2 = n2.zoom, m2 = [0, 0, 0];
          if (a2) {
            const e3 = o2(h2 || n2.pointCoordinate3D(u2)), t3 = { dir: ea([], aa([], e3, n2._camera.position)) };
            if (t3.dir[2] < 0) {
              const i3 = n2.zoomDeltaToMovement(e3, a2);
              Ys(m2, t3.dir, i3);
            }
          }
          const _2 = $s(d2, d2, m2);
          n2._translateCameraConstrained(_2), a2 && Math.abs(n2.zoom - f2) > 1e-4 && n2.recenterOnTerrain(), n2.cameraElevationReference = "ground", this._map._update(), e2.noInertia || this._inertia.record(e2), this._fireEvents(t2, i2, true);
        }
        _fireEvents(e2, t2, i2) {
          const r2 = mm(this._eventsInProgress), n2 = mm(e2), o2 = {};
          for (const t3 in e2) {
            const { originalEvent: i3 } = e2[t3];
            this._eventsInProgress[t3] || (o2[`${t3}start`] = i3), this._eventsInProgress[t3] = e2[t3];
          }
          !r2 && n2 && this._fireEvent("movestart", n2.originalEvent);
          for (const e3 in o2)
            this._fireEvent(e3, o2[e3]);
          n2 && this._fireEvent("move", n2.originalEvent);
          for (const t3 in e2) {
            const { originalEvent: i3 } = e2[t3];
            this._fireEvent(t3, i3);
          }
          const s2 = {};
          let a2;
          for (const e3 in this._eventsInProgress) {
            const { handlerName: i3, originalEvent: r3 } = this._eventsInProgress[e3];
            this._handlersById[i3].isActive() || (delete this._eventsInProgress[e3], a2 = t2[i3] || r3, s2[`${e3}end`] = a2);
          }
          for (const e3 in s2)
            this._fireEvent(e3, s2[e3]);
          const l2 = mm(this._eventsInProgress);
          if (i2 && (r2 || n2) && !l2) {
            this._updatingCamera = true;
            const e3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), t3 = (e4) => 0 !== e4 && -this._bearingSnap < e4 && e4 < this._bearingSnap;
            e3 ? (t3(e3.bearing || this._map.getBearing()) && (e3.bearing = 0), this._map.easeTo(e3, { originalEvent: a2 })) : (this._map.fire(new Event("moveend", { originalEvent: a2 })), t3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
          }
        }
        _fireEvent(e2, t2) {
          this._map.fire(new Event(e2, t2 ? { originalEvent: t2 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
            this._frameId = void 0, this.handleEvent(new RenderFrameEvent("renderFrame", { timeStamp: e2 })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          void 0 === this._frameId && (this._frameId = this._requestFrame());
        }
      }
      const gm = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
      class Camera extends Evented {
        constructor(e2, t2) {
          super(), this._moving = false, this._zooming = false, this.transform = e2, this._bearingSnap = t2.bearingSnap, O(["_renderFrameCallback"], this);
        }
        getCenter() {
          return new LngLat(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e2, t2) {
          return this.jumpTo({ center: e2 }, t2);
        }
        panBy(e2, t2, i2) {
          return e2 = d.convert(e2).mult(-1), this.panTo(this.transform.center, P({ offset: e2 }, t2), i2);
        }
        panTo(e2, t2, i2) {
          return this.easeTo(P({ center: e2 }, t2), i2);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e2, t2) {
          return this.jumpTo({ zoom: e2 }, t2), this;
        }
        zoomTo(e2, t2, i2) {
          return this.easeTo(P({ zoom: e2 }, t2), i2);
        }
        zoomIn(e2, t2) {
          return this.zoomTo(this.getZoom() + 1, e2, t2), this;
        }
        zoomOut(e2, t2) {
          return this.zoomTo(this.getZoom() - 1, e2, t2), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e2, t2) {
          return this.jumpTo({ bearing: e2 }, t2), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e2, t2) {
          return this.jumpTo({ padding: e2 }, t2), this;
        }
        rotateTo(e2, t2, i2) {
          return this.easeTo(P({ bearing: e2 }, t2), i2);
        }
        resetNorth(e2, t2) {
          return this.rotateTo(0, P({ duration: 1e3 }, e2), t2), this;
        }
        resetNorthPitch(e2, t2) {
          return this.easeTo(P({ bearing: 0, pitch: 0, duration: 1e3 }, e2), t2), this;
        }
        snapToNorth(e2, t2) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e2, t2) {
          return this.jumpTo({ pitch: e2 }, t2), this;
        }
        cameraForBounds(e2, t2) {
          e2 = LngLatBounds.convert(e2);
          const i2 = t2 && t2.bearing || 0, r2 = t2 && t2.pitch || 0, n2 = e2.getNorthWest(), o2 = e2.getSouthEast();
          return this._cameraForBounds(this.transform, n2, o2, i2, r2, t2);
        }
        _extendCameraOptions(e2) {
          const t2 = { top: 0, bottom: 0, right: 0, left: 0 };
          if ("number" == typeof (e2 = P({ padding: t2, offset: [0, 0], maxZoom: this.transform.maxZoom }, e2)).padding) {
            const t3 = e2.padding;
            e2.padding = { top: t3, bottom: t3, right: t3, left: t3 };
          }
          return e2.padding = P(t2, e2.padding), e2;
        }
        _minimumAABBFrustumDistance(e2, t2) {
          const i2 = t2.max[0] - t2.min[0], r2 = t2.max[1] - t2.min[1];
          return i2 / r2 > e2.aspect ? i2 / (2 * Math.tan(0.5 * e2.fovX) * e2.aspect) : r2 / (2 * Math.tan(0.5 * e2.fovY) * e2.aspect);
        }
        _cameraForBoundsOnGlobe(e2, t2, i2, r2, n2, o2) {
          const s2 = e2.clone(), a2 = this._extendCameraOptions(o2);
          s2.bearing = r2, s2.pitch = n2;
          const l2 = LngLat.convert(t2), c2 = LngLat.convert(i2), u2 = 0.5 * (l2.lat + c2.lat), h2 = 0.5 * (l2.lng + c2.lng), p2 = Eu(u2, h2), d2 = ea([], p2), f2 = ea([], ia([], d2, [0, 1, 0])), m2 = ia([], f2, d2), _2 = [f2[0], f2[1], f2[2], 0, m2[0], m2[1], m2[2], 0, d2[0], d2[1], d2[2], 0, 0, 0, 0, 1], g2 = [p2, Eu(l2.lat, l2.lng), Eu(c2.lat, l2.lng), Eu(c2.lat, c2.lng), Eu(l2.lat, c2.lng), Eu(u2, l2.lng), Eu(u2, c2.lng), Eu(l2.lat, h2), Eu(c2.lat, h2)];
          let y2 = Aabb.fromPoints(g2.map((e3) => [ta(f2, e3), ta(m2, e3), ta(d2, e3)]));
          const v2 = ra([], y2.center, _2);
          var b2, w2, T2, E2;
          0 == (w2 = (b2 = v2)[0]) * w2 + (T2 = b2[1]) * T2 + (E2 = b2[2]) * E2 && function(e3, t3, i3, r3) {
            e3[0] = 0, e3[1] = 0, e3[2] = 1;
          }(v2), ea(v2, v2), Ys(v2, v2, au), s2.center = function([e3, t3, i3]) {
            const r3 = Math.hypot(e3, t3, i3), n3 = Math.atan2(e3, i3), o3 = 0.5 * Math.PI - Math.acos(-t3 / r3);
            return new LngLat(x(n3), x(o3));
          }(v2);
          const S2 = s2.getWorldToCameraMatrix(), A2 = Ms(new Float64Array(16), S2);
          y2 = Aabb.applyTransform(y2, Ds([], S2, _2)), ra(v2, v2, S2);
          const C2 = 0.5 * (y2.max[2] - y2.min[2]), I2 = this._minimumAABBFrustumDistance(s2, y2), M2 = Ys([], [0, 0, 1], C2), D2 = $s(M2, v2, M2), P2 = I2 + (0 === s2.pitch ? 0 : Qs(v2, D2)), z2 = s2.globeCenterInViewSpace, L2 = aa([], v2, [z2[0], z2[1], z2[2]]);
          ea(L2, L2), Ys(L2, L2, P2);
          const k2 = $s([], v2, L2);
          ra(k2, k2, A2);
          const B2 = Bo / au, R2 = Vo(qs(k2) * B2 - Bo, 0), F2 = Math.min(s2.zoomFromMercatorZAdjusted(R2), a2.maxZoom);
          return F2 > 5.5 ? (s2.setProjection({ name: "mercator" }), s2.zoom = F2, this._cameraForBounds(s2, t2, i2, r2, n2, o2)) : { center: s2.center, zoom: F2, bearing: r2, pitch: n2 };
        }
        queryTerrainElevation(e2, t2) {
          const i2 = this.transform.elevation;
          return i2 ? (t2 = P({}, { exaggerated: true }, t2), i2.getAtPoint(MercatorCoordinate.fromLngLat(e2), null, t2.exaggerated)) : null;
        }
        _cameraForBounds(e2, t2, i2, r2, n2, o2) {
          if ("globe" === e2.projection.name)
            return this._cameraForBoundsOnGlobe(e2, t2, i2, r2, n2, o2);
          const s2 = e2.clone(), a2 = this._extendCameraOptions(o2), l2 = s2.padding;
          s2.bearing = r2, s2.pitch = n2;
          const c2 = LngLat.convert(t2), u2 = LngLat.convert(i2), h2 = new LngLat(c2.lng, u2.lat), p2 = new LngLat(u2.lng, c2.lat), f2 = s2.project(c2), m2 = s2.project(u2), _2 = this.queryTerrainElevation(c2), g2 = this.queryTerrainElevation(u2), x2 = this.queryTerrainElevation(h2), v2 = this.queryTerrainElevation(p2), b2 = [[f2.x, f2.y, Math.min(_2 || 0, g2 || 0, x2 || 0, v2 || 0)], [m2.x, m2.y, Math.max(_2 || 0, g2 || 0, x2 || 0, v2 || 0)]];
          let w2 = Aabb.fromPoints(b2);
          const T2 = s2.getWorldToCameraMatrix(), E2 = Ms(new Float64Array(16), T2);
          w2 = Aabb.applyTransform(w2, T2);
          const S2 = aa([], w2.max, w2.min), A2 = l2.left || 0, C2 = l2.right || 0, I2 = l2.bottom || 0, M2 = l2.top || 0, { left: D2, right: P2, top: z2, bottom: L2 } = a2.padding, k2 = 0.5 * (A2 + C2), B2 = 0.5 * (M2 + I2), R2 = Math.min(s2.scaleZoom(s2.scale * Math.min((s2.width - (A2 + C2 + D2 + P2)) / S2[0], (s2.height - (I2 + M2 + L2 + z2)) / S2[1])), a2.maxZoom), F2 = s2.scale / s2.zoomScale(R2);
          w2 = new Aabb([w2.min[0] - (D2 + k2) * F2, w2.min[1] - (L2 + B2) * F2, w2.min[2]], [w2.max[0] + (P2 + k2) * F2, w2.max[1] + (z2 + B2) * F2, w2.max[2]]);
          const O2 = 0.5 * S2[2], U2 = this._minimumAABBFrustumDistance(s2, w2), V2 = [0, 0, 1, 0];
          da(V2, V2, T2), pa(V2, V2);
          const j2 = Ys([], V2, U2 + O2), N2 = $s([], w2.center, j2), G2 = ("number" == typeof a2.offset.x && "number" == typeof a2.offset.y ? new d(a2.offset.x, a2.offset.y) : d.convert(a2.offset)).rotate(-y(r2));
          w2.center[0] -= G2.x * F2, w2.center[1] += G2.y * F2, ra(w2.center, w2.center, E2), ra(N2, N2, E2);
          const q2 = [w2.center[0], w2.center[1], N2[2] * s2.pixelsPerMeter];
          Ys(q2, q2, 1 / s2.worldSize);
          const Z2 = jo(q2[0]), $2 = No(q2[1]), W2 = Math.min(s2._zoomFromMercatorZ(q2[2]), a2.maxZoom), H2 = new LngLat(Z2, $2);
          return s2.mercatorFromTransition && W2 < 5.5 ? (s2.setProjection({ name: "globe" }), s2.zoom = W2, this._cameraForBounds(s2, t2, i2, r2, n2, o2)) : { center: H2, zoom: W2, bearing: r2, pitch: n2 };
        }
        fitBounds(e2, t2, i2) {
          const r2 = this.cameraForBounds(e2, t2);
          return this._fitInternal(r2, t2, i2);
        }
        fitScreenCoordinates(e2, t2, i2, r2, n2) {
          const o2 = d.convert(e2), s2 = d.convert(t2), a2 = new d(Math.min(o2.x, s2.x), Math.min(o2.y, s2.y)), l2 = new d(Math.max(o2.x, s2.x), Math.max(o2.y, s2.y));
          if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(o2, s2))
            return this;
          const c2 = this.transform.pointLocation3D(a2), u2 = this.transform.pointLocation3D(l2), h2 = this.transform.pointLocation3D(new d(a2.x, l2.y)), p2 = this.transform.pointLocation3D(new d(l2.x, a2.y)), f2 = [Math.min(c2.lng, u2.lng, h2.lng, p2.lng), Math.min(c2.lat, u2.lat, h2.lat, p2.lat)], m2 = [Math.max(c2.lng, u2.lng, h2.lng, p2.lng), Math.max(c2.lat, u2.lat, h2.lat, p2.lat)], _2 = r2 && r2.pitch ? r2.pitch : this.getPitch(), g2 = this._cameraForBounds(this.transform, f2, m2, i2, _2, r2);
          return this._fitInternal(g2, r2, n2);
        }
        _fitInternal(e2, t2, i2) {
          return e2 ? (delete (t2 = P(e2, t2)).padding, t2.linear ? this.easeTo(t2, i2) : this.flyTo(t2, i2)) : this;
        }
        jumpTo(e2, t2) {
          this.stop();
          const i2 = e2.preloadOnly ? this.transform.clone() : this.transform;
          let r2 = false, n2 = false, o2 = false;
          return "zoom" in e2 && i2.zoom !== +e2.zoom && (r2 = true, i2.zoom = +e2.zoom), void 0 !== e2.center && (i2.center = LngLat.convert(e2.center)), "bearing" in e2 && i2.bearing !== +e2.bearing && (n2 = true, i2.bearing = +e2.bearing), "pitch" in e2 && i2.pitch !== +e2.pitch && (o2 = true, i2.pitch = +e2.pitch), null == e2.padding || i2.isPaddingEqual(e2.padding) || (i2.padding = e2.padding), e2.preloadOnly ? (this._preloadTiles(i2), this) : (this.fire(new Event("movestart", t2)).fire(new Event("move", t2)), r2 && this.fire(new Event("zoomstart", t2)).fire(new Event("zoom", t2)).fire(new Event("zoomend", t2)), n2 && this.fire(new Event("rotatestart", t2)).fire(new Event("rotate", t2)).fire(new Event("rotateend", t2)), o2 && this.fire(new Event("pitchstart", t2)).fire(new Event("pitch", t2)).fire(new Event("pitchend", t2)), this.fire(new Event("moveend", t2)));
        }
        getFreeCameraOptions() {
          return this.transform.projection.supportsFreeCamera || Z(gm), this.transform.getFreeCameraOptions();
        }
        setFreeCameraOptions(e2, t2) {
          const i2 = this.transform;
          if (!i2.projection.supportsFreeCamera)
            return Z(gm), this;
          this.stop();
          const r2 = i2.zoom, n2 = i2.pitch, o2 = i2.bearing;
          i2.setFreeCameraOptions(e2);
          const s2 = r2 !== i2.zoom, a2 = n2 !== i2.pitch, l2 = o2 !== i2.bearing;
          return this.fire(new Event("movestart", t2)).fire(new Event("move", t2)), s2 && this.fire(new Event("zoomstart", t2)).fire(new Event("zoom", t2)).fire(new Event("zoomend", t2)), l2 && this.fire(new Event("rotatestart", t2)).fire(new Event("rotate", t2)).fire(new Event("rotateend", t2)), a2 && this.fire(new Event("pitchstart", t2)).fire(new Event("pitch", t2)).fire(new Event("pitchend", t2)), this.fire(new Event("moveend", t2)), this;
        }
        easeTo(e2, t2) {
          this._stop(false, e2.easeId), (false === (e2 = P({ offset: [0, 0], duration: 500, easing: S }, e2)).animate || !e2.essential && Je.prefersReducedMotion) && (e2.duration = 0);
          const i2 = this.transform, r2 = this.getZoom(), n2 = this.getBearing(), o2 = this.getPitch(), s2 = this.getPadding(), a2 = "zoom" in e2 ? +e2.zoom : r2, l2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, n2) : n2, c2 = "pitch" in e2 ? +e2.pitch : o2, u2 = "padding" in e2 ? e2.padding : i2.padding, h2 = d.convert(e2.offset);
          let p2, f2, m2;
          if ("globe" === i2.projection.name) {
            const t3 = MercatorCoordinate.fromLngLat(i2.center), r3 = h2.rotate(-i2.angle);
            t3.x += r3.x / i2.worldSize, t3.y += r3.y / i2.worldSize;
            const n3 = t3.toLngLat(), o3 = LngLat.convert(e2.center || n3);
            this._normalizeCenter(o3), p2 = i2.centerPoint.add(r3), f2 = new d(t3.x, t3.y).mult(i2.worldSize), m2 = new d(Oo(o3.lng), Uo(o3.lat)).mult(i2.worldSize).sub(f2);
          } else {
            p2 = i2.centerPoint.add(h2);
            const t3 = i2.pointLocation(p2), r3 = LngLat.convert(e2.center || t3);
            this._normalizeCenter(r3), f2 = i2.project(t3), m2 = i2.project(r3).sub(f2);
          }
          const _2 = i2.zoomScale(a2 - r2);
          let g2, y2;
          e2.around && (g2 = LngLat.convert(e2.around), y2 = i2.locationPoint(g2));
          const x2 = this._zooming || a2 !== r2, v2 = this._rotating || n2 !== l2, b2 = this._pitching || c2 !== o2, w2 = !i2.isPaddingEqual(u2), T2 = (i3) => (d2) => {
            if (x2 && (i3.zoom = Ii(r2, a2, d2)), v2 && (i3.bearing = Ii(n2, l2, d2)), b2 && (i3.pitch = Ii(o2, c2, d2)), w2 && (i3.interpolatePadding(s2, u2, d2), p2 = i3.centerPoint.add(h2)), g2)
              i3.setLocationAtPoint(g2, y2);
            else {
              const e3 = i3.zoomScale(i3.zoom - r2), t3 = a2 > r2 ? Math.min(2, _2) : Math.max(0.5, _2), n3 = Math.pow(t3, 1 - d2), o3 = i3.unproject(f2.add(m2.mult(d2 * n3)).mult(e3));
              i3.setLocationAtPoint(i3.renderWorldCopies ? o3.wrap() : o3, p2);
            }
            return e2.preloadOnly || this._fireMoveEvents(t2), i3;
          };
          if (e2.preloadOnly) {
            const t3 = this._emulate(T2, e2.duration, i2);
            return this._preloadTiles(t3), this;
          }
          const E2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = x2, this._rotating = v2, this._pitching = b2, this._padding = w2, this._easeId = e2.easeId, this._prepareEase(t2, e2.noMoveStart, E2), this._ease(T2(i2), (e3) => {
            i2.recenterOnTerrain(), this._afterEase(t2, e3);
          }, e2), this;
        }
        _prepareEase(e2, t2, i2 = {}) {
          this._moving = true, this.transform.cameraElevationReference = "sea", t2 || i2.moving || this.fire(new Event("movestart", e2)), this._zooming && !i2.zooming && this.fire(new Event("zoomstart", e2)), this._rotating && !i2.rotating && this.fire(new Event("rotatestart", e2)), this._pitching && !i2.pitching && this.fire(new Event("pitchstart", e2));
        }
        _fireMoveEvents(e2) {
          this.fire(new Event("move", e2)), this._zooming && this.fire(new Event("zoom", e2)), this._rotating && this.fire(new Event("rotate", e2)), this._pitching && this.fire(new Event("pitch", e2));
        }
        _afterEase(e2, t2) {
          if (this._easeId && t2 && this._easeId === t2)
            return;
          this._easeId = void 0, this.transform.cameraElevationReference = "ground";
          const i2 = this._zooming, r2 = this._rotating, n2 = this._pitching;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, i2 && this.fire(new Event("zoomend", e2)), r2 && this.fire(new Event("rotateend", e2)), n2 && this.fire(new Event("pitchend", e2)), this.fire(new Event("moveend", e2));
        }
        flyTo(e2, t2) {
          if (!e2.essential && Je.prefersReducedMotion) {
            const i3 = z(e2, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(i3, t2);
          }
          this.stop(), e2 = P({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: S }, e2);
          const i2 = this.transform, r2 = this.getZoom(), n2 = this.getBearing(), o2 = this.getPitch(), s2 = this.getPadding(), a2 = "zoom" in e2 ? A(+e2.zoom, i2.minZoom, i2.maxZoom) : r2, l2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, n2) : n2, c2 = "pitch" in e2 ? +e2.pitch : o2, u2 = "padding" in e2 ? e2.padding : i2.padding, h2 = i2.zoomScale(a2 - r2), p2 = d.convert(e2.offset);
          let f2 = i2.centerPoint.add(p2);
          const m2 = i2.pointLocation(f2), _2 = LngLat.convert(e2.center || m2);
          this._normalizeCenter(_2);
          const g2 = i2.project(m2), y2 = i2.project(_2).sub(g2);
          let x2 = e2.curve;
          const v2 = Math.max(i2.width, i2.height), b2 = v2 / h2, w2 = y2.mag();
          if ("minZoom" in e2) {
            const t3 = A(Math.min(e2.minZoom, r2, a2), i2.minZoom, i2.maxZoom), n3 = v2 / i2.zoomScale(t3 - r2);
            x2 = Math.sqrt(n3 / w2 * 2);
          }
          const T2 = x2 * x2;
          function E2(e3) {
            const t3 = (b2 * b2 - v2 * v2 + (e3 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (e3 ? b2 : v2) * T2 * w2);
            return Math.log(Math.sqrt(t3 * t3 + 1) - t3);
          }
          function C2(e3) {
            return (Math.exp(e3) - Math.exp(-e3)) / 2;
          }
          function I2(e3) {
            return (Math.exp(e3) + Math.exp(-e3)) / 2;
          }
          const M2 = E2(0);
          let D2 = function(e3) {
            return I2(M2) / I2(M2 + x2 * e3);
          }, L2 = function(e3) {
            return v2 * ((I2(M2) * (C2(t3 = M2 + x2 * e3) / I2(t3)) - C2(M2)) / T2) / w2;
            var t3;
          }, k2 = (E2(1) - M2) / x2;
          if (Math.abs(w2) < 1e-6 || !isFinite(k2)) {
            if (Math.abs(v2 - b2) < 1e-6)
              return this.easeTo(e2, t2);
            const i3 = b2 < v2 ? -1 : 1;
            k2 = Math.abs(Math.log(b2 / v2)) / x2, L2 = function() {
              return 0;
            }, D2 = function(e3) {
              return Math.exp(i3 * x2 * e3);
            };
          }
          e2.duration = "duration" in e2 ? +e2.duration : 1e3 * k2 / ("screenSpeed" in e2 ? +e2.screenSpeed / x2 : +e2.speed), e2.maxDuration && e2.duration > e2.maxDuration && (e2.duration = 0);
          const B2 = n2 !== l2, R2 = c2 !== o2, F2 = !i2.isPaddingEqual(u2), O2 = (i3) => (h3) => {
            const d2 = h3 * k2, m3 = 1 / D2(d2);
            i3.zoom = 1 === h3 ? a2 : r2 + i3.scaleZoom(m3), B2 && (i3.bearing = Ii(n2, l2, h3)), R2 && (i3.pitch = Ii(o2, c2, h3)), F2 && (i3.interpolatePadding(s2, u2, h3), f2 = i3.centerPoint.add(p2));
            const x3 = 1 === h3 ? _2 : i3.unproject(g2.add(y2.mult(L2(d2))).mult(m3));
            return i3.setLocationAtPoint(i3.renderWorldCopies ? x3.wrap() : x3, f2), i3._updateCameraOnTerrain(), e2.preloadOnly || this._fireMoveEvents(t2), i3;
          };
          if (e2.preloadOnly) {
            const t3 = this._emulate(O2, e2.duration, i2);
            return this._preloadTiles(t3), this;
          }
          return this._zooming = true, this._rotating = B2, this._pitching = R2, this._padding = F2, this._prepareEase(t2, false), this._ease(O2(i2), () => this._afterEase(t2), e2), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(e2, t2) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
            const e3 = this._onEaseEnd;
            this._onEaseEnd = void 0, e3.call(this, t2);
          }
          if (!e2) {
            const e3 = this.handlers;
            e3 && e3.stop(false);
          }
          return this;
        }
        _ease(e2, t2, i2) {
          false === i2.animate || 0 === i2.duration ? (e2(1), t2()) : (this._easeStart = Je.now(), this._easeOptions = i2, this._onEaseFrame = e2, this._onEaseEnd = t2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _renderFrameCallback() {
          const e2 = Math.min((Je.now() - this._easeStart) / this._easeOptions.duration, 1), t2 = this._onEaseFrame;
          t2 && t2(this._easeOptions.easing(e2)), e2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }
        _normalizeBearing(e2, t2) {
          e2 = I(e2, -180, 180);
          const i2 = Math.abs(e2 - t2);
          return Math.abs(e2 - 360 - t2) < i2 && (e2 -= 360), Math.abs(e2 + 360 - t2) < i2 && (e2 += 360), e2;
        }
        _normalizeCenter(e2) {
          const t2 = this.transform;
          if (!t2.renderWorldCopies || t2.maxBounds)
            return;
          const i2 = e2.lng - t2.center.lng;
          e2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
        }
        _emulate(e2, t2, i2) {
          const r2 = Math.ceil(15 * t2 / 1e3), n2 = [], o2 = e2(i2.clone());
          for (let e3 = 0; e3 <= r2; e3++) {
            const t3 = o2(e3 / r2);
            n2.push(t3.clone());
          }
          return n2;
        }
      }
      class AttributionControl {
        constructor(e2 = {}) {
          this.options = e2, O(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(e2) {
          const t2 = this.options && this.options.compact;
          return this._map = e2, this._container = Qe("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = Qe("button", "mapboxgl-ctrl-attrib-button", this._container), Qe("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = Qe("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(e2, t2) {
          const i2 = this._map._getUIString(`AttributionControl.${t2}`);
          e2.setAttribute("aria-label", i2), e2.removeAttribute("title"), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
        }
        _toggleAttribution() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
        }
        _updateEditLink() {
          let e2 = this._editLink;
          e2 || (e2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          const t2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || r.ACCESS_TOKEN }];
          if (e2) {
            const i2 = t2.reduce((e3, i3, r2) => (i3.value && (e3 += `${i3.key}=${i3.value}${r2 < t2.length - 1 ? "&" : ""}`), e3), "?");
            e2.href = `${r.FEEDBACK_URL}/${i2}#${Jf(this._map, true)}`, e2.rel = "noopener nofollow", this._setElementTitle(e2, "MapFeedback");
          }
        }
        _updateData(e2) {
          !e2 || "metadata" !== e2.sourceDataType && "visibility" !== e2.sourceDataType && "style" !== e2.dataType || (this._updateAttributions(), this._updateEditLink());
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let e2 = [];
          if (this._map.style.stylesheet) {
            const e3 = this._map.style.stylesheet;
            this.styleOwner = e3.owner, this.styleId = e3.id;
          }
          const t2 = this._map.style._sourceCaches;
          for (const i3 in t2) {
            const r2 = t2[i3];
            if (r2.used) {
              const t3 = r2.getSource();
              t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
            }
          }
          e2.sort((e3, t3) => e3.length - t3.length), e2 = e2.filter((t3, i3) => {
            for (let r2 = i3 + 1; r2 < e2.length; r2++)
              if (e2[r2].indexOf(t3) >= 0)
                return false;
            return true;
          }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = [...this.options.customAttribution, ...e2] : e2.unshift(this.options.customAttribution));
          const i2 = e2.join(" | ");
          i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        }
      }
      class LogoControl {
        constructor() {
          O(["_updateLogo", "_updateCompact"], this);
        }
        onAdd(e2) {
          this._map = e2, this._container = Qe("div", "mapboxgl-ctrl");
          const t2 = Qe("a", "mapboxgl-ctrl-logo");
          return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://www.mapbox.com/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _updateLogo(e2) {
          e2 && "metadata" !== e2.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }
        _logoRequired() {
          if (!this._map.style)
            return true;
          const e2 = this._map.style._sourceCaches;
          if (0 === Object.entries(e2).length)
            return true;
          for (const t2 in e2) {
            const i2 = e2[t2].getSource();
            if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo)
              return false;
          }
          return true;
        }
        _updateCompact() {
          const e2 = this._container.children;
          if (e2.length) {
            const t2 = e2[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? t2.classList.add("mapboxgl-compact") : t2.classList.remove("mapboxgl-compact");
          }
        }
      }
      class TaskQueue {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(e2) {
          const t2 = ++this._id;
          return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
        }
        remove(e2) {
          const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
          for (const t3 of i2)
            if (t3.id === e2)
              return void (t3.cancelled = true);
        }
        run(e2 = 0) {
          const t2 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const i2 of t2)
            if (!i2.cancelled && (i2.callback(e2), this._cleared))
              break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      function ym(e2, t2, i2) {
        if (e2 = new LngLat(e2.lng, e2.lat), t2) {
          const r2 = new LngLat(e2.lng - 360, e2.lat), n2 = new LngLat(e2.lng + 360, e2.lat), o2 = 360 * Math.ceil(Math.abs(e2.lng - i2.center.lng) / 360), s2 = i2.locationPoint(e2).distSqr(t2), a2 = t2.x < 0 || t2.y < 0 || t2.x > i2.width || t2.y > i2.height;
          i2.locationPoint(r2).distSqr(t2) < s2 && (a2 || Math.abs(r2.lng - i2.center.lng) < o2) ? e2 = r2 : i2.locationPoint(n2).distSqr(t2) < s2 && (a2 || Math.abs(n2.lng - i2.center.lng) < o2) && (e2 = n2);
        }
        for (; Math.abs(e2.lng - i2.center.lng) > 180; ) {
          const t3 = i2.locationPoint(e2);
          if (t3.x >= 0 && t3.y >= 0 && t3.x <= i2.width && t3.y <= i2.height)
            break;
          e2.lng > i2.center.lng ? e2.lng -= 360 : e2.lng += 360;
        }
        return e2;
      }
      const xm = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      class Marker extends Evented {
        constructor(t2, i2) {
          if (super(), (t2 instanceof e.HTMLElement || i2) && (t2 = P({ element: t2 }, i2)), O(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t2 && t2.anchor || "center", this._color = t2 && t2.color || "#3FB1CE", this._scale = t2 && t2.scale || 1, this._draggable = t2 && t2.draggable || false, this._clickTolerance = t2 && t2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t2 && t2.rotation || 0, this._rotationAlignment = t2 && t2.rotationAlignment || "auto", this._pitchAlignment = t2 && t2.pitchAlignment && t2.pitchAlignment || "auto", this._updateMoving = () => this._update(true), this._occludedOpacity = t2 && t2.occludedOpacity || 0.2, t2 && t2.element)
            this._element = t2.element, this._offset = d.convert(t2 && t2.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = Qe("div");
            const e2 = 41, i3 = 27, r3 = et("svg", { display: "block", height: e2 * this._scale + "px", width: i3 * this._scale + "px", viewBox: `0 0 ${i3} ${e2}` }, this._element), n2 = et("radialGradient", { id: "shadowGradient" }, et("defs", {}, r3));
            et("stop", { offset: "10%", "stop-opacity": 0.4 }, n2), et("stop", { offset: "100%", "stop-opacity": 0.05 }, n2), et("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r3), et("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r3), et("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r3), et("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r3), this._offset = d.convert(t2 && t2.offset || [0, -14]);
          }
          this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e2) => {
            e2.preventDefault();
          }), this._element.addEventListener("mousedown", (e2) => {
            e2.preventDefault();
          });
          const r2 = this._element.classList;
          for (const e2 in xm)
            r2.remove(`mapboxgl-marker-anchor-${e2}`);
          r2.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
        }
        addTo(e2) {
          return e2 === this._map || (this.remove(), this._map = e2, e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._updateMoving), e2.on("moveend", this._update), e2.on("remove", this._clearFadeTimer), e2._addMarker(this), this.setDraggable(this._draggable), this._update(), e2.on("click", this._onMapClick)), this;
        }
        remove() {
          const e2 = this._map;
          return e2 && (e2.off("click", this._onMapClick), e2.off("move", this._updateMoving), e2.off("moveend", this._update), e2.off("mousedown", this._addDragHandler), e2.off("touchstart", this._addDragHandler), e2.off("mouseup", this._onUp), e2.off("touchend", this._onUp), e2.off("mousemove", this._onMove), e2.off("touchmove", this._onMove), e2.off("remove", this._clearFadeTimer), e2._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e2) {
          return this._lngLat = LngLat.convert(e2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(e2) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
            if (!("offset" in e2.options)) {
              const t2 = 38.1, i2 = 13.5, r2 = Math.sqrt(Math.pow(i2, 2) / 2);
              e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t2], "bottom-left": [r2, -1 * (t2 - i2 + r2)], "bottom-right": [-r2, -1 * (t2 - i2 + r2)], left: [i2, -1 * (t2 - i2)], right: [-i2, -1 * (t2 - i2)] } : this._offset;
            }
            this._popup = e2, e2._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
          }
          return this;
        }
        _onKeyPress(e2) {
          const t2 = e2.code, i2 = e2.charCode || e2.keyCode;
          "Space" !== t2 && "Enter" !== t2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
        }
        _onMapClick(e2) {
          const t2 = e2.originalEvent.target, i2 = this._element;
          this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const e2 = this._popup;
          return e2 ? (e2.isOpen() ? (e2.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e2.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
        }
        _behindTerrain() {
          const e2 = this._map, t2 = this._pos;
          if (!e2 || !t2)
            return false;
          const i2 = e2.unproject(t2), r2 = e2.getFreeCameraOptions();
          if (!r2.position)
            return false;
          const n2 = r2.position.toLngLat();
          return n2.distanceTo(i2) < 0.9 * n2.distanceTo(this._lngLat);
        }
        _evaluateOpacity() {
          const e2 = this._map;
          if (!e2)
            return;
          const t2 = this._pos;
          if (!t2 || t2.x < 0 || t2.x > e2.transform.width || t2.y < 0 || t2.y > e2.transform.height)
            return void this._clearFadeTimer();
          const i2 = e2.unproject(t2);
          let r2;
          e2._showingGlobe() && Uu(e2.transform, this._lngLat) ? r2 = 0 : (r2 = 1 - e2._queryFogOpacity(i2), e2.transform._terrainEnabled() && e2.getTerrain() && this._behindTerrain() && (r2 *= this._occludedOpacity)), this._element.style.opacity = `${r2}`, this._element.style.pointerEvents = r2 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r2), this._fadeTimer = null;
        }
        _clearFadeTimer() {
          this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
        }
        _updateDOM() {
          const e2 = this._pos;
          if (!e2 || !this._map)
            return;
          const t2 = this._offset.mult(this._scale);
          this._element.style.transform = `
            translate(${e2.x}px,${e2.y}px)
            ${xm[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t2.x}px,${t2.y}px)
        `;
        }
        _calculateXYTransform() {
          const e2 = this._pos, t2 = this._map, i2 = this.getPitchAlignment();
          if (!t2 || !e2 || "map" !== i2)
            return "";
          if (!t2._showingGlobe()) {
            const e3 = t2.getPitch();
            return e3 ? `rotateX(${e3}deg)` : "";
          }
          const r2 = x(Ou(t2.transform, this._lngLat)), n2 = e2.sub(Fu(t2.transform)), o2 = Math.abs(n2.x) + Math.abs(n2.y);
          if (0 === o2)
            return "";
          const s2 = r2 / o2;
          return `rotateX(${-n2.y * s2}deg) rotateY(${n2.x * s2}deg)`;
        }
        _calculateZTransform() {
          const e2 = this._pos, t2 = this._map;
          if (!t2 || !e2)
            return "";
          let i2 = 0;
          const r2 = this.getRotationAlignment();
          if ("map" === r2)
            if (t2._showingGlobe()) {
              const e3 = t2.project(new LngLat(this._lngLat.lng, this._lngLat.lat + 1e-3)), r3 = t2.project(new LngLat(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(e3);
              i2 = x(Math.atan2(r3.y, r3.x)) - 90;
            } else
              i2 = -t2.getBearing();
          else if ("horizon" === r2) {
            const r3 = C(4, 6, t2.getZoom()), n2 = Fu(t2.transform);
            n2.y += r3 * t2.transform.height;
            const o2 = e2.sub(n2), s2 = x(Math.atan2(o2.y, o2.x));
            i2 = (s2 > 90 ? s2 - 270 : s2 + 90) * (1 - r3);
          }
          return i2 += this._rotation, i2 ? `rotateZ(${i2}deg)` : "";
        }
        _update(t2) {
          e.cancelAnimationFrame(this._updateFrameId);
          const i2 = this._map;
          i2 && (i2.transform.renderWorldCopies && (this._lngLat = ym(this._lngLat, this._pos, i2.transform)), this._pos = i2.project(this._lngLat), true === t2 ? this._updateFrameId = e.requestAnimationFrame(() => {
            this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
          }) : this._pos = this._pos.round(), i2._requestDomTask(() => {
            this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i2._showingGlobe() || i2.getTerrain() || i2.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
          }));
        }
        getOffset() {
          return this._offset;
        }
        setOffset(e2) {
          return this._offset = d.convert(e2), this._update(), this;
        }
        _onMove(e2) {
          const t2 = this._map;
          if (!t2)
            return;
          const i2 = this._pointerdownPos, r2 = this._positionDelta;
          if (i2 && r2) {
            if (!this._isDragging) {
              const r3 = this._clickTolerance || t2._clickTolerance;
              if (e2.point.dist(i2) < r3)
                return;
              this._isDragging = true;
            }
            this._pos = e2.point.sub(r2), this._lngLat = t2.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new Event("dragstart"))), this.fire(new Event("drag"));
          }
        }
        _onUp() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
          const e2 = this._map;
          e2 && (e2.off("mousemove", this._onMove), e2.off("touchmove", this._onMove)), "active" === this._state && this.fire(new Event("dragend")), this._state = "inactive";
        }
        _addDragHandler(e2) {
          const t2 = this._map, i2 = this._pos;
          t2 && i2 && this._element.contains(e2.originalEvent.target) && (e2.preventDefault(), this._positionDelta = e2.point.sub(i2), this._pointerdownPos = e2.point, this._state = "pending", t2.on("mousemove", this._onMove), t2.on("touchmove", this._onMove), t2.once("mouseup", this._onUp), t2.once("touchend", this._onUp));
        }
        setDraggable(e2) {
          this._draggable = !!e2;
          const t2 = this._map;
          return t2 && (e2 ? (t2.on("mousedown", this._addDragHandler), t2.on("touchstart", this._addDragHandler)) : (t2.off("mousedown", this._addDragHandler), t2.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e2) {
          return this._rotation = e2 || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e2) {
          return this._rotationAlignment = e2 || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
        }
        setPitchAlignment(e2) {
          return this._pitchAlignment = e2 || "auto", this._update(), this;
        }
        getPitchAlignment() {
          return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
        }
        setOccludedOpacity(e2) {
          return this._occludedOpacity = e2 || 0.2, this._update(), this;
        }
        getOccludedOpacity() {
          return this._occludedOpacity;
        }
      }
      const vm = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, bm = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function wm(e2 = new d(0, 0), t2 = "bottom") {
        if ("number" == typeof e2) {
          const i2 = Math.round(Math.sqrt(0.5 * Math.pow(e2, 2)));
          switch (t2) {
            case "top":
              return new d(0, e2);
            case "top-left":
              return new d(i2, i2);
            case "top-right":
              return new d(-i2, i2);
            case "bottom":
              return new d(0, -e2);
            case "bottom-left":
              return new d(i2, -i2);
            case "bottom-right":
              return new d(-i2, -i2);
            case "left":
              return new d(e2, 0);
            case "right":
              return new d(-e2, 0);
          }
          return new d(0, 0);
        }
        return e2 instanceof d || Array.isArray(e2) ? d.convert(e2) : d.convert(e2[t2] || [0, 0]);
      }
      class EasedVariable {
        constructor(e2) {
          this.jumpTo(e2);
        }
        getValue(e2) {
          if (e2 <= this._startTime)
            return this._start;
          if (e2 >= this._endTime)
            return this._end;
          const t2 = b((e2 - this._startTime) / (this._endTime - this._startTime));
          return this._start * (1 - t2) + this._end * t2;
        }
        isEasing(e2) {
          return e2 >= this._startTime && e2 <= this._endTime;
        }
        jumpTo(e2) {
          this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e2, this._end = e2;
        }
        easeTo(e2, t2, i2) {
          this._start = this.getValue(t2), this._end = e2, this._startTime = t2, this._endTime = t2 + i2;
        }
      }
      const Tm = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, Em = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, optimizeForTerrain: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: true }, Sm = { showCompass: true, showZoom: true, visualizePitch: false };
      class MouseRotateWrapper {
        constructor(e2, t2, i2 = false) {
          this._clickTolerance = 10, this.element = t2, this.mouseRotate = new MouseRotateHandler({ clickTolerance: e2.dragRotate._mouseRotate._clickTolerance }), this.map = e2, i2 && (this.mousePitch = new MousePitchHandler({ clickTolerance: e2.dragRotate._mousePitch._clickTolerance })), O(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), t2.addEventListener("mousedown", this.mousedown), t2.addEventListener("touchstart", this.touchstart, { passive: false }), t2.addEventListener("touchmove", this.touchmove), t2.addEventListener("touchend", this.touchend), t2.addEventListener("touchcancel", this.reset);
        }
        down(e2, t2) {
          this.mouseRotate.mousedown(e2, t2), this.mousePitch && this.mousePitch.mousedown(e2, t2), nt();
        }
        move(e2, t2) {
          const i2 = this.map, r2 = this.mouseRotate.mousemoveWindow(e2, t2), n2 = r2 && r2.bearingDelta;
          if (n2 && i2.setBearing(i2.getBearing() + n2), this.mousePitch) {
            const r3 = this.mousePitch.mousemoveWindow(e2, t2), n3 = r3 && r3.pitchDelta;
            n3 && i2.setPitch(i2.getPitch() + n3);
          }
        }
        off() {
          const e2 = this.element;
          e2.removeEventListener("mousedown", this.mousedown), e2.removeEventListener("touchstart", this.touchstart, { passive: false }), e2.removeEventListener("touchmove", this.touchmove), e2.removeEventListener("touchend", this.touchend), e2.removeEventListener("touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          ot(), e.removeEventListener("mousemove", this.mousemove), e.removeEventListener("mouseup", this.mouseup);
        }
        mousedown(t2) {
          this.down(P({}, t2, { ctrlKey: true, preventDefault: () => t2.preventDefault() }), lt(this.element, t2)), e.addEventListener("mousemove", this.mousemove), e.addEventListener("mouseup", this.mouseup);
        }
        mousemove(e2) {
          this.move(e2, lt(this.element, e2));
        }
        mouseup(e2) {
          this.mouseRotate.mouseupWindow(e2), this.mousePitch && this.mousePitch.mouseupWindow(e2), this.offTemp();
        }
        touchstart(e2) {
          1 !== e2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = ct(this.element, e2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e2.preventDefault() }, this._startPos));
        }
        touchmove(e2) {
          1 !== e2.targetTouches.length ? this.reset() : (this._lastPos = ct(this.element, e2.targetTouches)[0], this.move({ preventDefault: () => e2.preventDefault() }, this._lastPos));
        }
        touchend(e2) {
          0 === e2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      const Am = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, Cm = { maxWidth: 100, unit: "metric" };
      function Im(e2, t2, i2) {
        const r2 = Mm(t2), n2 = r2 / t2, o2 = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }[i2];
        this._map._requestDomTask(() => {
          this._container.style.width = e2 * n2 + "px", this._container.innerHTML = `${r2}&nbsp;${o2}`;
        });
      }
      function Mm(e2) {
        const t2 = Math.pow(10, `${Math.floor(e2)}`.length - 1);
        let i2 = e2 / t2;
        return i2 = i2 >= 10 ? 10 : i2 >= 5 ? 5 : i2 >= 3 ? 3 : i2 >= 2 ? 2 : i2 >= 1 ? 1 : function(e3) {
          const t3 = Math.pow(10, Math.ceil(-Math.log(e3) / Math.LN10));
          return Math.round(e3 * t3) / t3;
        }(i2), t2 * i2;
      }
      const Dm = { version: t, supported: Ze, setRTLTextPlugin: function(e2, t2, i2 = false) {
        if (Qn === Xn || Qn === Kn || Qn === Yn)
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        eo = Je.resolveURL(e2), Qn = Xn, Jn = t2, io(), i2 || oo();
      }, getRTLTextPluginStatus: no, Map: class Map$1 extends Camera {
        constructor(t2) {
          if (Ge.mark(Ne.create), null != (t2 = P({}, Em, t2)).minZoom && null != t2.maxZoom && t2.minZoom > t2.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (null != t2.minPitch && null != t2.maxPitch && t2.minPitch > t2.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (null != t2.minPitch && t2.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (null != t2.maxPitch && t2.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (t2.antialias && function(e2) {
            const t3 = e2.navigator ? e2.navigator.userAgent : null;
            return !!Y(e2) && t3 && (t3.match("Version/15.4") || t3.match("Version/15.5") || t3.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
          }(e) && (t2.antialias = false, Z("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Transform(t2.minZoom, t2.maxZoom, t2.minPitch, t2.maxPitch, t2.renderWorldCopies), t2), this._interactive = t2.interactive, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t2.preserveDrawingBuffer, this._antialias = t2.antialias, this._trackResize = t2.trackResize, this._bearingSnap = t2.bearingSnap, this._refreshExpiredTiles = t2.refreshExpiredTiles, this._fadeDuration = t2.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t2.crossSourceCollisions, this._collectResourceTiming = t2.collectResourceTiming, this._optimizeForTerrain = t2.optimizeForTerrain, this._language = this._parseLanguage(t2.language), this._worldview = t2.worldview, this._renderTaskQueue = new TaskQueue(), this._domRenderTaskQueue = new TaskQueue(), this._controls = [], this._markers = [], this._popups = [], this._mapId = k(), this._locale = P({}, Tm, t2.locale), this._clickTolerance = t2.clickTolerance, this._cooperativeGestures = t2.cooperativeGestures, this._performanceMetricsCollection = t2.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new EasedVariable(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._requestManager = new RequestManager(t2.transformRequest, t2.accessToken, t2.testMode), this._silenceAuthErrors = !!t2.testMode, "string" == typeof t2.container) {
            if (this._container = e.document.getElementById(t2.container), !this._container)
              throw new Error(`Container '${t2.container}' not found.`);
          } else {
            if (!(t2.container instanceof e.HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = t2.container;
          }
          if (this._container.childNodes.length > 0 && Z("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t2.maxBounds && this.setMaxBounds(t2.maxBounds), O(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter)
            throw new Error("Failed to initialize WebGL.");
          this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), void 0 !== e && (e.addEventListener("online", this._onWindowOnline, false), e.addEventListener("resize", this._onWindowResize, false), e.addEventListener("orientationchange", this._onWindowResize, false), e.addEventListener("webkitfullscreenchange", this._onWindowResize, false), e.addEventListener("visibilitychange", this._onVisibilityChange, false)), this.handlers = new HandlerManager(this, t2), this._localFontFamily = t2.localFontFamily, this._localIdeographFontFamily = t2.localIdeographFontFamily, t2.style && this.setStyle(t2.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t2.projection && this.setProjection(t2.projection), this._hash = t2.hash && new Hash("string" == typeof t2.hash && t2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t2.center, zoom: t2.zoom, bearing: t2.bearing, pitch: t2.pitch }), t2.bounds && (this.resize(), this.fitBounds(t2.bounds, P({}, t2.fitBoundsOptions, { duration: 0 })))), this.resize(), t2.attributionControl && this.addControl(new AttributionControl({ customAttribution: t2.customAttribution })), this._logoControl = new LogoControl(), this.addControl(this._logoControl, t2.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (e2) => {
            this._update("style" === e2.dataType), this.fire(new Event(`${e2.dataType}data`, e2));
          }), this.on("dataloading", (e2) => {
            this.fire(new Event(`${e2.dataType}dataloading`, e2));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(e2, t2) {
          if (void 0 === t2 && (t2 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd)
            return this.fire(new ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i2 = e2.onAdd(this);
          this._controls.push(e2);
          const r2 = this._controlPositions[t2];
          return -1 !== t2.indexOf("bottom") ? r2.insertBefore(i2, r2.firstChild) : r2.appendChild(i2), this;
        }
        removeControl(e2) {
          if (!e2 || !e2.onRemove)
            return this.fire(new ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const t2 = this._controls.indexOf(e2);
          return t2 > -1 && this._controls.splice(t2, 1), e2.onRemove(this), this;
        }
        hasControl(e2) {
          return this._controls.indexOf(e2) > -1;
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        resize(e2) {
          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
            return this;
          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
          const t2 = !this._moving;
          return t2 && this.fire(new Event("movestart", e2)).fire(new Event("move", e2)), this.fire(new Event("resize", e2)), t2 && this.fire(new Event("moveend", e2)), this;
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds() || null;
        }
        setMaxBounds(e2) {
          return this.transform.setMaxBounds(LngLatBounds.convert(e2)), this._update();
        }
        setMinZoom(e2) {
          if ((e2 = null == e2 ? -2 : e2) >= -2 && e2 <= this.transform.maxZoom)
            return this.transform.minZoom = e2, this._update(), this.getZoom() < e2 ? this.setZoom(e2) : this.fire(new Event("zoomstart")).fire(new Event("zoom")).fire(new Event("zoomend")), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(e2) {
          if ((e2 = null == e2 ? 22 : e2) >= this.transform.minZoom)
            return this.transform.maxZoom = e2, this._update(), this.getZoom() > e2 ? this.setZoom(e2) : this.fire(new Event("zoomstart")).fire(new Event("zoom")).fire(new Event("zoomend")), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(e2) {
          if ((e2 = null == e2 ? 0 : e2) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (e2 >= 0 && e2 <= this.transform.maxPitch)
            return this.transform.minPitch = e2, this._update(), this.getPitch() < e2 ? this.setPitch(e2) : this.fire(new Event("pitchstart")).fire(new Event("pitch")).fire(new Event("pitchend")), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(e2) {
          if ((e2 = null == e2 ? 85 : e2) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (e2 >= this.transform.minPitch)
            return this.transform.maxPitch = e2, this._update(), this.getPitch() > e2 ? this.setPitch(e2) : this.fire(new Event("pitchstart")).fire(new Event("pitch")).fire(new Event("pitchend")), this;
          throw new Error("maxPitch must be greater than or equal to minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(e2) {
          return this.transform.renderWorldCopies = e2, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
        }
        getLanguage() {
          return this._language;
        }
        _parseLanguage(t2) {
          return "auto" === t2 ? e.navigator.language : Array.isArray(t2) ? 0 === t2.length ? void 0 : t2.map((t3) => "auto" === t3 ? e.navigator.language : t3) : t2;
        }
        setLanguage(e2) {
          const t2 = this._parseLanguage(e2);
          if (!this.style || t2 === this._language)
            return this;
          this._language = t2, this.style._reloadSources();
          for (const e3 of this._controls)
            e3._setLanguage && e3._setLanguage(this._language);
          return this;
        }
        getWorldview() {
          return this._worldview;
        }
        setWorldview(e2) {
          return this.style && e2 !== this._worldview ? (this._worldview = e2, this.style._reloadSources(), this) : this;
        }
        getProjection() {
          return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
        }
        _showingGlobe() {
          return "globe" === this.transform.projection.name;
        }
        setProjection(e2) {
          return this._lazyInitEmptyStyle(), e2 ? "string" == typeof e2 && (e2 = { name: e2 }) : e2 = null, this._useExplicitProjection = !!e2, this._prioritizeAndUpdateProjection(e2, this.style.stylesheet ? this.style.stylesheet.projection : null);
        }
        _updateProjectionTransition() {
          if ("globe" !== this.getProjection().name)
            return;
          const e2 = this.transform, t2 = e2.projection.name;
          let i2;
          "globe" === t2 && e2.zoom >= 6 ? (e2.setMercatorFromTransition(), i2 = true) : "mercator" === t2 && e2.zoom < 6 && (e2.setProjection({ name: "globe" }), i2 = true), i2 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
        }
        _prioritizeAndUpdateProjection(e2, t2) {
          return this._updateProjection(e2 || t2 || { name: "mercator" });
        }
        _updateProjection(e2) {
          let t2;
          if (t2 = "globe" === e2.name && this.transform.zoom >= 6 ? this.transform.setMercatorFromTransition() : this.transform.setProjection(e2), this.style.applyProjectionUpdate(), t2) {
            this.painter.clearBackgroundTiles();
            for (const e3 in this.style._sourceCaches)
              this.style._sourceCaches[e3].clearTiles();
            this._update(true), this._forceMarkerAndPopupUpdate(true);
          }
          return this;
        }
        project(e2) {
          return this.transform.locationPoint3D(LngLat.convert(e2));
        }
        unproject(e2) {
          return this.transform.pointLocation3D(d.convert(e2));
        }
        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving() || false;
        }
        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming() || false;
        }
        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating() || false;
        }
        _isDragging() {
          return this.handlers && this.handlers._isDragging() || false;
        }
        _createDelegatedListener(e2, t2, i2) {
          if ("mouseenter" === e2 || "mouseover" === e2) {
            let r2 = false;
            const n2 = (n3) => {
              const o3 = t2.filter((e3) => this.getLayer(e3)), s2 = o3.length ? this.queryRenderedFeatures(n3.point, { layers: o3 }) : [];
              s2.length ? r2 || (r2 = true, i2.call(this, new MapMouseEvent(e2, this, n3.originalEvent, { features: s2 }))) : r2 = false;
            }, o2 = () => {
              r2 = false;
            };
            return { layers: new Set(t2), listener: i2, delegates: { mousemove: n2, mouseout: o2 } };
          }
          if ("mouseleave" === e2 || "mouseout" === e2) {
            let r2 = false;
            const n2 = (n3) => {
              const o3 = t2.filter((e3) => this.getLayer(e3));
              (o3.length ? this.queryRenderedFeatures(n3.point, { layers: o3 }) : []).length ? r2 = true : r2 && (r2 = false, i2.call(this, new MapMouseEvent(e2, this, n3.originalEvent)));
            }, o2 = (t3) => {
              r2 && (r2 = false, i2.call(this, new MapMouseEvent(e2, this, t3.originalEvent)));
            };
            return { layers: new Set(t2), listener: i2, delegates: { mousemove: n2, mouseout: o2 } };
          }
          {
            const r2 = (e3) => {
              const r3 = t2.filter((e4) => this.getLayer(e4)), n2 = r3.length ? this.queryRenderedFeatures(e3.point, { layers: r3 }) : [];
              n2.length && (e3.features = n2, i2.call(this, e3), delete e3.features);
            };
            return { layers: new Set(t2), listener: i2, delegates: { [e2]: r2 } };
          }
        }
        on(e2, t2, i2) {
          if (void 0 === i2)
            return super.on(e2, t2);
          Array.isArray(t2) || (t2 = [t2]);
          const r2 = this._createDelegatedListener(e2, t2, i2);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(r2);
          for (const e3 in r2.delegates)
            this.on(e3, r2.delegates[e3]);
          return this;
        }
        once(e2, t2, i2) {
          if (void 0 === i2)
            return super.once(e2, t2);
          Array.isArray(t2) || (t2 = [t2]);
          const r2 = this._createDelegatedListener(e2, t2, i2);
          for (const e3 in r2.delegates)
            this.once(e3, r2.delegates[e3]);
          return this;
        }
        off(e2, t2, i2) {
          if (void 0 === i2)
            return super.off(e2, t2);
          t2 = new Set(Array.isArray(t2) ? t2 : [t2]);
          const r2 = (e3, t3) => {
            if (e3.size !== t3.size)
              return false;
            for (const i3 of e3)
              if (!t3.has(i3))
                return false;
            return true;
          }, n2 = this._delegatedListeners ? this._delegatedListeners[e2] : void 0;
          return n2 && ((e3) => {
            for (let n3 = 0; n3 < e3.length; n3++) {
              const o2 = e3[n3];
              if (o2.listener === i2 && r2(o2.layers, t2)) {
                for (const e4 in o2.delegates)
                  this.off(e4, o2.delegates[e4]);
                return e3.splice(n3, 1), this;
              }
            }
          })(n2), this;
        }
        queryRenderedFeatures(e2, t2) {
          return this.style ? (void 0 !== t2 || void 0 === e2 || e2 instanceof d || Array.isArray(e2) || (t2 = e2, e2 = void 0), this.style.queryRenderedFeatures(e2 = e2 || [[0, 0], [this.transform.width, this.transform.height]], t2 = t2 || {}, this.transform)) : [];
        }
        querySourceFeatures(e2, t2) {
          return this.style.querySourceFeatures(e2, t2);
        }
        setStyle(e2, t2) {
          return false !== (t2 = P({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, t2)).diff && t2.localIdeographFontFamily === this._localIdeographFontFamily && t2.localFontFamily === this._localFontFamily && this.style && e2 ? (this._diffStyle(e2, t2), this) : (this._localIdeographFontFamily = t2.localIdeographFontFamily, this._localFontFamily = t2.localFontFamily, this._updateStyle(e2, t2));
        }
        _getUIString(e2) {
          const t2 = this._locale[e2];
          if (null == t2)
            throw new Error(`Missing UI string '${e2}'`);
          return t2;
        }
        _updateStyle(e2, t2) {
          return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e2 && (this.style = new Style(this, t2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e2 ? this.style.loadURL(e2) : this.style.loadJSON(e2)), this._updateTerrain(), this;
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Style(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(e2, t2) {
          if ("string" == typeof e2) {
            const i2 = this._requestManager.normalizeStyleURL(e2), r2 = this._requestManager.transformRequest(i2, pe.Style);
            me(r2, (e3, i3) => {
              e3 ? this.fire(new ErrorEvent(e3)) : i3 && this._updateDiff(i3, t2);
            });
          } else
            "object" == typeof e2 && this._updateDiff(e2, t2);
        }
        _updateDiff(e2, t2) {
          try {
            this.style.setState(e2) && this._update(true);
          } catch (i2) {
            Z(`Unable to perform style diff: ${i2.message || i2.error || i2}.  Rebuilding the style from scratch.`), this._updateStyle(e2, t2);
          }
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : (Z("There is no style added to the map."), false);
        }
        addSource(e2, t2) {
          return this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true);
        }
        isSourceLoaded(e2) {
          return !!this.style && this.style._isSourceCacheLoaded(e2);
        }
        areTilesLoaded() {
          const e2 = this.style && this.style._sourceCaches;
          for (const t2 in e2) {
            const i2 = e2[t2]._tiles;
            for (const e3 in i2) {
              const t3 = i2[e3];
              if ("loaded" !== t3.state && "errored" !== t3.state)
                return false;
            }
          }
          return true;
        }
        addSourceType(e2, t2, i2) {
          this._lazyInitEmptyStyle(), this.style.addSourceType(e2, t2, i2);
        }
        removeSource(e2) {
          return this.style.removeSource(e2), this._updateTerrain(), this._update(true);
        }
        getSource(e2) {
          return this.style.getSource(e2);
        }
        addImage(t2, i2, { pixelRatio: r2 = 1, sdf: n2 = false, stretchX: o2, stretchY: s2, content: a2 } = {}) {
          if (this._lazyInitEmptyStyle(), i2 instanceof e.HTMLImageElement || e.ImageBitmap && i2 instanceof e.ImageBitmap) {
            const { width: e2, height: l2, data: c2 } = Je.getImageData(i2);
            this.style.addImage(t2, { data: new RGBAImage({ width: e2, height: l2 }, c2), pixelRatio: r2, stretchX: o2, stretchY: s2, content: a2, sdf: n2, version: 0 });
          } else if (void 0 === i2.width || void 0 === i2.height)
            this.fire(new ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          else {
            const { width: e2, height: l2 } = i2, c2 = i2;
            this.style.addImage(t2, { data: new RGBAImage({ width: e2, height: l2 }, new Uint8Array(c2.data)), pixelRatio: r2, stretchX: o2, stretchY: s2, content: a2, sdf: n2, version: 0, userImage: c2 }), c2.onAdd && c2.onAdd(this, t2);
          }
        }
        updateImage(t2, i2) {
          const r2 = this.style.getImage(t2);
          if (!r2)
            return void this.fire(new ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const n2 = i2 instanceof e.HTMLImageElement || e.ImageBitmap && i2 instanceof e.ImageBitmap ? Je.getImageData(i2) : i2, { width: o2, height: s2 } = n2;
          void 0 !== o2 && void 0 !== s2 ? o2 === r2.data.width && s2 === r2.data.height ? (r2.data.replace(n2.data, !(i2 instanceof e.HTMLImageElement || e.ImageBitmap && i2 instanceof e.ImageBitmap)), this.style.updateImage(t2, r2)) : this.fire(new ErrorEvent(new Error(`The width and height of the updated image (${o2}, ${s2})
                must be that same as the previous version of the image
                (${r2.data.width}, ${r2.data.height})`))) : this.fire(new ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
        }
        hasImage(e2) {
          return e2 ? !!this.style.getImage(e2) : (this.fire(new ErrorEvent(new Error("Missing required image id"))), false);
        }
        removeImage(e2) {
          this.style.removeImage(e2);
        }
        loadImage(t2, i2) {
          be(this._requestManager.transformRequest(t2, pe.Image), (t3, r2) => {
            i2(t3, r2 instanceof e.HTMLImageElement ? Je.getImageData(r2) : r2);
          });
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(e2, t2) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true);
        }
        moveLayer(e2, t2) {
          return this.style.moveLayer(e2, t2), this._update(true);
        }
        removeLayer(e2) {
          return this.style.removeLayer(e2), this._update(true);
        }
        getLayer(e2) {
          return this.style.getLayer(e2);
        }
        setLayerZoomRange(e2, t2, i2) {
          return this.style.setLayerZoomRange(e2, t2, i2), this._update(true);
        }
        setFilter(e2, t2, i2 = {}) {
          return this.style.setFilter(e2, t2, i2), this._update(true);
        }
        getFilter(e2) {
          return this.style.getFilter(e2);
        }
        setPaintProperty(e2, t2, i2, r2 = {}) {
          return this.style.setPaintProperty(e2, t2, i2, r2), this._update(true);
        }
        getPaintProperty(e2, t2) {
          return this.style.getPaintProperty(e2, t2);
        }
        setLayoutProperty(e2, t2, i2, r2 = {}) {
          return this.style.setLayoutProperty(e2, t2, i2, r2), this._update(true);
        }
        getLayoutProperty(e2, t2) {
          return this.style.getLayoutProperty(e2, t2);
        }
        setLight(e2, t2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(e2, t2), this._update(true);
        }
        getLight() {
          return this.style.getLight();
        }
        setTerrain(e2) {
          return this._lazyInitEmptyStyle(), !e2 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e2), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
        }
        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }
        setFog(e2) {
          return this._lazyInitEmptyStyle(), this.style.setFog(e2), this._update(true);
        }
        getFog() {
          return this.style ? this.style.getFog() : null;
        }
        _queryFogOpacity(e2) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(LngLat.convert(e2), this.transform) : 0;
        }
        setFeatureState(e2, t2) {
          return this.style.setFeatureState(e2, t2), this._update();
        }
        removeFeatureState(e2, t2) {
          return this.style.removeFeatureState(e2, t2), this._update();
        }
        getFeatureState(e2) {
          return this.style.getFeatureState(e2);
        }
        _updateContainerDimensions() {
          if (!this._container)
            return;
          const t2 = this._container.getBoundingClientRect().width || 400, i2 = this._container.getBoundingClientRect().height || 300;
          let r2, n2, o2, s2 = this._container;
          for (; s2 && (!n2 || !o2); ) {
            const t3 = e.getComputedStyle(s2).transform;
            t3 && "none" !== t3 && (r2 = t3.match(/matrix.*\((.+)\)/)[1].split(", "), r2[0] && "0" !== r2[0] && "1" !== r2[0] && (n2 = r2[0]), r2[3] && "0" !== r2[3] && "1" !== r2[3] && (o2 = r2[3])), s2 = s2.parentElement;
          }
          this._containerWidth = n2 ? Math.abs(t2 / n2) : t2, this._containerHeight = o2 ? Math.abs(i2 / o2) : i2;
        }
        _detectMissingCSS() {
          "rgb(250, 128, 114)" !== e.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && Z("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }
        _setupContainer() {
          const e2 = this._container;
          e2.classList.add("mapboxgl-map"), (this._missingCSSCanary = Qe("div", "mapboxgl-canary", e2)).style.visibility = "hidden", this._detectMissingCSS();
          const t2 = this._canvasContainer = Qe("div", "mapboxgl-canvas-container", e2);
          this._interactive && t2.classList.add("mapboxgl-interactive"), this._canvas = Qe("canvas", "mapboxgl-canvas", t2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
          const i2 = this._controlContainer = Qe("div", "mapboxgl-control-container", e2), r2 = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e3) => {
            r2[e3] = Qe("div", `mapboxgl-ctrl-${e3}`, i2);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }
        _resizeCanvas(e2, t2) {
          const i2 = Je.devicePixelRatio || 1;
          this._canvas.width = i2 * Math.ceil(e2), this._canvas.height = i2 * Math.ceil(t2), this._canvas.style.width = `${e2}px`, this._canvas.style.height = `${t2}px`;
        }
        _addMarker(e2) {
          this._markers.push(e2);
        }
        _removeMarker(e2) {
          const t2 = this._markers.indexOf(e2);
          -1 !== t2 && this._markers.splice(t2, 1);
        }
        _addPopup(e2) {
          this._popups.push(e2);
        }
        _removePopup(e2) {
          const t2 = this._popups.indexOf(e2);
          -1 !== t2 && this._popups.splice(t2, 1);
        }
        _setupPainter() {
          const e2 = P({}, Ze.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), t2 = this._canvas.getContext("webgl", e2) || this._canvas.getContext("experimental-webgl", e2);
          t2 ? (je(t2, true), this.painter = new Painter(t2, this.transform), this.on("data", (e3) => {
            "source" === e3.dataType && this.painter.setTileLoadedFlag(true);
          }), n.testSupport(t2)) : this.fire(new ErrorEvent(new Error("Failed to initialize WebGL")));
        }
        _contextLost(e2) {
          e2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new Event("webglcontextlost", { originalEvent: e2 }));
        }
        _contextRestored(e2) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new Event("webglcontextrestored", { originalEvent: e2 }));
        }
        _onMapScroll(e2) {
          if (e2.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(e2) {
          return this.style ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(e2) {
          return this._update(), this._renderTaskQueue.add(e2);
        }
        _cancelRenderFrame(e2) {
          this._renderTaskQueue.remove(e2);
        }
        _requestDomTask(e2) {
          !this.loaded() || this.loaded() && !this.isMoving() ? e2() : this._domRenderTaskQueue.add(e2);
        }
        _render(t2) {
          let i2;
          const r2 = this.painter.context.extTimerQuery, n2 = Je.now();
          if (this.listens("gpu-timing-frame") && (i2 = r2.createQueryEXT(), r2.beginQueryEXT(r2.TIME_ELAPSED_EXT, i2)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e.performance.now())), this._renderTaskQueue.run(t2), this._domRenderTaskQueue.run(t2), this._removed)
            return;
          this._updateProjectionTransition();
          const o2 = this._isInitialLoad ? 0 : this._fadeDuration;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const e2 = this.transform.zoom, t3 = this.transform.pitch, i3 = Je.now(), r3 = new EvaluationParameters(e2, { now: i3, fadeDuration: o2, pitch: t3, transition: this.style.getTransition() });
            this.style.update(r3);
          }
          this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
          let s2 = false;
          if (this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), s2 = this._updateAverageElevation(n2), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s2 = this._updateAverageElevation(n2), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, o2, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: o2, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i2) {
            const t3 = Je.now() - n2;
            r2.endQueryEXT(r2.TIME_ELAPSED_EXT, i2), setTimeout(() => {
              const o3 = r2.getQueryObjectEXT(i2, r2.QUERY_RESULT_EXT) / 1e6;
              r2.deleteQueryEXT(i2), this.fire(new Event("gpu-timing-frame", { cpuTime: t3, gpuTime: o3 })), e.performance.mark("frame-gpu", { startTime: n2, detail: { gpuTime: o3 } });
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const e2 = this.painter.collectGpuTimers();
            setTimeout(() => {
              const t3 = this.painter.queryGpuTimers(e2);
              this.fire(new Event("gpu-timing-layer", { layerTimes: t3 }));
            }, 50);
          }
          if (this.listens("gpu-timing-deferred-render")) {
            const e2 = this.painter.collectDeferredRenderGpuQueries();
            setTimeout(() => {
              const t3 = this.painter.queryGpuTimeDeferredRender(e2);
              this.fire(new Event("gpu-timing-deferred-render", { gpuTime: t3 }));
            }, 50);
          }
          const a2 = this._sourcesDirty || this._styleDirty || this._placementDirty || s2;
          if (a2 || this._repaint)
            this.triggerRepaint();
          else {
            const e2 = !this.isMoving() && this.loaded();
            if (e2 && (s2 = this._updateAverageElevation(n2, true)), s2)
              this.triggerRepaint();
            else if (this._triggerFrame(false), e2 && (this.fire(new Event("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
              const e3 = this._calculateSpeedIndex();
              this.fire(new Event("speedindexcompleted", { speedIndex: e3 })), this.speedIndexTiming = false;
            }
          }
          !this._loaded || this._fullyLoaded || a2 || (this._fullyLoaded = true, Ge.mark(Ne.fullLoad), this._performanceMetricsCollection && Fe(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
        }
        _forceMarkerAndPopupUpdate(e2) {
          for (const t2 of this._markers)
            e2 && !this.getRenderWorldCopies() && (t2._lngLat = t2._lngLat.wrap()), t2._update();
          for (const t2 of this._popups)
            !e2 || this.getRenderWorldCopies() || t2._trackPointer || (t2._lngLat = t2._lngLat.wrap()), t2._update();
        }
        _updateAverageElevation(e2, t2 = false) {
          const i2 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
          if (!this.painter.averageElevationNeedsEasing())
            return 0 !== this.transform.averageElevation && i2(0);
          if ((t2 || e2 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e2)) {
            const t3 = this.transform.averageElevation;
            let r2 = this.transform.sampleAverageElevation(), n2 = false;
            this.transform.elevation && (n2 = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(r2) ? r2 = 0 : this._averageElevationLastSampledAt = e2;
            const o2 = Math.abs(t3 - r2);
            if (o2 > 1) {
              if (this._isInitialLoad || n2)
                return this._averageElevation.jumpTo(r2), i2(r2);
              this._averageElevation.easeTo(r2, e2, 300);
            } else if (o2 > 1e-4)
              return this._averageElevation.jumpTo(r2), i2(r2);
          }
          return !!this._averageElevation.isEasing(e2) && i2(this._averageElevation.getValue(e2));
        }
        _authenticate() {
          Ue(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (e2) => {
            if (e2 && (e2.message === we || 401 === e2.status)) {
              const e3 = this.painter.context.gl;
              je(e3, false), this._logoControl instanceof LogoControl && this._logoControl._updateLogo(), e3 && e3.clear(e3.DEPTH_BUFFER_BIT | e3.COLOR_BUFFER_BIT | e3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), Be(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
          });
        }
        _updateTerrain() {
          const e2 = this._isDragging();
          this.painter.updateTerrain(this.style, e2);
        }
        _calculateSpeedIndex() {
          const e2 = this.painter.canvasCopy(), t2 = this.painter.getCanvasCopiesAndTimestamps();
          t2.timeStamps.push(performance.now());
          const i2 = this.painter.context.gl, r2 = i2.createFramebuffer();
          function n2(e3) {
            i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e3, 0);
            const t3 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
            return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, t3), t3;
          }
          return i2.bindFramebuffer(i2.FRAMEBUFFER, r2), this._canvasPixelComparison(n2(e2), t2.canvasCopies.map(n2), t2.timeStamps);
        }
        _canvasPixelComparison(e2, t2, i2) {
          let r2 = i2[1] - i2[0];
          const n2 = e2.length / 4;
          for (let o2 = 0; o2 < t2.length; o2++) {
            const s2 = t2[o2];
            let a2 = 0;
            for (let t3 = 0; t3 < s2.length; t3 += 4)
              s2[t3] === e2[t3] && s2[t3 + 1] === e2[t3 + 1] && s2[t3 + 2] === e2[t3 + 2] && s2[t3 + 3] === e2[t3 + 3] && (a2 += 1);
            r2 += (i2[o2 + 2] - i2[o2 + 1]) * (1 - a2 / n2);
          }
          return r2;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const e2 of this._controls)
            e2.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e && (e.removeEventListener("resize", this._onWindowResize, false), e.removeEventListener("orientationchange", this._onWindowResize, false), e.removeEventListener("webkitfullscreenchange", this._onWindowResize, false), e.removeEventListener("online", this._onWindowOnline, false), e.removeEventListener("visibilitychange", this._onVisibilityChange, false));
          const t2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          t2 && t2.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), Ve.delete(this.painter.context.gl), this._removed = true, this.fire(new Event("remove"));
        }
        triggerRepaint() {
          this._triggerFrame(true);
        }
        _triggerFrame(e2) {
          this._renderNextFrame = this._renderNextFrame || e2, this.style && !this._frame && (this._frame = Je.frame((e3) => {
            const t2 = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, t2 && this._render(e3);
          }));
        }
        _preloadTiles(e2) {
          return M(this.style ? Object.values(this.style._sourceCaches) : [], (t2, i2) => t2._preloadTiles(e2, i2), () => {
            this.triggerRepaint();
          }), this;
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(e2) {
          this._trackResize && this.resize({ originalEvent: e2 })._update();
        }
        _onVisibilityChange() {
          "hidden" === e.document.visibilityState && this._visibilityHidden++;
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(e2) {
          this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._update());
        }
        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }
        set showTerrainWireframe(e2) {
          this._showTerrainWireframe !== e2 && (this._showTerrainWireframe = e2, this._update());
        }
        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }
        set speedIndexTiming(e2) {
          this._speedIndexTiming !== e2 && (this._speedIndexTiming = e2, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(e2) {
          this._showPadding !== e2 && (this._showPadding = e2, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(e2) {
          this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, e2 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(e2) {
          this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(e2) {
          this._repaint !== e2 && (this._repaint = e2, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(e2) {
          this._vertices = e2, this._update();
        }
        get showTileAABBs() {
          return !!this._showTileAABBs;
        }
        set showTileAABBs(e2) {
          this._showTileAABBs !== e2 && (this._showTileAABBs = e2, e2 && this._update());
        }
        _setCacheLimits(e2, t2) {
          !function(e3, t3) {
            oe = e3, se = t3;
          }(e2, t2);
        }
        get version() {
          return t;
        }
      }, NavigationControl: class NavigationControl {
        constructor(e2) {
          this.options = P({}, Sm, e2), this._container = Qe("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e3) => e3.preventDefault()), this.options.showZoom && (O(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e3) => {
            this._map && this._map.zoomIn({}, { originalEvent: e3 });
          }), Qe("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e3) => {
            this._map && this._map.zoomOut({}, { originalEvent: e3 });
          }), Qe("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (O(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e3) => {
            const t2 = this._map;
            t2 && (this.options.visualizePitch ? t2.resetNorthPitch({}, { originalEvent: e3 }) : t2.resetNorth({}, { originalEvent: e3 }));
          }), this._compassIcon = Qe("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        _updateZoomButtons() {
          const e2 = this._map;
          if (!e2)
            return;
          const t2 = e2.getZoom(), i2 = t2 === e2.getMaxZoom(), r2 = t2 === e2.getMinZoom();
          this._zoomInButton.disabled = i2, this._zoomOutButton.disabled = r2, this._zoomInButton.setAttribute("aria-disabled", i2.toString()), this._zoomOutButton.setAttribute("aria-disabled", r2.toString());
        }
        _rotateCompassArrow() {
          const e2 = this._map;
          if (!e2)
            return;
          const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e2.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e2.transform.pitch}deg) rotateZ(${e2.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e2.transform.angle * (180 / Math.PI)}deg)`;
          e2._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = t2);
          });
        }
        onAdd(e2) {
          return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e2.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e2.on("pitch", this._rotateCompassArrow), e2.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new MouseRotateWrapper(e2, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          const e2 = this._map;
          e2 && (this._container.remove(), this.options.showZoom && e2.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e2.off("pitch", this._rotateCompassArrow), e2.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
        }
        _createButton(e2, t2) {
          const i2 = Qe("button", e2, this._container);
          return i2.type = "button", i2.addEventListener("click", t2), i2;
        }
        _setButtonTitle(e2, t2) {
          if (!this._map)
            return;
          const i2 = this._map._getUIString(`NavigationControl.${t2}`);
          e2.setAttribute("aria-label", i2), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
        }
      }, GeolocateControl: class GeolocateControl extends Evented {
        constructor(t2) {
          super(), this.options = P({ geolocation: e.navigator.geolocation }, Am, t2), O(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Yf(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
        }
        onAdd(e2) {
          return this._map = e2, this._container = Qe("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
        }
        onRemove() {
          void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
        }
        _checkGeolocationSupport(t2) {
          const i2 = (e2 = !!this.options.geolocation) => {
            this._supportsGeolocation = e2, t2(e2);
          };
          void 0 !== this._supportsGeolocation ? t2(this._supportsGeolocation) : void 0 !== e.navigator.permissions ? e.navigator.permissions.query({ name: "geolocation" }).then((e2) => i2("denied" !== e2.state)).catch(() => i2()) : i2();
        }
        _isOutOfMapMaxBounds(e2) {
          const t2 = this._map.getMaxBounds(), i2 = e2.coords;
          return !!t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }
        _onSuccess(e2) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(e2))
              return this._setErrorState(), this.fire(new Event("outofmaxbounds", e2)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = e2, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e2), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e2), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new Event("geolocate", e2)), this._finish();
          }
        }
        _updateCamera(e2) {
          const t2 = new LngLat(e2.coords.longitude, e2.coords.latitude), i2 = e2.coords.accuracy, r2 = P({ bearing: this._map.getBearing() }, this.options.fitBoundsOptions);
          this._map.fitBounds(t2.toBounds(i2), r2, { geolocateSource: true });
        }
        _updateMarker(e2) {
          if (e2) {
            const t2 = new LngLat(e2.coords.longitude, e2.coords.latitude);
            this._accuracyCircleMarker.setLngLat(t2).addTo(this._map), this._userLocationDotMarker.setLngLat(t2).addTo(this._map), this._accuracy = e2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const e2 = this._map.transform, t2 = Vo(1, e2._center.lat) * e2.worldSize, i2 = Math.ceil(2 * this._accuracy * t2);
          this._circleElement.style.width = `${i2}px`, this._circleElement.style.height = `${i2}px`;
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _updateMarkerRotation() {
          this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }
        _onError(e2) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (1 === e2.code) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                const e3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", e3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e3), void 0 !== this._geolocationWatchID && this._clearWatch();
              } else {
                if (3 === e2.code && this._noTimeout)
                  return;
                this._setErrorState();
              }
            "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new Event("error", e2)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(e2) {
          if (void 0 !== this._map) {
            if (this._container.addEventListener("contextmenu", (e3) => e3.preventDefault()), this._geolocateButton = Qe("button", "mapboxgl-ctrl-geolocate", this._container), Qe("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === e2) {
              Z("Geolocation support is not available so the GeolocateControl will be disabled.");
              const e3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", e3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e3);
            } else {
              const e3 = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.setAttribute("aria-label", e3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e3);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = Qe("div", "mapboxgl-user-location"), this._dotElement.appendChild(Qe("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(Qe("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Marker({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = Qe("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Marker({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e3) => {
              e3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e3.originalEvent && "resize" === e3.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new Event("trackuserlocationend")));
            });
          }
        }
        _onDeviceOrientation(e2) {
          this._userLocationDotMarker && (e2.webkitCompassHeading ? this._heading = e2.webkitCompassHeading : true === e2.absolute && (this._heading = -1 * e2.alpha), this._updateMarkerRotationThrottled());
        }
        trigger() {
          if (!this._setup)
            return Z("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new Event("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new Event("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new Event("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
              this._clearWatch();
            else if (void 0 === this._geolocationWatchID) {
              let e2;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e2 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e2), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else
            this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return true;
        }
        _addDeviceOrientationListener() {
          const t2 = () => {
            e.addEventListener("ondeviceorientationabsolute" in e ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
          };
          void 0 !== e.DeviceMotionEvent && "function" == typeof e.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((e2) => {
            "granted" === e2 && t2();
          }).catch(console.error) : t2();
        }
        _clearWatch() {
          this.options.geolocation.clearWatch(this._geolocationWatchID), e.removeEventListener("deviceorientation", this._onDeviceOrientation), e.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, AttributionControl, ScaleControl: class ScaleControl {
        constructor(e2) {
          this.options = P({}, Cm, e2), function() {
            try {
              return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "narrow", unit: "meter" }), true;
            } catch (e3) {
              return false;
            }
          }() || (this._setScale = Im.bind(this)), O(["_update", "_setScale", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _update() {
          const e2 = this.options.maxWidth || 100, t2 = this._map, i2 = t2._containerHeight / 2, r2 = t2._containerWidth / 2 - e2 / 2, n2 = t2.unproject([r2, i2]), o2 = t2.unproject([r2 + e2, i2]), s2 = n2.distanceTo(o2);
          if ("imperial" === this.options.unit) {
            const t3 = 3.2808 * s2;
            t3 > 5280 ? this._setScale(e2, t3 / 5280, "mile") : this._setScale(e2, t3, "foot");
          } else
            "nautical" === this.options.unit ? this._setScale(e2, s2 / 1852, "nautical-mile") : s2 >= 1e3 ? this._setScale(e2, s2 / 1e3, "kilometer") : this._setScale(e2, s2, "meter");
        }
        _setScale(e2, t2, i2) {
          const r2 = Mm(t2), n2 = r2 / t2;
          this._map._requestDomTask(() => {
            this._container.style.width = e2 * n2 + "px", this._container.innerHTML = "nautical-mile" !== i2 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "narrow", unit: i2 }).format(r2) : `${r2}&nbsp;nm`;
          });
        }
        onAdd(e2) {
          return this._map = e2, this._language = e2.getLanguage(), this._container = Qe("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e2.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("move", this._update), this._map = void 0;
        }
        _setLanguage(e2) {
          this._language = e2, this._update();
        }
        setUnit(e2) {
          this.options.unit = e2, this._update();
        }
      }, FullscreenControl: class FullscreenControl {
        constructor(t2) {
          this._fullscreen = false, t2 && t2.container && (t2.container instanceof e.HTMLElement ? this._container = t2.container : Z("Full screen control 'container' must be a DOM element.")), O(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e.document && (this._fullscreenchange = "webkitfullscreenchange");
        }
        onAdd(e2) {
          return this._map = e2, this._container || (this._container = this._map.getContainer()), this._controlContainer = Qe("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", Z("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          this._controlContainer.remove(), this._map = null, e.document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !(!e.document.fullscreenEnabled && !e.document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const t2 = this._fullscreenButton = Qe("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          Qe("span", "mapboxgl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e.document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const e2 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e2);
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (e.document.fullscreenElement || e.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? e.document.exitFullscreen ? e.document.exitFullscreen() : e.document.webkitCancelFullScreen && e.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      }, Popup: class Popup extends Evented {
        constructor(e2) {
          super(), this.options = P(Object.create(vm), e2), O(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(e2 && e2.className ? e2.className.trim().split(/\s+/) : []);
        }
        addTo(e2) {
          return this._map && this.remove(), this._map = e2, this.options.closeOnClick && e2.on("preclick", this._onClose), this.options.closeOnMove && e2.on("move", this._onClose), e2.on("remove", this.remove), this._update(), e2._addPopup(this), this._focusFirstElement(), this._trackPointer ? (e2.on("mousemove", this._onMouseEvent), e2.on("mouseup", this._onMouseEvent), e2._canvasContainer.classList.add("mapboxgl-track-pointer")) : e2.on("move", this._update), this.fire(new Event("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
          const e2 = this._map;
          return e2 && (e2.off("move", this._update), e2.off("move", this._onClose), e2.off("preclick", this._onClose), e2.off("click", this._onClose), e2.off("remove", this.remove), e2.off("mousemove", this._onMouseEvent), e2.off("mouseup", this._onMouseEvent), e2.off("drag", this._onMouseEvent), e2._canvasContainer && e2._canvasContainer.classList.remove("mapboxgl-track-pointer"), e2._removePopup(this), this._map = void 0), this.fire(new Event("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e2) {
          this._lngLat = LngLat.convert(e2), this._pos = null, this._trackPointer = false, this._update();
          const t2 = this._map;
          return t2 && (t2.on("move", this._update), t2.off("mousemove", this._onMouseEvent), t2._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }
        trackPointer() {
          this._trackPointer = true, this._pos = null, this._update();
          const e2 = this._map;
          return e2 && (e2.off("move", this._update), e2.on("mousemove", this._onMouseEvent), e2.on("drag", this._onMouseEvent), e2._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(t2) {
          return this.setDOMContent(e.document.createTextNode(t2));
        }
        setHTML(t2) {
          const i2 = e.document.createDocumentFragment(), r2 = e.document.createElement("body");
          let n2;
          for (r2.innerHTML = t2; n2 = r2.firstChild, n2; )
            i2.appendChild(n2);
          return this.setDOMContent(i2);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(e2) {
          return this.options.maxWidth = e2, this._update(), this;
        }
        setDOMContent(e2) {
          let t2 = this._content;
          if (t2)
            for (; t2.hasChildNodes(); )
              t2.firstChild && t2.removeChild(t2.firstChild);
          else
            t2 = this._content = Qe("div", "mapboxgl-popup-content", this._container || void 0);
          if (t2.appendChild(e2), this.options.closeButton) {
            const e3 = this._closeButton = Qe("button", "mapboxgl-popup-close-button", t2);
            e3.type = "button", e3.setAttribute("aria-label", "Close popup"), e3.setAttribute("aria-hidden", "true"), e3.innerHTML = "&#215;", e3.addEventListener("click", this._onClose);
          }
          return this._update(), this._focusFirstElement(), this;
        }
        addClassName(e2) {
          return this._classList.add(e2), this._updateClassList(), this;
        }
        removeClassName(e2) {
          return this._classList.delete(e2), this._updateClassList(), this;
        }
        setOffset(e2) {
          return this.options.offset = e2, this._update(), this;
        }
        toggleClassName(e2) {
          let t2;
          return this._classList.delete(e2) ? t2 = false : (this._classList.add(e2), t2 = true), this._updateClassList(), t2;
        }
        _onMouseEvent(e2) {
          this._update(e2.point);
        }
        _getAnchor(e2) {
          if (this.options.anchor)
            return this.options.anchor;
          const t2 = this._map, i2 = this._container, r2 = this._pos;
          if (!t2 || !i2 || !r2)
            return "bottom";
          const n2 = i2.offsetWidth, o2 = i2.offsetHeight, s2 = r2.x < n2 / 2, a2 = r2.x > t2.transform.width - n2 / 2;
          if (r2.y + e2 < o2)
            return s2 ? "top-left" : a2 ? "top-right" : "top";
          if (r2.y > t2.transform.height - o2) {
            if (s2)
              return "bottom-left";
            if (a2)
              return "bottom-right";
          }
          return s2 ? "left" : a2 ? "right" : "bottom";
        }
        _updateClassList() {
          const e2 = this._container;
          if (!e2)
            return;
          const t2 = [...this._classList];
          t2.push("mapboxgl-popup"), this._anchor && t2.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t2.push("mapboxgl-popup-track-pointer"), e2.className = t2.join(" ");
        }
        _update(e2) {
          const t2 = this._map, i2 = this._content;
          if (!t2 || !this._lngLat && !this._trackPointer || !i2)
            return;
          let r2 = this._container;
          if (r2 || (r2 = this._container = Qe("div", "mapboxgl-popup", t2.getContainer()), this._tip = Qe("div", "mapboxgl-popup-tip", r2), r2.appendChild(i2)), this.options.maxWidth && r2.style.maxWidth !== this.options.maxWidth && (r2.style.maxWidth = this.options.maxWidth), t2.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = ym(this._lngLat, this._pos, t2.transform)), !this._trackPointer || e2) {
            const i3 = this._pos = this._trackPointer && e2 ? e2 : t2.project(this._lngLat), r3 = wm(this.options.offset), n2 = this._anchor = this._getAnchor(r3.y), o2 = wm(this.options.offset, n2), s2 = i3.add(o2).round();
            t2._requestDomTask(() => {
              this._container && n2 && (this._container.style.transform = `${xm[n2]} translate(${s2.x}px,${s2.y}px)`);
            });
          }
          if (!this._marker && t2._showingGlobe()) {
            const e3 = Uu(t2.transform, this._lngLat) ? 0 : 1;
            this._setOpacity(e3);
          }
          this._updateClassList();
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const e2 = this._container.querySelector(bm);
          e2 && e2.focus();
        }
        _onClose() {
          this.remove();
        }
        _setOpacity(e2) {
          this._container && (this._container.style.opacity = `${e2}`), this._content && (this._content.style.pointerEvents = e2 ? "auto" : "none");
        }
      }, Marker, Style, LngLat, LngLatBounds, Point: d, MercatorCoordinate, FreeCameraOptions, Evented, config: r, prewarm: function() {
        yp().acquire(_p);
      }, clearPrewarmedResources: function() {
        const e2 = gp;
        e2 && (e2.isPreloaded() && 1 === e2.numActive() ? (e2.release(_p), gp = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, get accessToken() {
        return r.ACCESS_TOKEN;
      }, set accessToken(e2) {
        r.ACCESS_TOKEN = e2;
      }, get baseApiUrl() {
        return r.API_URL;
      }, set baseApiUrl(e2) {
        r.API_URL = e2;
      }, get workerCount() {
        return WorkerPool.workerCount;
      }, set workerCount(e2) {
        WorkerPool.workerCount = e2;
      }, get maxParallelImageRequests() {
        return r.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(e2) {
        r.MAX_PARALLEL_IMAGE_REQUESTS = e2;
      }, clearStorage(t2) {
        !function(t3) {
          if (!ae())
            return;
          const i2 = e.caches.delete(ie);
          t3 && i2.catch(t3).then(() => t3());
        }(t2);
      }, workerUrl: "", workerClass: null, setNow: Je.setNow, restoreNow: Je.restoreNow };
      return Dm;
    });
  }
});
export default require_mapbox_gl_csp();
//# sourceMappingURL=mapbox-gl_dist_mapbox-gl-csp.js.map
